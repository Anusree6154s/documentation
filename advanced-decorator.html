<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>More about Advanced Decorator | Blog &amp; Docs</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="More about Advanced Decorator" />
<meta name="author" content="Anusree Anilkumar" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Advanced Decorator Usage Decorators in TypeScript are a powerful feature, primarily used for metadata reflection in frameworks like Angular. They allow you to modify or annotate classes, methods, properties, and parameters. In Angular, decorators are extensively used for features like dependency injection, routing, and more. Key Concepts: What is a Decorator? A decorator is a special kind of function that can be attached to a class, method, property, or parameter to modify or add metadata to it. Decorators are commonly used in frameworks like Angular and NestJS to add extra functionality to components, services, and other entities. Types of Decorators: Class Decorators: Used to modify or annotate classes. Method Decorators: Used to modify methods. Property Decorators: Used to modify properties. Parameter Decorators: Used to modify method parameters. Class Decorators: Class decorators are functions that take the class constructor as an argument and can modify its behavior or add metadata. Example: A simple class decorator: function Injectable(target: Function) { console.log(`Injectable: ${target.name}`); } @Injectable class MyService {} How it works: The Injectable decorator takes the class constructor (target) and logs a message with the class name. The @Injectable decorator is applied to the MyService class, making it injectable (this concept is widely used in Angular for dependency injection). Decorator Syntax: Decorator Declaration: A decorator is defined as a function that typically takes arguments like the target class, method, or property. Decorator Application: You apply a decorator by prefixing it with the @ symbol before a class, method, property, or parameter. Advanced Use Cases for Decorators: Metadata Reflection: Decorators are often used in frameworks like Angular for dependency injection, routing, and more by attaching metadata to classes and methods. For instance, Angular uses the @Injectable decorator to mark services that can be injected into other components or services. Method Decorators: You can create decorators to modify or enhance the behavior of methods, such as logging, authentication, etc. Example: function Log( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { const originalMethod = descriptor.value; descriptor.value = function (...args: any[]) { console.log( `Calling ${propertyKey} with arguments: ${JSON.stringify(args)}` ); return originalMethod.apply(this, args); }; } class Calculator { @Log add(a: number, b: number) { return a + b; } } const calc = new Calculator(); calc.add(2, 3); // Logs: Calling add with arguments: [2,3] How it works: The @Log decorator wraps the add method to log the arguments every time it’s called. Dependency Injection in Angular (Example): Decorators like @Injectable, @Component, and @Directive in Angular are used to add metadata for dependency injection and component configuration. Example: Angular-style @Injectable decorator: function Injectable(target: Function) { console.log(`${target.name} is injectable!`); } @Injectable class MyService { // Service logic } How it works: The @Injectable decorator marks MyService as a service that can be injected into other parts of the application, helping Angular’s dependency injection system manage instances of MyService. Parameter Decorators: These decorators are used to modify the behavior or add metadata to method parameters. Example: function Param(target: any, propertyKey: string, parameterIndex: number) { console.log( `Parameter at index ${parameterIndex} in method ${propertyKey} was decorated` ); } class MyClass { greet(@Param name: string) { console.log(`Hello, ${name}!`); } } Use Cases for Decorators in Frameworks: Angular: Dependency injection, lifecycle hooks, component metadata, routing. NestJS: Controllers, services, and route handlers. Logging: Method decorators for logging inputs and outputs. Access Control: Decorators for controlling access to methods based on user roles (e.g., @Role(&#39;admin&#39;)). Summary: Decorators in TypeScript are used to modify or annotate classes, methods, properties, and parameters with additional functionality or metadata. They are widely used in frameworks like Angular for dependency injection and NestJS for routing and middleware handling. Advanced usage includes using decorators for metadata reflection, logging, dependency injection, and more. Examples of common decorators include @Injectable, @Component, @Log, and custom decorators to modify method behavior." />
<meta property="og:description" content="Advanced Decorator Usage Decorators in TypeScript are a powerful feature, primarily used for metadata reflection in frameworks like Angular. They allow you to modify or annotate classes, methods, properties, and parameters. In Angular, decorators are extensively used for features like dependency injection, routing, and more. Key Concepts: What is a Decorator? A decorator is a special kind of function that can be attached to a class, method, property, or parameter to modify or add metadata to it. Decorators are commonly used in frameworks like Angular and NestJS to add extra functionality to components, services, and other entities. Types of Decorators: Class Decorators: Used to modify or annotate classes. Method Decorators: Used to modify methods. Property Decorators: Used to modify properties. Parameter Decorators: Used to modify method parameters. Class Decorators: Class decorators are functions that take the class constructor as an argument and can modify its behavior or add metadata. Example: A simple class decorator: function Injectable(target: Function) { console.log(`Injectable: ${target.name}`); } @Injectable class MyService {} How it works: The Injectable decorator takes the class constructor (target) and logs a message with the class name. The @Injectable decorator is applied to the MyService class, making it injectable (this concept is widely used in Angular for dependency injection). Decorator Syntax: Decorator Declaration: A decorator is defined as a function that typically takes arguments like the target class, method, or property. Decorator Application: You apply a decorator by prefixing it with the @ symbol before a class, method, property, or parameter. Advanced Use Cases for Decorators: Metadata Reflection: Decorators are often used in frameworks like Angular for dependency injection, routing, and more by attaching metadata to classes and methods. For instance, Angular uses the @Injectable decorator to mark services that can be injected into other components or services. Method Decorators: You can create decorators to modify or enhance the behavior of methods, such as logging, authentication, etc. Example: function Log( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { const originalMethod = descriptor.value; descriptor.value = function (...args: any[]) { console.log( `Calling ${propertyKey} with arguments: ${JSON.stringify(args)}` ); return originalMethod.apply(this, args); }; } class Calculator { @Log add(a: number, b: number) { return a + b; } } const calc = new Calculator(); calc.add(2, 3); // Logs: Calling add with arguments: [2,3] How it works: The @Log decorator wraps the add method to log the arguments every time it’s called. Dependency Injection in Angular (Example): Decorators like @Injectable, @Component, and @Directive in Angular are used to add metadata for dependency injection and component configuration. Example: Angular-style @Injectable decorator: function Injectable(target: Function) { console.log(`${target.name} is injectable!`); } @Injectable class MyService { // Service logic } How it works: The @Injectable decorator marks MyService as a service that can be injected into other parts of the application, helping Angular’s dependency injection system manage instances of MyService. Parameter Decorators: These decorators are used to modify the behavior or add metadata to method parameters. Example: function Param(target: any, propertyKey: string, parameterIndex: number) { console.log( `Parameter at index ${parameterIndex} in method ${propertyKey} was decorated` ); } class MyClass { greet(@Param name: string) { console.log(`Hello, ${name}!`); } } Use Cases for Decorators in Frameworks: Angular: Dependency injection, lifecycle hooks, component metadata, routing. NestJS: Controllers, services, and route handlers. Logging: Method decorators for logging inputs and outputs. Access Control: Decorators for controlling access to methods based on user roles (e.g., @Role(&#39;admin&#39;)). Summary: Decorators in TypeScript are used to modify or annotate classes, methods, properties, and parameters with additional functionality or metadata. They are widely used in frameworks like Angular for dependency injection and NestJS for routing and middleware handling. Advanced usage includes using decorators for metadata reflection, logging, dependency injection, and more. Examples of common decorators include @Injectable, @Component, @Log, and custom decorators to modify method behavior." />
<link rel="canonical" href="https://anusree6154s.github.io/documentation/advanced-decorator" />
<meta property="og:url" content="https://anusree6154s.github.io/documentation/advanced-decorator" />
<meta property="og:site_name" content="Blog &amp; Docs" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-01-19T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="More about Advanced Decorator" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Anusree Anilkumar"},"dateModified":"2025-01-19T00:00:00+00:00","datePublished":"2025-01-19T00:00:00+00:00","description":"Advanced Decorator Usage Decorators in TypeScript are a powerful feature, primarily used for metadata reflection in frameworks like Angular. They allow you to modify or annotate classes, methods, properties, and parameters. In Angular, decorators are extensively used for features like dependency injection, routing, and more. Key Concepts: What is a Decorator? A decorator is a special kind of function that can be attached to a class, method, property, or parameter to modify or add metadata to it. Decorators are commonly used in frameworks like Angular and NestJS to add extra functionality to components, services, and other entities. Types of Decorators: Class Decorators: Used to modify or annotate classes. Method Decorators: Used to modify methods. Property Decorators: Used to modify properties. Parameter Decorators: Used to modify method parameters. Class Decorators: Class decorators are functions that take the class constructor as an argument and can modify its behavior or add metadata. Example: A simple class decorator: function Injectable(target: Function) { console.log(`Injectable: ${target.name}`); } @Injectable class MyService {} How it works: The Injectable decorator takes the class constructor (target) and logs a message with the class name. The @Injectable decorator is applied to the MyService class, making it injectable (this concept is widely used in Angular for dependency injection). Decorator Syntax: Decorator Declaration: A decorator is defined as a function that typically takes arguments like the target class, method, or property. Decorator Application: You apply a decorator by prefixing it with the @ symbol before a class, method, property, or parameter. Advanced Use Cases for Decorators: Metadata Reflection: Decorators are often used in frameworks like Angular for dependency injection, routing, and more by attaching metadata to classes and methods. For instance, Angular uses the @Injectable decorator to mark services that can be injected into other components or services. Method Decorators: You can create decorators to modify or enhance the behavior of methods, such as logging, authentication, etc. Example: function Log( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { const originalMethod = descriptor.value; descriptor.value = function (...args: any[]) { console.log( `Calling ${propertyKey} with arguments: ${JSON.stringify(args)}` ); return originalMethod.apply(this, args); }; } class Calculator { @Log add(a: number, b: number) { return a + b; } } const calc = new Calculator(); calc.add(2, 3); // Logs: Calling add with arguments: [2,3] How it works: The @Log decorator wraps the add method to log the arguments every time it’s called. Dependency Injection in Angular (Example): Decorators like @Injectable, @Component, and @Directive in Angular are used to add metadata for dependency injection and component configuration. Example: Angular-style @Injectable decorator: function Injectable(target: Function) { console.log(`${target.name} is injectable!`); } @Injectable class MyService { // Service logic } How it works: The @Injectable decorator marks MyService as a service that can be injected into other parts of the application, helping Angular’s dependency injection system manage instances of MyService. Parameter Decorators: These decorators are used to modify the behavior or add metadata to method parameters. Example: function Param(target: any, propertyKey: string, parameterIndex: number) { console.log( `Parameter at index ${parameterIndex} in method ${propertyKey} was decorated` ); } class MyClass { greet(@Param name: string) { console.log(`Hello, ${name}!`); } } Use Cases for Decorators in Frameworks: Angular: Dependency injection, lifecycle hooks, component metadata, routing. NestJS: Controllers, services, and route handlers. Logging: Method decorators for logging inputs and outputs. Access Control: Decorators for controlling access to methods based on user roles (e.g., @Role(&#39;admin&#39;)). Summary: Decorators in TypeScript are used to modify or annotate classes, methods, properties, and parameters with additional functionality or metadata. They are widely used in frameworks like Angular for dependency injection and NestJS for routing and middleware handling. Advanced usage includes using decorators for metadata reflection, logging, dependency injection, and more. Examples of common decorators include @Injectable, @Component, @Log, and custom decorators to modify method behavior.","headline":"More about Advanced Decorator","mainEntityOfPage":{"@type":"WebPage","@id":"https://anusree6154s.github.io/documentation/advanced-decorator"},"url":"https://anusree6154s.github.io/documentation/advanced-decorator"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/documentation/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://anusree6154s.github.io/documentation/feed.xml" title="Blog &amp; Docs" /></head>
<body><header class="site-header">
  <div class="loader"></div>

    <div class="wrapper"><!-- <a class="site-title" rel="author" href="/documentation/">Blog &amp; Docs</a> -->
          <a class="site-title"  rel="author" href="/documentation/"><span>BITS</span><span> & </span><span>BYTES</span></a><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewBox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
              </svg>
            </span>
          </label>
  
          <div class="trigger">
            <!--<a class="page-link" href="/documentation/about">About Me</a>-->

            <a class="page-link" href="/documentation/#latest-posts">LATEST POSTS</a>
            <a class="page-link" href="/documentation/all-posts">ALL POSTS</a>
            <a class="page-link" href="/documentation/#projects">PROJECTS</a>
            <a class="page-link" href="/documentation/#profile">PROFILE</a>
            <a class="page-link" href="/documentation/#contact">CONTACT</a>
          </div>
        </nav></div>
    
  </header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  


  <header class="post-header">
    
      
        <div class="parent-link">
          This post is part of <a href="/documentation/typescript-learners-guide">Typescript learners guide</a>.
        </div>
    
    <h1 class="post-title p-name" itemprop="name headline">More about Advanced Decorator</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-01-19T00:00:00+00:00" itemprop="datePublished">19 Jan 2025
      </time></p>
      <p class="tag-container"><span  class="tag-badge">
            typescript
        </span><span  class="tag-badge">
            advanced decorator
        </span></span>
</p>
  </header> 

  

  <div class="post-content e-content" itemprop="articleBody">
    <h3 id="advanced-decorator-usage"><strong>Advanced Decorator Usage</strong></h3>

<p>Decorators in TypeScript are a powerful feature, primarily used for metadata reflection in frameworks like Angular. They allow you to modify or annotate classes, methods, properties, and parameters. In Angular, decorators are extensively used for features like dependency injection, routing, and more.</p>

<p><br /></p>

<h4 id="key-concepts">Key Concepts:</h4>

<ol>
  <li>
    <p><strong>What is a Decorator?</strong></p>

    <ul>
      <li>A decorator is a special kind of function that can be attached to a class, method, property, or parameter to modify or add metadata to it.</li>
      <li>Decorators are commonly used in frameworks like Angular and NestJS to add extra functionality to components, services, and other entities.</li>
    </ul>
  </li>
  <li>
    <p><strong>Types of Decorators</strong>:</p>

    <ul>
      <li><strong>Class Decorators</strong>: Used to modify or annotate classes.</li>
      <li><strong>Method Decorators</strong>: Used to modify methods.</li>
      <li><strong>Property Decorators</strong>: Used to modify properties.</li>
      <li><strong>Parameter Decorators</strong>: Used to modify method parameters.</li>
    </ul>
  </li>
  <li>
    <p><strong>Class Decorators</strong>:</p>

    <ul>
      <li>Class decorators are functions that take the class constructor as an argument and can modify its behavior or add metadata.</li>
    </ul>

    <p><strong>Example: A simple class decorator</strong>:</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Injectable</span><span class="p">(</span><span class="nx">target</span><span class="p">:</span> <span class="nb">Function</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Injectable: </span><span class="p">${</span><span class="nx">target</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">@</span><span class="nd">Injectable</span>
<span class="kd">class</span> <span class="nx">MyService</span> <span class="p">{}</span>
</code></pre></div>    </div>

    <ul>
      <li><strong>How it works</strong>:
        <ul>
          <li>The <code class="language-plaintext highlighter-rouge">Injectable</code> decorator takes the class constructor (<code class="language-plaintext highlighter-rouge">target</code>) and logs a message with the class name.</li>
          <li>The <code class="language-plaintext highlighter-rouge">@Injectable</code> decorator is applied to the <code class="language-plaintext highlighter-rouge">MyService</code> class, making it injectable (this concept is widely used in Angular for dependency injection).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Decorator Syntax</strong>:</p>

    <ul>
      <li><strong>Decorator Declaration</strong>: A decorator is defined as a function that typically takes arguments like the target class, method, or property.</li>
      <li><strong>Decorator Application</strong>: You apply a decorator by prefixing it with the <code class="language-plaintext highlighter-rouge">@</code> symbol before a class, method, property, or parameter.</li>
    </ul>
  </li>
  <li>
    <p><strong>Advanced Use Cases for Decorators</strong>:</p>

    <ul>
      <li>
        <p><strong>Metadata Reflection</strong>:</p>

        <ul>
          <li>Decorators are often used in frameworks like Angular for dependency injection, routing, and more by attaching metadata to classes and methods.</li>
          <li>For instance, Angular uses the <code class="language-plaintext highlighter-rouge">@Injectable</code> decorator to mark services that can be injected into other components or services.</li>
        </ul>
      </li>
      <li>
        <p><strong>Method Decorators</strong>:</p>

        <ul>
          <li>You can create decorators to modify or enhance the behavior of methods, such as logging, authentication, etc.</li>
        </ul>

        <p><strong>Example</strong>:</p>

        <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Log</span><span class="p">(</span>
  <span class="nx">target</span><span class="p">:</span> <span class="kr">any</span><span class="p">,</span>
  <span class="nx">propertyKey</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span>
  <span class="nx">descriptor</span><span class="p">:</span> <span class="nx">PropertyDescriptor</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">originalMethod</span> <span class="o">=</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="nx">descriptor</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(...</span><span class="nx">args</span><span class="p">:</span> <span class="kr">any</span><span class="p">[])</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
      <span class="s2">`Calling </span><span class="p">${</span><span class="nx">propertyKey</span><span class="p">}</span><span class="s2"> with arguments: </span><span class="p">${</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">args</span><span class="p">)}</span><span class="s2">`</span>
    <span class="p">);</span>
    <span class="k">return</span> <span class="nx">originalMethod</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Calculator</span> <span class="p">{</span>
  <span class="p">@</span><span class="nd">Log</span>
  <span class="nx">add</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">calc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Calculator</span><span class="p">();</span>
<span class="nx">calc</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// Logs: Calling add with arguments: [2,3]</span>
</code></pre></div>        </div>

        <ul>
          <li><strong>How it works</strong>: The <code class="language-plaintext highlighter-rouge">@Log</code> decorator wraps the <code class="language-plaintext highlighter-rouge">add</code> method to log the arguments every time it’s called.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Dependency Injection in Angular (Example)</strong>:</p>

    <ul>
      <li>Decorators like <code class="language-plaintext highlighter-rouge">@Injectable</code>, <code class="language-plaintext highlighter-rouge">@Component</code>, and <code class="language-plaintext highlighter-rouge">@Directive</code> in Angular are used to add metadata for dependency injection and component configuration.</li>
    </ul>

    <p><strong>Example: Angular-style <code class="language-plaintext highlighter-rouge">@Injectable</code> decorator</strong>:</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Injectable</span><span class="p">(</span><span class="nx">target</span><span class="p">:</span> <span class="nb">Function</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">target</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2"> is injectable!`</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">@</span><span class="nd">Injectable</span>
<span class="kd">class</span> <span class="nx">MyService</span> <span class="p">{</span>
  <span class="c1">// Service logic</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li><strong>How it works</strong>: The <code class="language-plaintext highlighter-rouge">@Injectable</code> decorator marks <code class="language-plaintext highlighter-rouge">MyService</code> as a service that can be injected into other parts of the application, helping Angular’s dependency injection system manage instances of <code class="language-plaintext highlighter-rouge">MyService</code>.</li>
    </ul>
  </li>
  <li>
    <p><strong>Parameter Decorators</strong>:</p>

    <ul>
      <li>These decorators are used to modify the behavior or add metadata to method parameters.</li>
    </ul>

    <p><strong>Example</strong>:</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Param</span><span class="p">(</span><span class="nx">target</span><span class="p">:</span> <span class="kr">any</span><span class="p">,</span> <span class="nx">propertyKey</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">parameterIndex</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
    <span class="s2">`Parameter at index </span><span class="p">${</span><span class="nx">parameterIndex</span><span class="p">}</span><span class="s2"> in method </span><span class="p">${</span><span class="nx">propertyKey</span><span class="p">}</span><span class="s2"> was decorated`</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
  <span class="nx">greet</span><span class="p">(@</span><span class="nd">Param</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hello, </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">!`</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Use Cases for Decorators in Frameworks</strong>:</p>
    <ul>
      <li><strong>Angular</strong>: Dependency injection, lifecycle hooks, component metadata, routing.</li>
      <li><strong>NestJS</strong>: Controllers, services, and route handlers.</li>
      <li><strong>Logging</strong>: Method decorators for logging inputs and outputs.</li>
      <li><strong>Access Control</strong>: Decorators for controlling access to methods based on user roles (e.g., <code class="language-plaintext highlighter-rouge">@Role('admin')</code>).</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h4 id="summary">Summary:</h4>
<ul>
  <li><strong>Decorators</strong> in TypeScript are used to modify or annotate classes, methods, properties, and parameters with additional functionality or metadata.</li>
  <li>They are widely used in frameworks like <strong>Angular</strong> for dependency injection and <strong>NestJS</strong> for routing and middleware handling.</li>
  <li><strong>Advanced usage</strong> includes using decorators for <strong>metadata reflection</strong>, <strong>logging</strong>, <strong>dependency injection</strong>, and more.</li>
  <li><strong>Examples</strong> of common decorators include <code class="language-plaintext highlighter-rouge">@Injectable</code>, <code class="language-plaintext highlighter-rouge">@Component</code>, <code class="language-plaintext highlighter-rouge">@Log</code>, and custom decorators to modify method behavior.</li>
</ul>

  </div>

  
  <div style="margin-top: 20px;">
  <div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'https://anusree6154s.github.io/documentation/advanced-decorator';
      this.page.identifier = 'https://anusree6154s.github.io/documentation/advanced-decorator';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://anusree-anilkumar-blog.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript><a class="u-url" href="/documentation/advanced-decorator" hidden></a>
</article>
      </div>
    </main><!-- <footer class="site-footer h-card">
    <data class="u-url" href="/documentation/"></data>
  
    <div class="wrapper">
  
      <div class="footer-col-wrapper">
        <div class="footer-col">
          <p class="feed-subscribe">
            <a href="https://anusree6154s.github.io/documentation/feed.xml">
              <svg class="svg-icon orange">
                <path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194
                  11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017 0
                  13.806c0-1.21.983-2.195 2.194-2.195zM10.606
                  16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"
                />
              </svg><span>Subscribe</span>
            </a>
          </p>
          <ul class="contact-list">
            
          </ul>
        </div>
        <div class="footer-col">
          <p>This site is my personal documentation, made public for anyone who might find my code scribbles useful! ❤️</p>
        </div>
      </div>
  
      <div class="social-links"><ul class="social-media-list"><li><a href="https://github.com/Anusree6154s"><svg class="svg-icon"><use xlink:href="/documentation/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Anusree6154s</span></a></li><li><a href="https://www.linkedin.com/in/anusreeanilkumar1"><svg class="svg-icon"><use xlink:href="/documentation/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">anusreeanilkumar1</span></a></li><li><a href="https://www.twitter.com/anu6154s"><svg class="svg-icon"><use xlink:href="/documentation/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">anu6154s</span></a></li><li><a href="/documentation/feed.xml"><svg class="svg-icon"><use xlink:href="/documentation/assets/minima-social-icons.svg#rss"></use></svg> <span>rss</span></a></li></ul>
</div>
  
    </div>
  
  </footer> -->

<footer id="contact">
  <section class="footer-inner">
    <div class="contact">
      <div class="contact-inner">
        <p>CONTACT</p>
        <p>
          <span class="logo"></span><span>anilkumaranusree113@gmail.com</span>
        </p>
        <p><span class="logo"></span><span>+91-9699973230</span></p>
        <p><span class="logo"></span><span>Surat, Gujarat, India</span></p>
      </div>

      <div class="socials">
        <a href="https://www.linkedin.com/in/anusreeanilkumar1/"
          ><span></span
        ></a>
        <a href="https://github.com/Anusree6154s"><span></span></a>
        <a href="https://x.com/anu6154s"><span></span></a>
      </div>
    </div>
    <div class="list">
      <div class="sections">
        <p>SECTIONS</p>
        <a href="/documentation/#latest-posts">Latest Posts</a>
        <a href="/documentation/all-posts">All Posts</a>
        <a href="/documentation/#projects">Projects</a>
        <a href="/documentation/#profile">Profile</a>
      </div>
      <div class="links">
        <p>LINKS</p>
        <a href="https://www.">Personal Portfolio</a>
        <a href="https://www.crio.do/learn/portfolio/anilkumaranusree113/"
          >Crio.Do Portfolio</a
        >
        <a href="https://www.">All Projects</a>
        <a
          href="https://drive.google.com/file/d/1Y8_r1SKBmwClHUr-pszQpEmI3XLBEbTO/view?usp=sharing"
          >Resume</a
        >
      </div>
    </div>
  </section>

  <section class="sub-footer">@ 2025 Anusree Anilkumar</section>
</footer>
</body>

</html>
