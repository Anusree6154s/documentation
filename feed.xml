<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://anusree6154s.github.io/documentation/feed.xml" rel="self" type="application/atom+xml" /><link href="https://anusree6154s.github.io/documentation/" rel="alternate" type="text/html" /><updated>2025-01-19T16:33:53+00:00</updated><id>https://anusree6154s.github.io/documentation/feed.xml</id><title type="html">Blog &amp;amp; Docs</title><subtitle>This site is my personal documentation, made public for anyone who might find my code scribbles useful! ❤️</subtitle><author><name>Anusree Anilkumar</name></author><entry><title type="html">More about Advanced Decorator</title><link href="https://anusree6154s.github.io/documentation/advanced-decorator" rel="alternate" type="text/html" title="More about Advanced Decorator" /><published>2025-01-19T00:00:00+00:00</published><updated>2025-01-19T00:00:00+00:00</updated><id>https://anusree6154s.github.io/documentation/advanced-decorator</id><content type="html" xml:base="https://anusree6154s.github.io/documentation/advanced-decorator"><![CDATA[<h3 id="advanced-decorator-usage"><strong>Advanced Decorator Usage</strong></h3>

<p>Decorators in TypeScript are a powerful feature, primarily used for metadata reflection in frameworks like Angular. They allow you to modify or annotate classes, methods, properties, and parameters. In Angular, decorators are extensively used for features like dependency injection, routing, and more.</p>

<p><br /></p>

<h4 id="key-concepts">Key Concepts:</h4>

<ol>
  <li>
    <p><strong>What is a Decorator?</strong></p>

    <ul>
      <li>A decorator is a special kind of function that can be attached to a class, method, property, or parameter to modify or add metadata to it.</li>
      <li>Decorators are commonly used in frameworks like Angular and NestJS to add extra functionality to components, services, and other entities.</li>
    </ul>
  </li>
  <li>
    <p><strong>Types of Decorators</strong>:</p>

    <ul>
      <li><strong>Class Decorators</strong>: Used to modify or annotate classes.</li>
      <li><strong>Method Decorators</strong>: Used to modify methods.</li>
      <li><strong>Property Decorators</strong>: Used to modify properties.</li>
      <li><strong>Parameter Decorators</strong>: Used to modify method parameters.</li>
    </ul>
  </li>
  <li>
    <p><strong>Class Decorators</strong>:</p>

    <ul>
      <li>Class decorators are functions that take the class constructor as an argument and can modify its behavior or add metadata.</li>
    </ul>

    <p><strong>Example: A simple class decorator</strong>:</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Injectable</span><span class="p">(</span><span class="nx">target</span><span class="p">:</span> <span class="nb">Function</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Injectable: </span><span class="p">${</span><span class="nx">target</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">@</span><span class="nd">Injectable</span>
<span class="kd">class</span> <span class="nx">MyService</span> <span class="p">{}</span>
</code></pre></div>    </div>

    <ul>
      <li><strong>How it works</strong>:
        <ul>
          <li>The <code class="language-plaintext highlighter-rouge">Injectable</code> decorator takes the class constructor (<code class="language-plaintext highlighter-rouge">target</code>) and logs a message with the class name.</li>
          <li>The <code class="language-plaintext highlighter-rouge">@Injectable</code> decorator is applied to the <code class="language-plaintext highlighter-rouge">MyService</code> class, making it injectable (this concept is widely used in Angular for dependency injection).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Decorator Syntax</strong>:</p>

    <ul>
      <li><strong>Decorator Declaration</strong>: A decorator is defined as a function that typically takes arguments like the target class, method, or property.</li>
      <li><strong>Decorator Application</strong>: You apply a decorator by prefixing it with the <code class="language-plaintext highlighter-rouge">@</code> symbol before a class, method, property, or parameter.</li>
    </ul>
  </li>
  <li>
    <p><strong>Advanced Use Cases for Decorators</strong>:</p>

    <ul>
      <li>
        <p><strong>Metadata Reflection</strong>:</p>

        <ul>
          <li>Decorators are often used in frameworks like Angular for dependency injection, routing, and more by attaching metadata to classes and methods.</li>
          <li>For instance, Angular uses the <code class="language-plaintext highlighter-rouge">@Injectable</code> decorator to mark services that can be injected into other components or services.</li>
        </ul>
      </li>
      <li>
        <p><strong>Method Decorators</strong>:</p>

        <ul>
          <li>You can create decorators to modify or enhance the behavior of methods, such as logging, authentication, etc.</li>
        </ul>

        <p><strong>Example</strong>:</p>

        <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Log</span><span class="p">(</span>
  <span class="nx">target</span><span class="p">:</span> <span class="kr">any</span><span class="p">,</span>
  <span class="nx">propertyKey</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span>
  <span class="nx">descriptor</span><span class="p">:</span> <span class="nx">PropertyDescriptor</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">originalMethod</span> <span class="o">=</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="nx">descriptor</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(...</span><span class="nx">args</span><span class="p">:</span> <span class="kr">any</span><span class="p">[])</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
      <span class="s2">`Calling </span><span class="p">${</span><span class="nx">propertyKey</span><span class="p">}</span><span class="s2"> with arguments: </span><span class="p">${</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">args</span><span class="p">)}</span><span class="s2">`</span>
    <span class="p">);</span>
    <span class="k">return</span> <span class="nx">originalMethod</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Calculator</span> <span class="p">{</span>
  <span class="p">@</span><span class="nd">Log</span>
  <span class="nx">add</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">calc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Calculator</span><span class="p">();</span>
<span class="nx">calc</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// Logs: Calling add with arguments: [2,3]</span>
</code></pre></div>        </div>

        <ul>
          <li><strong>How it works</strong>: The <code class="language-plaintext highlighter-rouge">@Log</code> decorator wraps the <code class="language-plaintext highlighter-rouge">add</code> method to log the arguments every time it’s called.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>Dependency Injection in Angular (Example)</strong>:</p>

    <ul>
      <li>Decorators like <code class="language-plaintext highlighter-rouge">@Injectable</code>, <code class="language-plaintext highlighter-rouge">@Component</code>, and <code class="language-plaintext highlighter-rouge">@Directive</code> in Angular are used to add metadata for dependency injection and component configuration.</li>
    </ul>

    <p><strong>Example: Angular-style <code class="language-plaintext highlighter-rouge">@Injectable</code> decorator</strong>:</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Injectable</span><span class="p">(</span><span class="nx">target</span><span class="p">:</span> <span class="nb">Function</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">target</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2"> is injectable!`</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">@</span><span class="nd">Injectable</span>
<span class="kd">class</span> <span class="nx">MyService</span> <span class="p">{</span>
  <span class="c1">// Service logic</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <ul>
      <li><strong>How it works</strong>: The <code class="language-plaintext highlighter-rouge">@Injectable</code> decorator marks <code class="language-plaintext highlighter-rouge">MyService</code> as a service that can be injected into other parts of the application, helping Angular’s dependency injection system manage instances of <code class="language-plaintext highlighter-rouge">MyService</code>.</li>
    </ul>
  </li>
  <li>
    <p><strong>Parameter Decorators</strong>:</p>

    <ul>
      <li>These decorators are used to modify the behavior or add metadata to method parameters.</li>
    </ul>

    <p><strong>Example</strong>:</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Param</span><span class="p">(</span><span class="nx">target</span><span class="p">:</span> <span class="kr">any</span><span class="p">,</span> <span class="nx">propertyKey</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">parameterIndex</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
    <span class="s2">`Parameter at index </span><span class="p">${</span><span class="nx">parameterIndex</span><span class="p">}</span><span class="s2"> in method </span><span class="p">${</span><span class="nx">propertyKey</span><span class="p">}</span><span class="s2"> was decorated`</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
  <span class="nx">greet</span><span class="p">(@</span><span class="nd">Param</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hello, </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">!`</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Use Cases for Decorators in Frameworks</strong>:</p>
    <ul>
      <li><strong>Angular</strong>: Dependency injection, lifecycle hooks, component metadata, routing.</li>
      <li><strong>NestJS</strong>: Controllers, services, and route handlers.</li>
      <li><strong>Logging</strong>: Method decorators for logging inputs and outputs.</li>
      <li><strong>Access Control</strong>: Decorators for controlling access to methods based on user roles (e.g., <code class="language-plaintext highlighter-rouge">@Role('admin')</code>).</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h4 id="summary">Summary:</h4>
<ul>
  <li><strong>Decorators</strong> in TypeScript are used to modify or annotate classes, methods, properties, and parameters with additional functionality or metadata.</li>
  <li>They are widely used in frameworks like <strong>Angular</strong> for dependency injection and <strong>NestJS</strong> for routing and middleware handling.</li>
  <li><strong>Advanced usage</strong> includes using decorators for <strong>metadata reflection</strong>, <strong>logging</strong>, <strong>dependency injection</strong>, and more.</li>
  <li><strong>Examples</strong> of common decorators include <code class="language-plaintext highlighter-rouge">@Injectable</code>, <code class="language-plaintext highlighter-rouge">@Component</code>, <code class="language-plaintext highlighter-rouge">@Log</code>, and custom decorators to modify method behavior.</li>
</ul>]]></content><author><name>Anusree Anilkumar</name></author><category term="typescript" /><category term="advanced decorator" /><summary type="html"><![CDATA[Advanced Decorator Usage Decorators in TypeScript are a powerful feature, primarily used for metadata reflection in frameworks like Angular. They allow you to modify or annotate classes, methods, properties, and parameters. In Angular, decorators are extensively used for features like dependency injection, routing, and more. Key Concepts: What is a Decorator? A decorator is a special kind of function that can be attached to a class, method, property, or parameter to modify or add metadata to it. Decorators are commonly used in frameworks like Angular and NestJS to add extra functionality to components, services, and other entities. Types of Decorators: Class Decorators: Used to modify or annotate classes. Method Decorators: Used to modify methods. Property Decorators: Used to modify properties. Parameter Decorators: Used to modify method parameters. Class Decorators: Class decorators are functions that take the class constructor as an argument and can modify its behavior or add metadata. Example: A simple class decorator: function Injectable(target: Function) { console.log(`Injectable: ${target.name}`); } @Injectable class MyService {} How it works: The Injectable decorator takes the class constructor (target) and logs a message with the class name. The @Injectable decorator is applied to the MyService class, making it injectable (this concept is widely used in Angular for dependency injection). Decorator Syntax: Decorator Declaration: A decorator is defined as a function that typically takes arguments like the target class, method, or property. Decorator Application: You apply a decorator by prefixing it with the @ symbol before a class, method, property, or parameter. Advanced Use Cases for Decorators: Metadata Reflection: Decorators are often used in frameworks like Angular for dependency injection, routing, and more by attaching metadata to classes and methods. For instance, Angular uses the @Injectable decorator to mark services that can be injected into other components or services. Method Decorators: You can create decorators to modify or enhance the behavior of methods, such as logging, authentication, etc. Example: function Log( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { const originalMethod = descriptor.value; descriptor.value = function (...args: any[]) { console.log( `Calling ${propertyKey} with arguments: ${JSON.stringify(args)}` ); return originalMethod.apply(this, args); }; } class Calculator { @Log add(a: number, b: number) { return a + b; } } const calc = new Calculator(); calc.add(2, 3); // Logs: Calling add with arguments: [2,3] How it works: The @Log decorator wraps the add method to log the arguments every time it’s called. Dependency Injection in Angular (Example): Decorators like @Injectable, @Component, and @Directive in Angular are used to add metadata for dependency injection and component configuration. Example: Angular-style @Injectable decorator: function Injectable(target: Function) { console.log(`${target.name} is injectable!`); } @Injectable class MyService { // Service logic } How it works: The @Injectable decorator marks MyService as a service that can be injected into other parts of the application, helping Angular’s dependency injection system manage instances of MyService. Parameter Decorators: These decorators are used to modify the behavior or add metadata to method parameters. Example: function Param(target: any, propertyKey: string, parameterIndex: number) { console.log( `Parameter at index ${parameterIndex} in method ${propertyKey} was decorated` ); } class MyClass { greet(@Param name: string) { console.log(`Hello, ${name}!`); } } Use Cases for Decorators in Frameworks: Angular: Dependency injection, lifecycle hooks, component metadata, routing. NestJS: Controllers, services, and route handlers. Logging: Method decorators for logging inputs and outputs. Access Control: Decorators for controlling access to methods based on user roles (e.g., @Role('admin')). Summary: Decorators in TypeScript are used to modify or annotate classes, methods, properties, and parameters with additional functionality or metadata. They are widely used in frameworks like Angular for dependency injection and NestJS for routing and middleware handling. Advanced usage includes using decorators for metadata reflection, logging, dependency injection, and more. Examples of common decorators include @Injectable, @Component, @Log, and custom decorators to modify method behavior.]]></summary></entry><entry><title type="html">More about Conditional Types</title><link href="https://anusree6154s.github.io/documentation/conditional-types" rel="alternate" type="text/html" title="More about Conditional Types" /><published>2025-01-19T00:00:00+00:00</published><updated>2025-01-19T00:00:00+00:00</updated><id>https://anusree6154s.github.io/documentation/conditional-types</id><content type="html" xml:base="https://anusree6154s.github.io/documentation/conditional-types"><![CDATA[<h3 id="1-syntax-of-conditional-types"><strong>1. Syntax of Conditional Types</strong></h3>

<p>The syntax for a conditional type is:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">U</span> <span class="p">?</span> <span class="nx">X</span> <span class="p">:</span> <span class="nx">Y</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">T</code></strong>: The type to evaluate.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">U</code></strong>: The condition to check (<code class="language-plaintext highlighter-rouge">T extends U</code>).</li>
  <li><strong><code class="language-plaintext highlighter-rouge">X</code></strong>: The type returned if the condition is true.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Y</code></strong>: The type returned if the condition is false.</li>
</ul>

<p><br /></p>

<h3 id="2-example-basic-conditional-type"><strong>2. Example: Basic Conditional Type</strong></h3>

<p>The following example checks if a type <code class="language-plaintext highlighter-rouge">T</code> is a <code class="language-plaintext highlighter-rouge">string</code>:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">IsString</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="kr">string</span> <span class="p">?</span> <span class="kc">true</span> <span class="p">:</span> <span class="kc">false</span><span class="p">;</span>

<span class="kd">type</span> <span class="nx">Test1</span> <span class="o">=</span> <span class="nx">IsString</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// true</span>
<span class="kd">type</span> <span class="nx">Test2</span> <span class="o">=</span> <span class="nx">IsString</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// false</span>
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">Test1</code> resolves to <code class="language-plaintext highlighter-rouge">true</code> because <code class="language-plaintext highlighter-rouge">string</code> extends <code class="language-plaintext highlighter-rouge">string</code>, while <code class="language-plaintext highlighter-rouge">Test2</code> resolves to <code class="language-plaintext highlighter-rouge">false</code> because <code class="language-plaintext highlighter-rouge">number</code> does not extend <code class="language-plaintext highlighter-rouge">string</code>.</p>]]></content><author><name>Anusree Anilkumar</name></author><category term="typescript" /><category term="conditional types" /><summary type="html"><![CDATA[1. Syntax of Conditional Types The syntax for a conditional type is: T extends U ? X : Y T: The type to evaluate. U: The condition to check (T extends U). X: The type returned if the condition is true. Y: The type returned if the condition is false. 2. Example: Basic Conditional Type The following example checks if a type T is a string: type IsString&lt;T&gt; = T extends string ? true : false; type Test1 = IsString&lt;string&gt;; // true type Test2 = IsString&lt;number&gt;; // false Here, Test1 resolves to true because string extends string, while Test2 resolves to false because number does not extend string.]]></summary></entry><entry><title type="html">More about Declaration Merging</title><link href="https://anusree6154s.github.io/documentation/declaration-merging" rel="alternate" type="text/html" title="More about Declaration Merging" /><published>2025-01-19T00:00:00+00:00</published><updated>2025-01-19T00:00:00+00:00</updated><id>https://anusree6154s.github.io/documentation/declaration-merging</id><content type="html" xml:base="https://anusree6154s.github.io/documentation/declaration-merging"><![CDATA[<h3 id="declaration-merging-in-typescript"><strong>Declaration Merging in TypeScript</strong></h3>

<p>Declaration merging is a feature in TypeScript where <strong>two or more declarations with the same name</strong> are automatically combined into a <strong>single definition</strong>. This feature is particularly useful for extending existing types, interfaces, namespaces, and modules. It ensures that TypeScript provides flexible and extensible code constructs.</p>

<p><br /></p>

<h3 id="1-how-declaration-merging-works"><strong>1. How Declaration Merging Works</strong></h3>

<p>When TypeScript encounters multiple declarations of the same name, it merges their members into a single composite type. The way merging happens depends on the type of the declaration:</p>

<ol>
  <li><strong>Interfaces</strong>: Members are combined.</li>
  <li><strong>Namespaces</strong>: Members are combined.</li>
  <li><strong>Enums</strong>: Members are combined.</li>
  <li><strong>Functions and Classes</strong>: Overloads are created.</li>
</ol>

<p><br /></p>

<h3 id="2-interface-merging"><strong>2. Interface Merging</strong></h3>

<p>Interfaces with the same name are automatically merged, with their members combined into a single definition.</p>

<h4 id="example-merging-interfaces"><strong>Example: Merging Interfaces</strong></h4>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">person</span><span class="p">:</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">age</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
<span class="p">};</span> <span class="c1">// Both `name` and `age` are available due to merging</span>
</code></pre></div></div>

<h4 id="rules-for-interface-merging"><strong>Rules for Interface Merging</strong></h4>
<ul>
  <li>If two members have the same name and type, they are compatible.</li>
  <li>If two members have the same name but different types, a compilation error occurs.</li>
</ul>

<h4 id="example-conflicting-members"><strong>Example: Conflicting Members</strong></h4>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="c1">// Error: Subsequent property declarations must have the same type</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="3-namespace-merging"><strong>3. Namespace Merging</strong></h3>

<p>Namespaces with the same name are merged, and their members are combined into a single namespace.</p>

<h4 id="example-merging-namespaces"><strong>Example: Merging Namespaces</strong></h4>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nx">MyNamespace</span> <span class="p">{</span>
  <span class="k">export</span> <span class="kd">const</span> <span class="nx">greeting</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="nx">MyNamespace</span> <span class="p">{</span>
  <span class="k">export</span> <span class="kd">function</span> <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">greeting</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">MyNamespace</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">();</span> <span class="c1">// Logs: Hello</span>
</code></pre></div></div>

<h4 id="use-case-extending-external-libraries"><strong>Use Case: Extending External Libraries</strong></h4>
<p>Declaration merging can extend third-party libraries by adding additional functionality.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nx">Express</span> <span class="p">{</span>
  <span class="k">export</span> <span class="kr">interface</span> <span class="nx">Request</span> <span class="p">{</span>
    <span class="nl">user</span><span class="p">?:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="4-enum-merging"><strong>4. Enum Merging</strong></h3>

<p>Enums with the same name are merged, combining their members into a single enum.</p>

<h4 id="example-merging-enums"><strong>Example: Merging Enums</strong></h4>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Colors</span> <span class="p">{</span>
  <span class="nx">Red</span><span class="p">,</span>
<span class="p">}</span>

<span class="kr">enum</span> <span class="nx">Colors</span> <span class="p">{</span>
  <span class="nx">Blue</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Colors</span><span class="p">.</span><span class="nx">Red</span><span class="p">);</span>  <span class="c1">// 0</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Colors</span><span class="p">.</span><span class="nx">Blue</span><span class="p">);</span> <span class="c1">// 2</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="5-function-and-class-merging"><strong>5. Function and Class Merging</strong></h3>

<p>For functions or classes, declaration merging results in <strong>overload declarations</strong>.</p>

<h4 id="example-function-merging"><strong>Example: Function Merging</strong></h4>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">string</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">any</span><span class="p">):</span> <span class="kr">any</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>     <span class="c1">// 10</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// hello</span>
</code></pre></div></div>

<h4 id="example-class-merging-with-namespace"><strong>Example: Class Merging with Namespace</strong></h4>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Car</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="k">public</span> <span class="nx">make</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="nx">Car</span> <span class="p">{</span>
  <span class="k">export</span> <span class="kd">const</span> <span class="nx">numberOfWheels</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">myCar</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Car</span><span class="p">(</span><span class="dl">"</span><span class="s2">Toyota</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Car</span><span class="p">.</span><span class="nx">numberOfWheels</span><span class="p">);</span> <span class="c1">// 4</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="6-practical-applications-of-declaration-merging"><strong>6. Practical Applications of Declaration Merging</strong></h3>

<ol>
  <li><strong>Extending Third-Party Libraries</strong>
    <ul>
      <li>Adding additional members to interfaces from external libraries.</li>
    </ul>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Window</span> <span class="p">{</span>
  <span class="nl">customProperty</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">customProperty</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, world!</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Combining Related Code</strong>
    <ul>
      <li>Grouping related declarations (interfaces, namespaces, etc.) without modifying original declarations.</li>
    </ul>
  </li>
  <li><strong>Creating Overloads</strong>
    <ul>
      <li>Defining multiple versions of functions or methods using merging.</li>
    </ul>
  </li>
</ol>

<p><br /></p>

<h3 id="key-topics-recap"><strong>Key Topics Recap</strong></h3>

<table>
  <thead>
    <tr>
      <th><strong>Topic</strong></th>
      <th><strong>Description</strong></th>
      <th><strong>Example</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Declaration Merging</strong></td>
      <td>Combining multiple declarations of the same name into one.</td>
      <td>Merging interfaces, namespaces, enums, or creating function overloads.</td>
    </tr>
    <tr>
      <td><strong>Interfaces</strong></td>
      <td>Members are combined into one.</td>
      <td><code class="language-plaintext highlighter-rouge">interface A { x: number; }</code> and <code class="language-plaintext highlighter-rouge">interface A { y: string; }</code> =&gt; <code class="language-plaintext highlighter-rouge">{ x: number; y: string }</code></td>
    </tr>
    <tr>
      <td><strong>Namespaces</strong></td>
      <td>Members are merged into the same namespace.</td>
      <td>Adding methods to an existing namespace.</td>
    </tr>
    <tr>
      <td><strong>Enums</strong></td>
      <td>Enum members are merged into one enum.</td>
      <td><code class="language-plaintext highlighter-rouge">enum Colors { Red }</code> and <code class="language-plaintext highlighter-rouge">enum Colors { Blue }</code> =&gt; <code class="language-plaintext highlighter-rouge">Colors.Red</code> and <code class="language-plaintext highlighter-rouge">Colors.Blue</code>.</td>
    </tr>
    <tr>
      <td><strong>Functions and Classes</strong></td>
      <td>Overloads are created during merging.</td>
      <td>Adding a namespace to a class or defining multiple function signatures.</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Anusree Anilkumar</name></author><category term="typescript" /><category term="declaration merging" /><summary type="html"><![CDATA[Declaration Merging in TypeScript Declaration merging is a feature in TypeScript where two or more declarations with the same name are automatically combined into a single definition. This feature is particularly useful for extending existing types, interfaces, namespaces, and modules. It ensures that TypeScript provides flexible and extensible code constructs. 1. How Declaration Merging Works When TypeScript encounters multiple declarations of the same name, it merges their members into a single composite type. The way merging happens depends on the type of the declaration: Interfaces: Members are combined. Namespaces: Members are combined. Enums: Members are combined. Functions and Classes: Overloads are created. 2. Interface Merging Interfaces with the same name are automatically merged, with their members combined into a single definition. Example: Merging Interfaces interface Person { name: string; } interface Person { age: number; } const person: Person = { name: "Alice", age: 30, }; // Both `name` and `age` are available due to merging Rules for Interface Merging If two members have the same name and type, they are compatible. If two members have the same name but different types, a compilation error occurs. Example: Conflicting Members interface Animal { name: string; } interface Animal { name: number; // Error: Subsequent property declarations must have the same type } 3. Namespace Merging Namespaces with the same name are merged, and their members are combined into a single namespace. Example: Merging Namespaces namespace MyNamespace { export const greeting = "Hello"; } namespace MyNamespace { export function sayHello() { console.log(greeting); } } MyNamespace.sayHello(); // Logs: Hello Use Case: Extending External Libraries Declaration merging can extend third-party libraries by adding additional functionality. namespace Express { export interface Request { user?: string; } } 4. Enum Merging Enums with the same name are merged, combining their members into a single enum. Example: Merging Enums enum Colors { Red, } enum Colors { Blue = 2, } console.log(Colors.Red); // 0 console.log(Colors.Blue); // 2 5. Function and Class Merging For functions or classes, declaration merging results in overload declarations. Example: Function Merging function add(x: number): number; function add(x: string): string; function add(x: any): any { return x; } console.log(add(10)); // 10 console.log(add("hello")); // hello Example: Class Merging with Namespace class Car { constructor(public make: string) {} } namespace Car { export const numberOfWheels = 4; } const myCar = new Car("Toyota"); console.log(Car.numberOfWheels); // 4 6. Practical Applications of Declaration Merging Extending Third-Party Libraries Adding additional members to interfaces from external libraries. interface Window { customProperty: string; } window.customProperty = "Hello, world!"; Combining Related Code Grouping related declarations (interfaces, namespaces, etc.) without modifying original declarations. Creating Overloads Defining multiple versions of functions or methods using merging. Key Topics Recap Topic Description Example Declaration Merging Combining multiple declarations of the same name into one. Merging interfaces, namespaces, enums, or creating function overloads. Interfaces Members are combined into one. interface A { x: number; } and interface A { y: string; } =&gt; { x: number; y: string } Namespaces Members are merged into the same namespace. Adding methods to an existing namespace. Enums Enum members are merged into one enum. enum Colors { Red } and enum Colors { Blue } =&gt; Colors.Red and Colors.Blue. Functions and Classes Overloads are created during merging. Adding a namespace to a class or defining multiple function signatures.]]></summary></entry><entry><title type="html">More about Decorators in Typescript</title><link href="https://anusree6154s.github.io/documentation/decorators" rel="alternate" type="text/html" title="More about Decorators in Typescript" /><published>2025-01-19T00:00:00+00:00</published><updated>2025-01-19T00:00:00+00:00</updated><id>https://anusree6154s.github.io/documentation/decorators</id><content type="html" xml:base="https://anusree6154s.github.io/documentation/decorators"><![CDATA[<h3 id="decorators-in-typescript"><strong>Decorators in TypeScript</strong></h3>

<p>Decorators are a powerful feature in TypeScript that allows you to <strong>annotate and modify classes, methods, properties, and parameters</strong> at runtime. They provide a clean way to apply reusable behaviors or metadata to your code. Decorators are particularly useful in frameworks like Angular, where they are extensively used for dependency injection and metadata annotation.</p>

<p><br /></p>

<h3 id="1-what-are-decorators"><strong>1. What Are Decorators?</strong></h3>

<p>A <strong>decorator</strong> is a special kind of declaration attached to a class, method, accessor, property, or parameter. Decorators are defined using the <strong><code class="language-plaintext highlighter-rouge">@</code></strong> symbol followed by a function.</p>

<h4 id="decorator-syntax">Decorator Syntax</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">decorator</span>
<span class="kd">class</span> <span class="nx">MyClass</span> <span class="p">{}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="2-enabling-decorators"><strong>2. Enabling Decorators</strong></h3>

<p>Decorators are an experimental feature in TypeScript and must be explicitly enabled in the <code class="language-plaintext highlighter-rouge">tsconfig.json</code>:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"experimentalDecorators"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><br /></p>

<h3 id="3-types-of-decorators"><strong>3. Types of Decorators</strong></h3>

<p>TypeScript provides several types of decorators:</p>

<table>
  <thead>
    <tr>
      <th>Decorator Type</th>
      <th>Targeted Element</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Class Decorator</strong></td>
      <td>Classes</td>
    </tr>
    <tr>
      <td><strong>Method Decorator</strong></td>
      <td>Methods</td>
    </tr>
    <tr>
      <td><strong>Accessor Decorator</strong></td>
      <td>Getters and setters</td>
    </tr>
    <tr>
      <td><strong>Property Decorator</strong></td>
      <td>Properties</td>
    </tr>
    <tr>
      <td><strong>Parameter Decorator</strong></td>
      <td>Function or constructor parameters</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h3 id="4-class-decorators"><strong>4. Class Decorators</strong></h3>

<p>A class decorator applies to a class declaration. It can modify or replace the class definition.</p>

<h4 id="example-1-logging-class-creation">Example 1: Logging Class Creation</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">logClass</span><span class="p">(</span><span class="nx">target</span><span class="p">:</span> <span class="nb">Function</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">target</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2"> class is being created!`</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">@</span><span class="nd">logClass</span>
<span class="kd">class</span> <span class="nx">MyClass</span> <span class="p">{}</span>

<span class="kd">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">();</span> <span class="c1">// Logs: MyClass class is being created!</span>
</code></pre></div></div>

<h4 id="example-2-adding-static-properties">Example 2: Adding Static Properties</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">addTimestamp</span><span class="p">(</span><span class="nx">target</span><span class="p">:</span> <span class="nb">Function</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">target</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">timestamp</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">@</span><span class="nd">addTimestamp</span>
<span class="kd">class</span> <span class="nx">MyClass</span> <span class="p">{}</span>

<span class="kd">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">((</span><span class="nx">instance</span> <span class="k">as</span> <span class="kr">any</span><span class="p">).</span><span class="nx">timestamp</span><span class="p">);</span> <span class="c1">// Logs the timestamp</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="5-method-decorators"><strong>5. Method Decorators</strong></h3>

<p>A method decorator is applied to a method of a class. It can modify the method or add functionality.</p>

<h4 id="example-logging-method-calls">Example: Logging Method Calls</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">logMethod</span><span class="p">(</span>
  <span class="nx">target</span><span class="p">:</span> <span class="kr">any</span><span class="p">,</span>
  <span class="nx">propertyKey</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span>
  <span class="nx">descriptor</span><span class="p">:</span> <span class="nx">PropertyDescriptor</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">originalMethod</span> <span class="o">=</span> <span class="nx">descriptor</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="nx">descriptor</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(...</span><span class="nx">args</span><span class="p">:</span> <span class="kr">any</span><span class="p">[])</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Calling </span><span class="p">${</span><span class="nx">propertyKey</span><span class="p">}</span><span class="s2"> with arguments:`</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">originalMethod</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
  <span class="p">@</span><span class="nd">logMethod</span>
  <span class="nx">sayHello</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hello, </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">!`</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">();</span>
<span class="nx">instance</span><span class="p">.</span><span class="nx">sayHello</span><span class="p">(</span><span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// Logs:</span>
<span class="c1">// Calling sayHello with arguments: [ 'Alice' ]</span>
<span class="c1">// Hello, Alice!</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="6-property-decorators"><strong>6. Property Decorators</strong></h3>

<p>A property decorator applies to class properties. It allows you to attach metadata or modify how the property is used.</p>

<h4 id="example-marking-required-properties">Example: Marking Required Properties</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">required</span><span class="p">(</span><span class="nx">target</span><span class="p">:</span> <span class="kr">any</span><span class="p">,</span> <span class="nx">propertyKey</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Property "</span><span class="p">${</span><span class="nx">propertyKey</span><span class="p">}</span><span class="s2">" is required.`</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
  <span class="p">@</span><span class="nd">required</span>
  <span class="nx">name</span><span class="o">!</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// Logs: Property "name" is required.</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="7-accessor-decorators"><strong>7. Accessor Decorators</strong></h3>

<p>Accessor decorators are used on getters and setters of properties.</p>

<h4 id="example-validating-property-access">Example: Validating Property Access</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">logAccess</span><span class="p">(</span>
  <span class="nx">target</span><span class="p">:</span> <span class="kr">any</span><span class="p">,</span>
  <span class="nx">propertyKey</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span>
  <span class="nx">descriptor</span><span class="p">:</span> <span class="nx">PropertyDescriptor</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">originalGet</span> <span class="o">=</span> <span class="nx">descriptor</span><span class="p">.</span><span class="kd">get</span><span class="p">;</span>
  <span class="nx">descriptor</span><span class="p">.</span><span class="kd">get</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Accessing property "</span><span class="p">${</span><span class="nx">propertyKey</span><span class="p">}</span><span class="s2">"`</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">originalGet</span><span class="p">?.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
  <span class="k">private</span> <span class="nx">_value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>

  <span class="p">@</span><span class="nd">logAccess</span>
  <span class="kd">get</span> <span class="nx">value</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">_value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
<span class="c1">// Logs:</span>
<span class="c1">// Accessing property "value"</span>
<span class="c1">// 42</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="8-parameter-decorators"><strong>8. Parameter Decorators</strong></h3>

<p>A parameter decorator applies to the parameters of a method or constructor. It’s often used for dependency injection or metadata collection.</p>

<h4 id="example-logging-parameter-metadata">Example: Logging Parameter Metadata</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">logParameter</span><span class="p">(</span>
  <span class="nx">target</span><span class="p">:</span> <span class="kr">any</span><span class="p">,</span>
  <span class="nx">propertyKey</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span>
  <span class="nx">parameterIndex</span><span class="p">:</span> <span class="kr">number</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
    <span class="s2">`Parameter at index </span><span class="p">${</span><span class="nx">parameterIndex</span><span class="p">}</span><span class="s2"> in method "</span><span class="p">${</span><span class="nx">propertyKey</span><span class="p">}</span><span class="s2">" is being logged.`</span>
  <span class="p">);</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
  <span class="nx">greet</span><span class="p">(@</span><span class="nd">logParameter</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Hello, </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">();</span>
<span class="nx">instance</span><span class="p">.</span><span class="nx">greet</span><span class="p">(</span><span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">);</span>
<span class="c1">// Logs:</span>
<span class="c1">// Parameter at index 0 in method "greet" is being logged.</span>
<span class="c1">// Hello, Alice</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="9-composing-multiple-decorators"><strong>9. Composing Multiple Decorators</strong></h3>

<p>You can stack multiple decorators on a single element. Decorators are applied in <strong>reverse order</strong> (bottom to top).</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">first</span><span class="p">(</span><span class="nx">target</span><span class="p">:</span> <span class="kr">any</span><span class="p">,</span> <span class="nx">propertyKey</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">First decorator</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">second</span><span class="p">(</span><span class="nx">target</span><span class="p">:</span> <span class="kr">any</span><span class="p">,</span> <span class="nx">propertyKey</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Second decorator</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
  <span class="p">@</span><span class="nd">first</span>
  <span class="p">@</span><span class="nd">second</span>
  <span class="nx">method</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="c1">// Logs:</span>
<span class="c1">// Second decorator</span>
<span class="c1">// First decorator</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="10-practical-use-cases-for-decorators"><strong>10. Practical Use Cases for Decorators</strong></h3>

<ul>
  <li><strong>Dependency Injection</strong>: Used in frameworks like Angular for injecting dependencies into classes.</li>
  <li><strong>Logging</strong>: Automatically log class instantiation, method calls, or property accesses.</li>
  <li><strong>Validation</strong>: Mark required properties or validate method arguments.</li>
  <li><strong>Metadata</strong>: Attach additional metadata to classes or members, useful for libraries like <code class="language-plaintext highlighter-rouge">reflect-metadata</code>.</li>
</ul>

<h2><br /></h2>

<h3 id="summary-of-all-topics"><strong>Summary of All Topics</strong></h3>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Class Decorator</strong></td>
      <td>Modifies or replaces class definitions.</td>
      <td><code class="language-plaintext highlighter-rouge">@logClass</code></td>
    </tr>
    <tr>
      <td><strong>Method Decorator</strong></td>
      <td>Enhances or overrides method behavior.</td>
      <td><code class="language-plaintext highlighter-rouge">@logMethod</code></td>
    </tr>
    <tr>
      <td><strong>Property Decorator</strong></td>
      <td>Adds metadata or modifies properties.</td>
      <td><code class="language-plaintext highlighter-rouge">@required</code></td>
    </tr>
    <tr>
      <td><strong>Accessor Decorator</strong></td>
      <td>Applies to getters or setters to log or modify access behavior.</td>
      <td><code class="language-plaintext highlighter-rouge">@logAccess</code></td>
    </tr>
    <tr>
      <td><strong>Parameter Decorator</strong></td>
      <td>Logs or injects data into parameters.</td>
      <td><code class="language-plaintext highlighter-rouge">@logParameter</code></td>
    </tr>
    <tr>
      <td><strong>Indexed Access Types</strong></td>
      <td>Retrieves the type of a property dynamically.</td>
      <td><code class="language-plaintext highlighter-rouge">type Name = Person["name"];</code></td>
    </tr>
    <tr>
      <td><strong>Template Literal Types</strong></td>
      <td>Constructs string types dynamically.</td>
      <td><code class="language-plaintext highlighter-rouge">type API = \${"GET" | "POST"} /${"users"}\</code></td>
    </tr>
    <tr>
      <td><strong>Utility Types</strong></td>
      <td>Built-in types for manipulating types (<code class="language-plaintext highlighter-rouge">Partial</code>, <code class="language-plaintext highlighter-rouge">Readonly</code>, <code class="language-plaintext highlighter-rouge">Pick</code>, <code class="language-plaintext highlighter-rouge">Omit</code>).</td>
      <td><code class="language-plaintext highlighter-rouge">type PartialPerson = Partial&lt;Person&gt;;</code></td>
    </tr>
    <tr>
      <td><strong>Conditional Types</strong></td>
      <td>Constructs types conditionally based on logic (<code class="language-plaintext highlighter-rouge">extends ? :</code>).</td>
      <td><code class="language-plaintext highlighter-rouge">type IsString&lt;T&gt; = T extends string ? true : false;</code></td>
    </tr>
    <tr>
      <td><strong>Mapped Types</strong></td>
      <td>Creates new types by transforming existing ones (<code class="language-plaintext highlighter-rouge">readonly</code>, <code class="language-plaintext highlighter-rouge">optional</code>).</td>
      <td><code class="language-plaintext highlighter-rouge">type Readonly&lt;T&gt; = { readonly [K in keyof T]: T[K] };</code></td>
    </tr>
    <tr>
      <td><strong>Keyof and Lookup Types</strong></td>
      <td>Dynamically access object keys and properties.</td>
      <td><code class="language-plaintext highlighter-rouge">type Key = keyof Person;</code></td>
    </tr>
    <tr>
      <td><strong>Generics</strong></td>
      <td>Enables reusable, flexible code for any type.</td>
      <td><code class="language-plaintext highlighter-rouge">function identity&lt;T&gt;(arg: T): T;</code></td>
    </tr>
    <tr>
      <td><strong>Modules</strong></td>
      <td>Allows splitting code into separate files for better organization (<code class="language-plaintext highlighter-rouge">import/export</code>).</td>
      <td><code class="language-plaintext highlighter-rouge">import { greet } from "./file";</code></td>
    </tr>
  </tbody>
</table>

<hr />]]></content><author><name>Anusree Anilkumar</name></author><category term="typescript" /><category term="decorators" /><summary type="html"><![CDATA[Decorators in TypeScript Decorators are a powerful feature in TypeScript that allows you to annotate and modify classes, methods, properties, and parameters at runtime. They provide a clean way to apply reusable behaviors or metadata to your code. Decorators are particularly useful in frameworks like Angular, where they are extensively used for dependency injection and metadata annotation. 1. What Are Decorators? A decorator is a special kind of declaration attached to a class, method, accessor, property, or parameter. Decorators are defined using the @ symbol followed by a function. Decorator Syntax @decorator class MyClass {} 2. Enabling Decorators Decorators are an experimental feature in TypeScript and must be explicitly enabled in the tsconfig.json: { "experimentalDecorators": true } 3. Types of Decorators TypeScript provides several types of decorators: Decorator Type Targeted Element Class Decorator Classes Method Decorator Methods Accessor Decorator Getters and setters Property Decorator Properties Parameter Decorator Function or constructor parameters 4. Class Decorators A class decorator applies to a class declaration. It can modify or replace the class definition. Example 1: Logging Class Creation function logClass(target: Function) { console.log(`${target.name} class is being created!`); } @logClass class MyClass {} const instance = new MyClass(); // Logs: MyClass class is being created! Example 2: Adding Static Properties function addTimestamp(target: Function) { target.prototype.timestamp = Date.now(); } @addTimestamp class MyClass {} const instance = new MyClass(); console.log((instance as any).timestamp); // Logs the timestamp 5. Method Decorators A method decorator is applied to a method of a class. It can modify the method or add functionality. Example: Logging Method Calls function logMethod( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { const originalMethod = descriptor.value; descriptor.value = function (...args: any[]) { console.log(`Calling ${propertyKey} with arguments:`, args); return originalMethod.apply(this, args); }; } class MyClass { @logMethod sayHello(name: string) { console.log(`Hello, ${name}!`); } } const instance = new MyClass(); instance.sayHello("Alice"); // Logs: // Calling sayHello with arguments: [ 'Alice' ] // Hello, Alice! 6. Property Decorators A property decorator applies to class properties. It allows you to attach metadata or modify how the property is used. Example: Marking Required Properties function required(target: any, propertyKey: string) { console.log(`Property "${propertyKey}" is required.`); } class MyClass { @required name!: string; } // Logs: Property "name" is required. 7. Accessor Decorators Accessor decorators are used on getters and setters of properties. Example: Validating Property Access function logAccess( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { const originalGet = descriptor.get; descriptor.get = function () { console.log(`Accessing property "${propertyKey}"`); return originalGet?.apply(this); }; } class MyClass { private _value = 42; @logAccess get value() { return this._value; } } const instance = new MyClass(); console.log(instance.value); // Logs: // Accessing property "value" // 42 8. Parameter Decorators A parameter decorator applies to the parameters of a method or constructor. It’s often used for dependency injection or metadata collection. Example: Logging Parameter Metadata function logParameter( target: any, propertyKey: string, parameterIndex: number ) { console.log( `Parameter at index ${parameterIndex} in method "${propertyKey}" is being logged.` ); } class MyClass { greet(@logParameter name: string) { console.log(`Hello, ${name}`); } } const instance = new MyClass(); instance.greet("Alice"); // Logs: // Parameter at index 0 in method "greet" is being logged. // Hello, Alice 9. Composing Multiple Decorators You can stack multiple decorators on a single element. Decorators are applied in reverse order (bottom to top). function first(target: any, propertyKey: string) { console.log("First decorator"); } function second(target: any, propertyKey: string) { console.log("Second decorator"); } class MyClass { @first @second method() {} } // Logs: // Second decorator // First decorator 10. Practical Use Cases for Decorators Dependency Injection: Used in frameworks like Angular for injecting dependencies into classes. Logging: Automatically log class instantiation, method calls, or property accesses. Validation: Mark required properties or validate method arguments. Metadata: Attach additional metadata to classes or members, useful for libraries like reflect-metadata. Summary of All Topics Feature Description Example Class Decorator Modifies or replaces class definitions. @logClass Method Decorator Enhances or overrides method behavior. @logMethod Property Decorator Adds metadata or modifies properties. @required Accessor Decorator Applies to getters or setters to log or modify access behavior. @logAccess Parameter Decorator Logs or injects data into parameters. @logParameter Indexed Access Types Retrieves the type of a property dynamically. type Name = Person["name"]; Template Literal Types Constructs string types dynamically. type API = \${"GET" | "POST"} /${"users"}\ Utility Types Built-in types for manipulating types (Partial, Readonly, Pick, Omit). type PartialPerson = Partial&lt;Person&gt;; Conditional Types Constructs types conditionally based on logic (extends ? :). type IsString&lt;T&gt; = T extends string ? true : false; Mapped Types Creates new types by transforming existing ones (readonly, optional). type Readonly&lt;T&gt; = { readonly [K in keyof T]: T[K] }; Keyof and Lookup Types Dynamically access object keys and properties. type Key = keyof Person; Generics Enables reusable, flexible code for any type. function identity&lt;T&gt;(arg: T): T; Modules Allows splitting code into separate files for better organization (import/export). import { greet } from "./file";]]></summary></entry><entry><title type="html">More about Discriminated Unions</title><link href="https://anusree6154s.github.io/documentation/discriminated-unions" rel="alternate" type="text/html" title="More about Discriminated Unions" /><published>2025-01-19T00:00:00+00:00</published><updated>2025-01-19T00:00:00+00:00</updated><id>https://anusree6154s.github.io/documentation/discriminated-unions</id><content type="html" xml:base="https://anusree6154s.github.io/documentation/discriminated-unions"><![CDATA[<h3 id="discriminated-unions-in-typescript"><strong>Discriminated Unions in TypeScript</strong></h3>

<p>Discriminated unions, also known as tagged unions or algebraic data types, are a powerful feature in TypeScript. They enable you to work with union types that include a shared property (discriminant) to help narrow down specific types in a type-safe way. This makes it easier to work with complex types and ensures type safety during development.</p>

<p><br /></p>

<h3 id="1-what-are-discriminated-unions"><strong>1. What Are Discriminated Unions?</strong></h3>

<p>A discriminated union is a <strong>union type</strong> where each variant (type in the union) has a unique literal property, often called a <strong>discriminant</strong> or <strong>tag</strong>. The discriminant property is used to determine which variant of the union is currently being used.</p>

<h4 id="key-components">Key Components:</h4>

<ol>
  <li><strong>Union Types</strong>: A type composed of multiple possible types.You define it by using the <code class="language-plaintext highlighter-rouge">|</code> (pipe) symbol to combine multiple types.</li>
</ol>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Shape</span> <span class="o">=</span>
  <span class="o">|</span> <span class="p">{</span> <span class="na">kind</span><span class="p">:</span> <span class="dl">"</span><span class="s2">circle</span><span class="dl">"</span><span class="p">;</span> <span class="nl">radius</span><span class="p">:</span> <span class="kr">number</span> <span class="p">}</span>
  <span class="o">|</span> <span class="p">{</span> <span class="na">kind</span><span class="p">:</span> <span class="dl">"</span><span class="s2">square</span><span class="dl">"</span><span class="p">;</span> <span class="nl">sideLength</span><span class="p">:</span> <span class="kr">number</span> <span class="p">};</span>
</code></pre></div></div>

<ol>
  <li><strong>Discriminant Property</strong>: A shared property that uniquely identifies each member of the union. It often uses a literal value like “<code class="language-plaintext highlighter-rouge">circle"</code> or <code class="language-plaintext highlighter-rouge">"square"</code>.</li>
</ol>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Shape</span> <span class="o">=</span>
  <span class="o">|</span> <span class="p">{</span> <span class="na">kind</span><span class="p">:</span> <span class="dl">"</span><span class="s2">circle</span><span class="dl">"</span><span class="p">;</span> <span class="nl">radius</span><span class="p">:</span> <span class="kr">number</span> <span class="p">}</span>
  <span class="o">|</span> <span class="p">{</span> <span class="na">kind</span><span class="p">:</span> <span class="dl">"</span><span class="s2">square</span><span class="dl">"</span><span class="p">;</span> <span class="nl">sideLength</span><span class="p">:</span> <span class="kr">number</span> <span class="p">};</span>
</code></pre></div></div>

<ol>
  <li><strong>Narrowing</strong>: TypeScript uses the discriminant to refine the type within specific branches of code.</li>
</ol>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">area</span><span class="p">(</span><span class="nx">shape</span><span class="p">:</span> <span class="nx">Shape</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">shape</span><span class="p">.</span><span class="nx">kind</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">circle</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">radius</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// shape is narrowed to { kind: "circle"; radius: number }</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">sideLength</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// shape is narrowed to { kind: "square"; sideLength: number }</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><strong>Explanation</strong>: Inside the <code class="language-plaintext highlighter-rouge">if</code> and <code class="language-plaintext highlighter-rouge">else</code> branches, TypeScript narrows the type based on the value of <code class="language-plaintext highlighter-rouge">shape.kind</code>. If <code class="language-plaintext highlighter-rouge">shape.kind</code> is <code class="language-plaintext highlighter-rouge">"circle"</code>, TypeScript knows it’s a circle and can access the <code class="language-plaintext highlighter-rouge">radius</code> property. Similarly, if <code class="language-plaintext highlighter-rouge">shape.kind</code> is <code class="language-plaintext highlighter-rouge">"square"</code>, TypeScript knows it’s a square and can access the <code class="language-plaintext highlighter-rouge">sideLength</code> property.</li>
</ul>

<p><br /></p>

<h3 id="2-example-discriminated-unions"><strong>2. Example: Discriminated Unions</strong></h3>

<p>Here’s an example where <code class="language-plaintext highlighter-rouge">kind</code> is the discriminant property:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Shape</span> <span class="o">=</span>
  <span class="o">|</span> <span class="p">{</span> <span class="na">kind</span><span class="p">:</span> <span class="dl">"</span><span class="s2">circle</span><span class="dl">"</span><span class="p">;</span> <span class="nl">radius</span><span class="p">:</span> <span class="kr">number</span> <span class="p">}</span>
  <span class="o">|</span> <span class="p">{</span> <span class="na">kind</span><span class="p">:</span> <span class="dl">"</span><span class="s2">square</span><span class="dl">"</span><span class="p">;</span> <span class="nl">sideLength</span><span class="p">:</span> <span class="kr">number</span> <span class="p">}</span>
  <span class="o">|</span> <span class="p">{</span> <span class="na">kind</span><span class="p">:</span> <span class="dl">"</span><span class="s2">rectangle</span><span class="dl">"</span><span class="p">;</span> <span class="nl">width</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span> <span class="nl">height</span><span class="p">:</span> <span class="kr">number</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nx">area</span><span class="p">(</span><span class="nx">shape</span><span class="p">:</span> <span class="nx">Shape</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="nx">shape</span><span class="p">.</span><span class="nx">kind</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">circle</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">radius</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">square</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">sideLength</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">rectangle</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">width</span> <span class="o">*</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>
    <span class="nl">default</span><span class="p">:</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Unknown shape</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">circle</span><span class="p">:</span> <span class="nx">Shape</span> <span class="o">=</span> <span class="p">{</span> <span class="na">kind</span><span class="p">:</span> <span class="dl">"</span><span class="s2">circle</span><span class="dl">"</span><span class="p">,</span> <span class="na">radius</span><span class="p">:</span> <span class="mi">10</span> <span class="p">};</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">area</span><span class="p">(</span><span class="nx">circle</span><span class="p">));</span> <span class="c1">// 314.1592653589793</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="3-how-discriminated-unions-work"><strong>3. How Discriminated Unions Work</strong></h3>

<p>TypeScript uses <strong>control flow analysis</strong> to refine types within a block of code. When it detects a comparison or check against the discriminant property, it narrows the type automatically.</p>

<h4 id="example">Example:</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Animal</span> <span class="o">=</span>
  <span class="o">|</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">dog</span><span class="dl">"</span><span class="p">;</span> <span class="nl">bark</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span> <span class="p">}</span>
  <span class="o">|</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">cat</span><span class="dl">"</span><span class="p">;</span> <span class="nl">meow</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nx">makeSound</span><span class="p">(</span><span class="nx">animal</span><span class="p">:</span> <span class="nx">Animal</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">animal</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">dog</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">animal</span><span class="p">.</span><span class="nx">bark</span><span class="p">();</span> <span class="c1">// TypeScript knows this is a dog</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">animal</span><span class="p">.</span><span class="nx">meow</span><span class="p">();</span> <span class="c1">// TypeScript knows this is a cat</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="4-benefits-of-discriminated-unions"><strong>4. Benefits of Discriminated Unions</strong></h3>

<ol>
  <li><strong>Type Safety</strong>: Ensures only valid properties and methods are accessed.</li>
  <li><strong>Readability</strong>: The discriminant property makes it easy to distinguish between types.</li>
  <li><strong>Error Prevention</strong>: TypeScript catches missing cases in functions and ensures exhaustive checks when using <code class="language-plaintext highlighter-rouge">switch</code> statements.</li>
  <li><strong>Code Clarity</strong>: Clear separation of logic for each type in the union.</li>
</ol>

<p><br /></p>

<h3 id="5-exhaustiveness-checking"><strong>5. Exhaustiveness Checking</strong></h3>

<p>TypeScript helps ensure that all possible variants of a discriminated union are handled. If you miss a case, TypeScript can throw an error.</p>

<h4 id="example-adding-a-never-case">Example: Adding a <code class="language-plaintext highlighter-rouge">never</code> Case</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">area</span><span class="p">(</span><span class="nx">shape</span><span class="p">:</span> <span class="nx">Shape</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="nx">shape</span><span class="p">.</span><span class="nx">kind</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">circle</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span> <span class="o">*</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">radius</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">square</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">sideLength</span> <span class="o">**</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">rectangle</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">width</span> <span class="o">*</span> <span class="nx">shape</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>
    <span class="nl">default</span><span class="p">:</span>
      <span class="kd">const</span> <span class="nx">_exhaustiveCheck</span><span class="p">:</span> <span class="nx">never</span> <span class="o">=</span> <span class="nx">shape</span><span class="p">;</span> <span class="c1">// TypeScript error if a new variant is added</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">`Unhandled shape: </span><span class="p">${</span><span class="nx">_exhaustiveCheck</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="6-practical-use-cases"><strong>6. Practical Use Cases</strong></h3>

<p>Discriminated unions are widely used for scenarios where you need to handle multiple related types with unique behaviors.</p>

<h4 id="61-state-management"><strong>6.1 State Management</strong></h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">State</span> <span class="o">=</span>
  <span class="o">|</span> <span class="p">{</span> <span class="na">status</span><span class="p">:</span> <span class="dl">"</span><span class="s2">loading</span><span class="dl">"</span> <span class="p">}</span>
  <span class="o">|</span> <span class="p">{</span> <span class="na">status</span><span class="p">:</span> <span class="dl">"</span><span class="s2">success</span><span class="dl">"</span><span class="p">;</span> <span class="nl">data</span><span class="p">:</span> <span class="kr">string</span> <span class="p">}</span>
  <span class="o">|</span> <span class="p">{</span> <span class="na">status</span><span class="p">:</span> <span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">;</span> <span class="nl">error</span><span class="p">:</span> <span class="kr">string</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nx">handleState</span><span class="p">(</span><span class="nx">state</span><span class="p">:</span> <span class="nx">State</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">status</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">loading</span><span class="dl">"</span><span class="p">:</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Loading...</span><span class="dl">"</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">success</span><span class="dl">"</span><span class="p">:</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Data: </span><span class="p">${</span><span class="nx">state</span><span class="p">.</span><span class="nx">data</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">:</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s2">`Error: </span><span class="p">${</span><span class="nx">state</span><span class="p">.</span><span class="nx">error</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="62-api-responses"><strong>6.2 API Responses</strong></h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ApiResponse</span> <span class="o">=</span>
  <span class="o">|</span> <span class="p">{</span> <span class="na">status</span><span class="p">:</span> <span class="dl">"</span><span class="s2">ok</span><span class="dl">"</span><span class="p">;</span> <span class="nl">data</span><span class="p">:</span> <span class="kr">any</span> <span class="p">}</span>
  <span class="o">|</span> <span class="p">{</span> <span class="na">status</span><span class="p">:</span> <span class="dl">"</span><span class="s2">error</span><span class="dl">"</span><span class="p">;</span> <span class="nl">error</span><span class="p">:</span> <span class="kr">string</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nx">handleResponse</span><span class="p">(</span><span class="nx">response</span><span class="p">:</span> <span class="nx">ApiResponse</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">status</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">ok</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Data:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">response</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="dl">"</span><span class="s2">Error:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">response</span><span class="p">.</span><span class="nx">error</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Anusree Anilkumar</name></author><category term="typescript" /><category term="discriminated unions" /><summary type="html"><![CDATA[Discriminated Unions in TypeScript Discriminated unions, also known as tagged unions or algebraic data types, are a powerful feature in TypeScript. They enable you to work with union types that include a shared property (discriminant) to help narrow down specific types in a type-safe way. This makes it easier to work with complex types and ensures type safety during development. 1. What Are Discriminated Unions? A discriminated union is a union type where each variant (type in the union) has a unique literal property, often called a discriminant or tag. The discriminant property is used to determine which variant of the union is currently being used. Key Components: Union Types: A type composed of multiple possible types.You define it by using the | (pipe) symbol to combine multiple types. type Shape = | { kind: "circle"; radius: number } | { kind: "square"; sideLength: number }; Discriminant Property: A shared property that uniquely identifies each member of the union. It often uses a literal value like “circle" or "square". type Shape = | { kind: "circle"; radius: number } | { kind: "square"; sideLength: number }; Narrowing: TypeScript uses the discriminant to refine the type within specific branches of code. function area(shape: Shape): number { if (shape.kind === "circle") { return Math.PI * shape.radius ** 2; // shape is narrowed to { kind: "circle"; radius: number } } else { return shape.sideLength ** 2; // shape is narrowed to { kind: "square"; sideLength: number } } } Explanation: Inside the if and else branches, TypeScript narrows the type based on the value of shape.kind. If shape.kind is "circle", TypeScript knows it’s a circle and can access the radius property. Similarly, if shape.kind is "square", TypeScript knows it’s a square and can access the sideLength property. 2. Example: Discriminated Unions Here’s an example where kind is the discriminant property: type Shape = | { kind: "circle"; radius: number } | { kind: "square"; sideLength: number } | { kind: "rectangle"; width: number; height: number }; function area(shape: Shape): number { switch (shape.kind) { case "circle": return Math.PI * shape.radius ** 2; case "square": return shape.sideLength ** 2; case "rectangle": return shape.width * shape.height; default: throw new Error("Unknown shape"); } } const circle: Shape = { kind: "circle", radius: 10 }; console.log(area(circle)); // 314.1592653589793 3. How Discriminated Unions Work TypeScript uses control flow analysis to refine types within a block of code. When it detects a comparison or check against the discriminant property, it narrows the type automatically. Example: type Animal = | { type: "dog"; bark: () =&gt; void } | { type: "cat"; meow: () =&gt; void }; function makeSound(animal: Animal): void { if (animal.type === "dog") { animal.bark(); // TypeScript knows this is a dog } else { animal.meow(); // TypeScript knows this is a cat } } 4. Benefits of Discriminated Unions Type Safety: Ensures only valid properties and methods are accessed. Readability: The discriminant property makes it easy to distinguish between types. Error Prevention: TypeScript catches missing cases in functions and ensures exhaustive checks when using switch statements. Code Clarity: Clear separation of logic for each type in the union. 5. Exhaustiveness Checking TypeScript helps ensure that all possible variants of a discriminated union are handled. If you miss a case, TypeScript can throw an error. Example: Adding a never Case function area(shape: Shape): number { switch (shape.kind) { case "circle": return Math.PI * shape.radius ** 2; case "square": return shape.sideLength ** 2; case "rectangle": return shape.width * shape.height; default: const _exhaustiveCheck: never = shape; // TypeScript error if a new variant is added throw new Error(`Unhandled shape: ${_exhaustiveCheck}`); } } 6. Practical Use Cases Discriminated unions are widely used for scenarios where you need to handle multiple related types with unique behaviors. 6.1 State Management type State = | { status: "loading" } | { status: "success"; data: string } | { status: "error"; error: string }; function handleState(state: State): void { switch (state.status) { case "loading": console.log("Loading..."); break; case "success": console.log(`Data: ${state.data}`); break; case "error": console.error(`Error: ${state.error}`); break; } } 6.2 API Responses type ApiResponse = | { status: "ok"; data: any } | { status: "error"; error: string }; function handleResponse(response: ApiResponse): void { if (response.status === "ok") { console.log("Data:", response.data); } else { console.error("Error:", response.error); } }]]></summary></entry><entry><title type="html">Generics Examples</title><link href="https://anusree6154s.github.io/documentation/generics" rel="alternate" type="text/html" title="Generics Examples" /><published>2025-01-19T00:00:00+00:00</published><updated>2025-01-19T00:00:00+00:00</updated><id>https://anusree6154s.github.io/documentation/generics</id><content type="html" xml:base="https://anusree6154s.github.io/documentation/generics"><![CDATA[<h3 id="1-generic-interfaces"><strong>1. Generic Interfaces</strong></h3>

<p>A <strong>generic interface</strong> allows you to define type-safe interfaces that work with various types.</p>

<h4 id="example-with-object-structures">Example with Object Structures:</h4>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Pair</span><span class="o">&lt;</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="na">key</span><span class="p">:</span> <span class="nx">K</span><span class="p">;</span>
  <span class="nl">value</span><span class="p">:</span> <span class="nx">V</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">numberPair</span><span class="p">:</span> <span class="nx">Pair</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="kr">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">key</span><span class="p">:</span> <span class="dl">"</span><span class="s2">age</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">value</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">numberPair</span><span class="p">.</span><span class="nx">key</span><span class="p">);</span> <span class="c1">// Output: age</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">numberPair</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// Output: 30</span>
</code></pre></div></div>

<h4 id="example-with-function-types">Example with Function Types:</h4>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">GenericFunction</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="p">(</span><span class="na">arg</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">stringFunction</span><span class="p">:</span> <span class="nx">GenericFunction</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="nx">arg</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">stringFunction</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// Output: HELLO</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="2-generic-constraints-with-keyof"><strong>2. Generic Constraints with <code class="language-plaintext highlighter-rouge">keyof</code></strong></h3>

<p>The <code class="language-plaintext highlighter-rouge">keyof</code> keyword allows you to constrain a generic to the keys of an object.</p>

<h4 id="example">Example:</h4>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getProperty</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">K</span> <span class="kd">extends</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">obj</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">key</span><span class="p">:</span> <span class="nx">K</span><span class="p">):</span> <span class="nx">T</span><span class="p">[</span><span class="nx">K</span><span class="p">]</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">30</span> <span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">getProperty</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">));</span> <span class="c1">// Output: Alice</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">getProperty</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="dl">"</span><span class="s2">age</span><span class="dl">"</span><span class="p">));</span>  <span class="c1">// Output: 30</span>

<span class="c1">// Error: Argument of type '"address"' is not assignable to parameter of type 'keyof T'</span>
<span class="c1">// console.log(getProperty(person, "address"));</span>
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">K</code> is constrained to be a key of the type <code class="language-plaintext highlighter-rouge">T</code>.</p>

<p><br /></p>

<h3 id="3-generics-with-default-types"><strong>3. Generics with Default Types</strong></h3>

<p>You can provide <strong>default types</strong> for generics to make them optional when the type isn’t explicitly specified.</p>

<h4 id="example-1">Example:</h4>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">BoxWithDefault</span><span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="kr">string</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">getValue</span><span class="p">():</span> <span class="nx">T</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">defaultBox</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BoxWithDefault</span><span class="p">(</span><span class="dl">"</span><span class="s2">Default Value</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">defaultBox</span><span class="p">.</span><span class="nx">getValue</span><span class="p">());</span> <span class="c1">// Output: Default Value</span>

<span class="kd">const</span> <span class="nx">numberBox</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">BoxWithDefault</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">numberBox</span><span class="p">.</span><span class="nx">getValue</span><span class="p">());</span> <span class="c1">// Output: 42</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="4-benefits-of-generics"><strong>4. Benefits of Generics</strong></h3>

<ol>
  <li><strong>Type Safety:</strong> Generics enforce type constraints, reducing runtime errors caused by incorrect types.</li>
  <li><strong>Reusability:</strong> Create reusable components that work across various data types.</li>
  <li><strong>Flexibility:</strong> Allow defining types dynamically while maintaining strong typing.</li>
  <li><strong>Readability:</strong> Simplify complex types and make the intent of the code clear.</li>
</ol>]]></content><author><name>Anusree Anilkumar</name></author><category term="typescript" /><category term="generics" /><summary type="html"><![CDATA[1. Generic Interfaces A generic interface allows you to define type-safe interfaces that work with various types. Example with Object Structures: interface Pair&lt;K, V&gt; { key: K; value: V; } const numberPair: Pair&lt;string, number&gt; = { key: "age", value: 30, }; console.log(numberPair.key); // Output: age console.log(numberPair.value); // Output: 30 Example with Function Types: interface GenericFunction&lt;T&gt; { (arg: T): T; } const stringFunction: GenericFunction&lt;string&gt; = (arg) =&gt; arg.toUpperCase(); console.log(stringFunction("hello")); // Output: HELLO 2. Generic Constraints with keyof The keyof keyword allows you to constrain a generic to the keys of an object. Example: function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] { return obj[key]; } const person = { name: "Alice", age: 30 }; console.log(getProperty(person, "name")); // Output: Alice console.log(getProperty(person, "age")); // Output: 30 // Error: Argument of type '"address"' is not assignable to parameter of type 'keyof T' // console.log(getProperty(person, "address")); Here, K is constrained to be a key of the type T. 3. Generics with Default Types You can provide default types for generics to make them optional when the type isn’t explicitly specified. Example: class BoxWithDefault&lt;T = string&gt; { value: T; constructor(value: T) { this.value = value; } getValue(): T { return this.value; } } const defaultBox = new BoxWithDefault("Default Value"); console.log(defaultBox.getValue()); // Output: Default Value const numberBox = new BoxWithDefault&lt;number&gt;(42); console.log(numberBox.getValue()); // Output: 42 4. Benefits of Generics Type Safety: Generics enforce type constraints, reducing runtime errors caused by incorrect types. Reusability: Create reusable components that work across various data types. Flexibility: Allow defining types dynamically while maintaining strong typing. Readability: Simplify complex types and make the intent of the code clear.]]></summary></entry><entry><title type="html">More about Inferences in Typescript</title><link href="https://anusree6154s.github.io/documentation/inferences" rel="alternate" type="text/html" title="More about Inferences in Typescript" /><published>2025-01-19T00:00:00+00:00</published><updated>2025-01-19T00:00:00+00:00</updated><id>https://anusree6154s.github.io/documentation/inferences</id><content type="html" xml:base="https://anusree6154s.github.io/documentation/inferences"><![CDATA[<h3 id="1-contextual-typing"><strong>1. Contextual Typing</strong></h3>

<p>TypeScript uses the surrounding context to infer types, especially in scenarios like function callbacks.</p>

<h4 id="example">Example:</h4>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">names</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Bob</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Charlie</span><span class="dl">"</span><span class="p">];</span>

<span class="c1">// The type of `name` is inferred as string</span>
<span class="nx">names</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">name</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">());</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Here, the type of <code class="language-plaintext highlighter-rouge">name</code> is inferred from the array <code class="language-plaintext highlighter-rouge">names</code>, which is of type <code class="language-plaintext highlighter-rouge">string[]</code>.</p>

<p><br /></p>

<h3 id="2-best-common-type"><strong>2. Best Common Type</strong></h3>

<p>When inferring the type of a more complex expression, TypeScript tries to find the <strong>best common type</strong>.</p>

<h4 id="example-1">Example:</h4>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">mixedArray</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">,</span> <span class="kc">true</span><span class="p">];</span> <span class="c1">// Type: (string | number | boolean)[]</span>
</code></pre></div></div>

<p>TypeScript combines all the types in the array and assigns the union type <code class="language-plaintext highlighter-rouge">(string | number | boolean)</code> to the <code class="language-plaintext highlighter-rouge">mixedArray</code> variable.</p>

<p><br /></p>

<h3 id="3-type-assertions-with-inference"><strong>3. Type Assertions with Inference</strong></h3>

<p>Sometimes, you may know more about a type than TypeScript does. In such cases, you can use <strong>type assertions</strong> to explicitly tell TypeScript what type to consider.</p>

<h4 id="example-2">Example:</h4>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">someValue</span><span class="p">:</span> <span class="nx">unknown</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Hello, world!</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">stringLength</span> <span class="o">=</span> <span class="p">(</span><span class="nx">someValue</span> <span class="k">as</span> <span class="kr">string</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span> <span class="c1">// Type: number</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="4-limitations-of-type-inference"><strong>4. Limitations of Type Inference</strong></h3>

<p>Type inference works well for simple cases but may require explicit types in more complex scenarios.</p>

<h4 id="example-3">Example:</h4>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">parseInput</span><span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">input</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">input</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">();</span> <span class="c1">// Return type inferred as string</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">input</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// Return type inferred as string</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here, TypeScript infers the return type as <code class="language-plaintext highlighter-rouge">string</code>, but using explicit typing can clarify intent.</p>

<p><br /></p>

<h3 id="5-inference-in-generics"><strong>5. Inference in Generics</strong></h3>

<p>Generics also benefit from type inference, allowing you to omit the generic type when TypeScript can infer it.</p>

<h4 id="example-4">Example:</h4>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">identity</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="nx">T</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">inferredString</span> <span class="o">=</span> <span class="nx">identity</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// T inferred as string</span>
<span class="kd">let</span> <span class="nx">inferredNumber</span> <span class="o">=</span> <span class="nx">identity</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>      <span class="c1">// T inferred as number</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="6-return-type-inference-in-arrow-functions"><strong>6. Return Type Inference in Arrow Functions</strong></h3>

<p>TypeScript can infer the return type of arrow functions based on their bodies.</p>

<h4 id="example-5">Example:</h4>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">multiply</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">;</span> <span class="c1">// Return type inferred as number</span>
</code></pre></div></div>

<p>Explicit return types are still helpful for clarity:</p>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">multiply</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span><span class="p">;</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="7-type-inference-with-destructuring"><strong>7. Type Inference with Destructuring</strong></h3>

<p>TypeScript infers types even in destructuring assignments.</p>

<h4 id="example-6">Example:</h4>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">point</span> <span class="o">=</span> <span class="p">{</span> <span class="na">x</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">20</span> <span class="p">};</span>

<span class="c1">// x and y inferred as number</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">point</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">colors</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">red</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">blue</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">green</span><span class="dl">"</span><span class="p">];</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">firstColor</span><span class="p">,</span> <span class="nx">secondColor</span><span class="p">]</span> <span class="o">=</span> <span class="nx">colors</span><span class="p">;</span> <span class="c1">// Inferred as string</span>
</code></pre></div></div>]]></content><author><name>Anusree Anilkumar</name></author><category term="typescript" /><category term="inferences" /><summary type="html"><![CDATA[1. Contextual Typing TypeScript uses the surrounding context to infer types, especially in scenarios like function callbacks. Example: const names = ["Alice", "Bob", "Charlie"]; // The type of `name` is inferred as string names.forEach((name) =&gt; { console.log(name.toUpperCase()); }); Here, the type of name is inferred from the array names, which is of type string[]. 2. Best Common Type When inferring the type of a more complex expression, TypeScript tries to find the best common type. Example: const mixedArray = [1, "string", true]; // Type: (string | number | boolean)[] TypeScript combines all the types in the array and assigns the union type (string | number | boolean) to the mixedArray variable. 3. Type Assertions with Inference Sometimes, you may know more about a type than TypeScript does. In such cases, you can use type assertions to explicitly tell TypeScript what type to consider. Example: let someValue: unknown = "Hello, world!"; let stringLength = (someValue as string).length; // Type: number 4. Limitations of Type Inference Type inference works well for simple cases but may require explicit types in more complex scenarios. Example: function parseInput(input: string | number) { if (typeof input === "string") { return input.toUpperCase(); // Return type inferred as string } else { return input.toFixed(2); // Return type inferred as string } } Here, TypeScript infers the return type as string, but using explicit typing can clarify intent. 5. Inference in Generics Generics also benefit from type inference, allowing you to omit the generic type when TypeScript can infer it. Example: function identity&lt;T&gt;(value: T): T { return value; } let inferredString = identity("Hello"); // T inferred as string let inferredNumber = identity(42); // T inferred as number 6. Return Type Inference in Arrow Functions TypeScript can infer the return type of arrow functions based on their bodies. Example: const multiply = (a: number, b: number) =&gt; a * b; // Return type inferred as number Explicit return types are still helpful for clarity: const multiply = (a: number, b: number): number =&gt; a * b; 7. Type Inference with Destructuring TypeScript infers types even in destructuring assignments. Example: const point = { x: 10, y: 20 }; // x and y inferred as number const { x, y } = point; const colors = ["red", "blue", "green"]; const [firstColor, secondColor] = colors; // Inferred as string]]></summary></entry><entry><title type="html">Typescript Interfaces Usecases</title><link href="https://anusree6154s.github.io/documentation/interfaces-usecases" rel="alternate" type="text/html" title="Typescript Interfaces Usecases" /><published>2025-01-19T00:00:00+00:00</published><updated>2025-01-19T00:00:00+00:00</updated><id>https://anusree6154s.github.io/documentation/interfaces-usecases</id><content type="html" xml:base="https://anusree6154s.github.io/documentation/interfaces-usecases"><![CDATA[<h3 id="interfaces"><strong>Interfaces</strong></h3>

<p>An interface defines the structure of an object by specifying its properties and methods. However, interfaces are not limited to describing objects. They can also define function types, arrays, hybrid types, and even work with generics.</p>

<p><br /></p>

<h4 id="1-defining-object-structures">1. <strong>Defining Object Structures</strong></h4>
<p>The most common use case for interfaces is to describe the shape of an object, including its properties and methods.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nx">greet</span><span class="p">():</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">person</span><span class="p">:</span> <span class="nx">Person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">age</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span>
  <span class="nx">greet</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">`Hello, my name is </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
  <span class="p">},</span>
<span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="2-defining-function-types">2. <strong>Defining Function Types</strong></h4>
<p>Interfaces can specify the structure of a function, including its parameter types and return type.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">GreetFunction</span> <span class="p">{</span>
  <span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">greet</span><span class="p">:</span> <span class="nx">GreetFunction</span> <span class="o">=</span> <span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s2">`Hello, my name is </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2"> and I am </span><span class="p">${</span><span class="nx">age</span><span class="p">}</span><span class="s2"> years old.`</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">greet</span><span class="p">(</span><span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">));</span> <span class="c1">// Hello, my name is Alice and I am 30 years old.</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="3-defining-array-types">3. <strong>Defining Array Types</strong></h4>
<p>Interfaces can describe the shape of arrays, specifying the types of elements they contain.</p>

<h5 id="example-array-with-specific-element-types">Example: Array with specific element types</h5>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">StringArray</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">index</span><span class="p">:</span> <span class="kr">number</span><span class="p">]:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">fruits</span><span class="p">:</span> <span class="nx">StringArray</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">apple</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">banana</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">cherry</span><span class="dl">"</span><span class="p">];</span>
</code></pre></div></div>

<h5 id="example-associative-array-key-value-pairs">Example: Associative array (key-value pairs)</h5>
<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Dictionary</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">key</span><span class="p">:</span> <span class="kr">string</span><span class="p">]:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">inventory</span><span class="p">:</span> <span class="nx">Dictionary</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">apples</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
  <span class="na">bananas</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="4-using-interfaces-with-classes">4. <strong>Using Interfaces with Classes</strong></h4>
<p>Interfaces can act as contracts that classes must adhere to, ensuring the class implements specific properties and methods.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nx">makeSound</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Dog</span> <span class="k">implements</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>

  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">makeSound</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Woof!</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">dog</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Dog</span><span class="p">(</span><span class="dl">"</span><span class="s2">Buddy</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">dog</span><span class="p">.</span><span class="nx">makeSound</span><span class="p">();</span> <span class="c1">// Woof!</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="5-extending-interfaces">5. <strong>Extending Interfaces</strong></h4>
<p>Interfaces can extend other interfaces, allowing you to build on existing definitions.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Shape</span> <span class="p">{</span>
  <span class="nl">color</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Circle</span> <span class="kd">extends</span> <span class="nx">Shape</span> <span class="p">{</span>
  <span class="nl">radius</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">circle</span><span class="p">:</span> <span class="nx">Circle</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">color</span><span class="p">:</span> <span class="dl">"</span><span class="s2">red</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">radius</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="6-hybrid-types">6. <strong>Hybrid Types</strong></h4>
<p>Interfaces can describe entities that act as both objects and functions.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Counter</span> <span class="p">{</span>
  <span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span><span class="p">;</span> <span class="c1">// Function signature</span>
  <span class="nl">count</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>           <span class="c1">// Property</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">counter</span><span class="p">:</span> <span class="nx">Counter</span> <span class="o">=</span> <span class="p">(</span><span class="nx">start</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">counter</span><span class="p">.</span><span class="nx">count</span> <span class="o">=</span> <span class="nx">start</span><span class="p">;</span>
  <span class="k">return</span> <span class="s2">`Counter started at </span><span class="p">${</span><span class="nx">start</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">counter</span><span class="p">.</span><span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">counter</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span> <span class="c1">// Counter started at 10</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">counter</span><span class="p">.</span><span class="nx">count</span><span class="p">);</span> <span class="c1">// 10</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="7-using-generics-with-interfaces">7. <strong>Using Generics with Interfaces</strong></h4>
<p>Interfaces can be generic, making them reusable for various types.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="na">content</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">stringBox</span><span class="p">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="na">content</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span> <span class="p">};</span>
<span class="kd">const</span> <span class="nx">numberBox</span><span class="p">:</span> <span class="nx">Box</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="na">content</span><span class="p">:</span> <span class="mi">42</span> <span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">stringBox</span><span class="p">.</span><span class="nx">content</span><span class="p">);</span> <span class="c1">// Hello</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">numberBox</span><span class="p">.</span><span class="nx">content</span><span class="p">);</span> <span class="c1">// 42</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="8-index-signatures">8. <strong>Index Signatures</strong></h4>
<p>Interfaces can define objects with dynamic keys where the key type is known, but the exact keys are not predefined.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Roles</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">role</span><span class="p">:</span> <span class="kr">string</span><span class="p">]:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">userRoles</span><span class="p">:</span> <span class="nx">Roles</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">admin</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Administrator</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">editor</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Content Editor</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">viewer</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Read-Only User</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="9-intersection-types-with-interfaces">9. <strong>Intersection Types with Interfaces</strong></h4>
<p>Interfaces can be combined with other types using intersection (&amp;) or union (|) types.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">User</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Admin</span> <span class="p">{</span>
  <span class="nl">admin</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">AdminUser</span> <span class="o">=</span> <span class="nx">User</span> <span class="o">&amp;</span> <span class="nx">Admin</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">admin</span><span class="p">:</span> <span class="nx">AdminUser</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">admin</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="10-interfaces-vs-type-aliases">10. <strong>Interfaces vs. Type Aliases</strong></h4>
<p>While interfaces and <a href="typescript-learners-guide#9-type-aliases">type aliases</a> can overlap in functionality, interfaces are better suited for object-like structures, while type aliases excel with unions and complex compositions.</p>

<p>For example:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Interface for object-like structure</span>
<span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Type alias for union types</span>
<span class="kd">type</span> <span class="nx">Role</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">admin</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">user</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">// Type alias for complex composition (union + intersection)</span>
<span class="kd">type</span> <span class="nx">Employee</span> <span class="o">=</span> <span class="nx">Person</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="na">role</span><span class="p">:</span> <span class="nx">Role</span> <span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="11-optional-properties-in-interfaces">11. Optional Properties in Interfaces</h4>
<p>You can make certain properties of an interface optional by adding a question mark (<code class="language-plaintext highlighter-rouge">?</code>) after the property name. This allows objects that implement the interface to omit these properties.</p>

<p>Example:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Car</span> <span class="p">{</span>
  <span class="nl">make</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">model</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">year</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span>  <span class="c1">// Optional property</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">myCar</span><span class="p">:</span> <span class="nx">Car</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">make</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Toyota</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">model</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Corolla</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>
<p>In this case, <code class="language-plaintext highlighter-rouge">year</code> is optional, so the <code class="language-plaintext highlighter-rouge">myCar</code> object can still be valid even without it.</p>

<p><br /></p>

<h3 id="summary">Summary</h3>
<p>Interfaces in TypeScript are a powerful tool that extends far beyond simply defining object shapes. They can describe:</p>

<ol>
  <li>Object structures.</li>
  <li>Function types.</li>
  <li>Array types.</li>
  <li>Classes (via contracts).</li>
  <li>Hybrid types (both objects and functions).</li>
  <li>Generic structures.</li>
  <li>Indexable types.</li>
</ol>

<p>Their versatility makes interfaces a foundational feature for designing flexible and type-safe TypeScript applications.</p>]]></content><author><name>Anusree Anilkumar</name></author><category term="typescript" /><category term="interfaces" /><summary type="html"><![CDATA[Different Usecases for Typescript Interfaces]]></summary></entry><entry><title type="html">More about Mapped Types</title><link href="https://anusree6154s.github.io/documentation/mapped-types" rel="alternate" type="text/html" title="More about Mapped Types" /><published>2025-01-19T00:00:00+00:00</published><updated>2025-01-19T00:00:00+00:00</updated><id>https://anusree6154s.github.io/documentation/mapped-types</id><content type="html" xml:base="https://anusree6154s.github.io/documentation/mapped-types"><![CDATA[<h3 id="mapped-types-in-typescript"><strong>Mapped Types in TypeScript</strong></h3>

<p>Mapped types are a powerful feature in TypeScript that allow you to create new types by transforming the properties of existing types. They are especially useful for modifying the shape or behavior of types dynamically, enabling more flexible and reusable code.</p>

<p><br /></p>

<h3 id="1-syntax-of-mapped-types"><strong>1. Syntax of Mapped Types</strong></h3>

<p>The basic syntax for creating a mapped type is:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">NewType</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">Key</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="p">]:</span> <span class="nx">TransformedType</span> <span class="p">};</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">keyof T</code></strong>: Extracts all keys from the type <code class="language-plaintext highlighter-rouge">T</code> as a union of string or symbol literal types.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">[Key in keyof T]</code></strong>: Iterates over each key in the type <code class="language-plaintext highlighter-rouge">T</code>.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">T[Key]</code></strong>: Accesses the type of the value corresponding to the key <code class="language-plaintext highlighter-rouge">Key</code> in <code class="language-plaintext highlighter-rouge">T</code>.</li>
  <li><strong>Modifiers</strong> (<code class="language-plaintext highlighter-rouge">readonly</code>, <code class="language-plaintext highlighter-rouge">?</code>): Used to adjust the properties (e.g., making them <code class="language-plaintext highlighter-rouge">readonly</code> or optional).</li>
</ul>

<p><br /></p>

<h3 id="2-examples-of-mapped-types"><strong>2. Examples of Mapped Types</strong></h3>

<h4 id="21-readonly-type"><strong>2.1 Readonly Type</strong></h4>

<p>Transforms all properties of an object into <code class="language-plaintext highlighter-rouge">readonly</code> properties, preventing them from being reassigned.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nb">Readonly</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="k">readonly</span> <span class="p">[</span><span class="nx">Key</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="p">]:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">Key</span><span class="p">]</span> <span class="p">};</span>

<span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ReadonlyPerson</span> <span class="o">=</span> <span class="nb">Readonly</span><span class="o">&lt;</span><span class="nx">Person</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">person</span><span class="p">:</span> <span class="nx">ReadonlyPerson</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">30</span> <span class="p">};</span>
<span class="c1">// person.name = "Bob"; // Error: cannot assign to 'name' because it is a read-only property.</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="22-partial-type"><strong>2.2 Partial Type</strong></h4>

<p>Makes all properties of an object optional.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nb">Partial</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">Key</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="p">]?:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">Key</span><span class="p">]</span> <span class="p">};</span>

<span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PartialPerson</span> <span class="o">=</span> <span class="nb">Partial</span><span class="o">&lt;</span><span class="nx">Person</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">person</span><span class="p">:</span> <span class="nx">PartialPerson</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span> <span class="p">};</span> <span class="c1">// `age` is optional</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="23-required-type"><strong>2.3 Required Type</strong></h4>

<p>Makes all properties of an object required.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Required</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">Key</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="p">]</span><span class="o">-</span><span class="p">?:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">Key</span><span class="p">]</span> <span class="p">};</span>

<span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">?:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RequiredPerson</span> <span class="o">=</span> <span class="nx">Required</span><span class="o">&lt;</span><span class="nx">Person</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">person</span><span class="p">:</span> <span class="nx">RequiredPerson</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">30</span> <span class="p">};</span> <span class="c1">// All properties are required</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="24-record-type"><strong>2.4 Record Type</strong></h4>

<p>Creates an object type where keys are specified and values have a uniform type.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nb">Record</span><span class="o">&lt;</span><span class="nx">K</span> <span class="kd">extends</span> <span class="kr">keyof</span> <span class="kr">any</span><span class="p">,</span> <span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">Key</span> <span class="k">in</span> <span class="nx">K</span><span class="p">]:</span> <span class="nx">T</span> <span class="p">};</span>

<span class="kd">type</span> <span class="nx">Roles</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">admin</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">user</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">guest</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">Permissions</span> <span class="o">=</span> <span class="nb">Record</span><span class="o">&lt;</span><span class="nx">Roles</span><span class="p">,</span> <span class="kr">string</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">permissions</span><span class="p">:</span> <span class="nx">Permissions</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">admin</span><span class="p">:</span> <span class="dl">"</span><span class="s2">all</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">user</span><span class="p">:</span> <span class="dl">"</span><span class="s2">read-only</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">guest</span><span class="p">:</span> <span class="dl">"</span><span class="s2">none</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="25-pick-type"><strong>2.5 Pick Type</strong></h4>

<p>Extracts a subset of properties from an object.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nb">Pick</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">K</span> <span class="kd">extends</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">Key</span> <span class="k">in</span> <span class="nx">K</span><span class="p">]:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">Key</span><span class="p">]</span> <span class="p">};</span>

<span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nl">address</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">NameAndAge</span> <span class="o">=</span> <span class="nb">Pick</span><span class="o">&lt;</span><span class="nx">Person</span><span class="p">,</span> <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">age</span><span class="dl">"</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">person</span><span class="p">:</span> <span class="nx">NameAndAge</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">30</span> <span class="p">};</span> <span class="c1">// Only name and age are allowed</span>
</code></pre></div></div>

<p><br /></p>

<h4 id="26-omit-type"><strong>2.6 Omit Type</strong></h4>

<p>Removes specific properties from an object type.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Omit</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">K</span> <span class="kd">extends</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">Pick</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">Exclude</span><span class="o">&lt;</span><span class="kr">keyof</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">K</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nl">address</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">WithoutAddress</span> <span class="o">=</span> <span class="nx">Omit</span><span class="o">&lt;</span><span class="nx">Person</span><span class="p">,</span> <span class="dl">"</span><span class="s2">address</span><span class="dl">"</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">person</span><span class="p">:</span> <span class="nx">WithoutAddress</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">30</span> <span class="p">};</span> <span class="c1">// Address is omitted</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="3-key-modifiers-in-mapped-types"><strong>3. Key Modifiers in Mapped Types</strong></h3>

<h4 id="31-readonly-modifier"><strong>3.1 <code class="language-plaintext highlighter-rouge">readonly</code> Modifier</strong></h4>

<p>Applies the <code class="language-plaintext highlighter-rouge">readonly</code> modifier to all properties, making them immutable.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nb">Readonly</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="k">readonly</span> <span class="p">[</span><span class="nx">Key</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="p">]:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">Key</span><span class="p">]</span> <span class="p">};</span>
</code></pre></div></div>

<h4 id="32--modifier"><strong>3.2 <code class="language-plaintext highlighter-rouge">?</code> Modifier</strong></h4>

<p>Applies the optional (<code class="language-plaintext highlighter-rouge">?</code>) modifier to all properties.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nb">Partial</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">Key</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="p">]?:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">Key</span><span class="p">]</span> <span class="p">};</span>
</code></pre></div></div>

<h4 id="33---modifier"><strong>3.3 <code class="language-plaintext highlighter-rouge">-?</code> Modifier</strong></h4>

<p>Removes the optional modifier from all properties.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Required</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">Key</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="p">]</span><span class="o">-</span><span class="p">?:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">Key</span><span class="p">]</span> <span class="p">};</span>
</code></pre></div></div>

<h4 id="34--readonly-modifier"><strong>3.4 <code class="language-plaintext highlighter-rouge">-readonly</code> Modifier</strong></h4>

<p>Removes the <code class="language-plaintext highlighter-rouge">readonly</code> modifier from all properties.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Mutable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="k">readonly</span> <span class="p">[</span><span class="nx">Key</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="p">]:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">Key</span><span class="p">]</span> <span class="p">};</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="4-combining-mapped-types-with-utility-types"><strong>4. Combining Mapped Types with Utility Types</strong></h3>

<p>Mapped types can be combined with other TypeScript features like <strong>utility types</strong>, <strong>union types</strong>, and <strong>conditional types</strong>.</p>

<h4 id="41-combining-with-union-types"><strong>4.1 Combining with Union Types</strong></h4>

<p>You can use mapped types to iterate over a union of keys.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">OptionsFlags</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">Key</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="p">]:</span> <span class="nx">boolean</span> <span class="p">};</span>

<span class="kr">interface</span> <span class="nx">Features</span> <span class="p">{</span>
  <span class="nl">darkMode</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
  <span class="nl">newUser</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">FeatureFlags</span> <span class="o">=</span> <span class="nx">OptionsFlags</span><span class="o">&lt;</span><span class="nx">Features</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">flags</span><span class="p">:</span> <span class="nx">FeatureFlags</span> <span class="o">=</span> <span class="p">{</span> <span class="na">darkMode</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">newUser</span><span class="p">:</span> <span class="kc">false</span> <span class="p">};</span>
</code></pre></div></div>

<h4 id="42-using-conditional-types"><strong>4.2 Using Conditional Types</strong></h4>

<p>You can conditionally modify the properties of a mapped type.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Nullable</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">Key</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="p">]:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">Key</span><span class="p">]</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">};</span>

<span class="kr">interface</span> <span class="nx">User</span> <span class="p">{</span>
  <span class="nl">id</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">NullableUser</span> <span class="o">=</span> <span class="nx">Nullable</span><span class="o">&lt;</span><span class="nx">User</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">user</span><span class="p">:</span> <span class="nx">NullableUser</span> <span class="o">=</span> <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Alice</span><span class="dl">"</span> <span class="p">};</span> <span class="c1">// Properties can be null</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="5-advanced-use-cases"><strong>5. Advanced Use Cases</strong></h3>

<h4 id="51-deep-readonly"><strong>5.1 Deep Readonly</strong></h4>

<p>Make all properties of an object (and its nested objects) <code class="language-plaintext highlighter-rouge">readonly</code>.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">DeepReadonly</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="k">readonly</span> <span class="p">[</span><span class="nx">Key</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="p">]:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">Key</span><span class="p">]</span> <span class="kd">extends</span> <span class="nx">object</span> <span class="p">?</span> <span class="nx">DeepReadonly</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">[</span><span class="nx">Key</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">Key</span><span class="p">];</span>
<span class="p">};</span>

<span class="kr">interface</span> <span class="nx">NestedObject</span> <span class="p">{</span>
  <span class="nl">level1</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">level2</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">value</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">obj</span><span class="p">:</span> <span class="nx">DeepReadonly</span><span class="o">&lt;</span><span class="nx">NestedObject</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">level1</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">level2</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">value</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Hello</span><span class="dl">"</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">};</span>

<span class="c1">// obj.level1.level2.value = "New Value"; // Error</span>
</code></pre></div></div>

<h4 id="52-filtering-keys"><strong>5.2 Filtering Keys</strong></h4>

<p>Extract keys from an object based on their types.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">FilterKeys</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="nx">Key</span> <span class="k">in</span> <span class="kr">keyof</span> <span class="nx">T</span><span class="p">]:</span> <span class="nx">T</span><span class="p">[</span><span class="nx">Key</span><span class="p">]</span> <span class="kd">extends</span> <span class="nx">U</span> <span class="p">?</span> <span class="nx">Key</span> <span class="p">:</span> <span class="nx">never</span> <span class="p">}[</span><span class="kr">keyof</span> <span class="nx">T</span><span class="p">];</span>

<span class="kr">interface</span> <span class="nx">Example</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nl">isActive</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StringKeys</span> <span class="o">=</span> <span class="nx">FilterKeys</span><span class="o">&lt;</span><span class="nx">Example</span><span class="p">,</span> <span class="kr">string</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// "name"</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="6-how-mapped-types-relate-to-other-topics"><strong>6. How Mapped Types Relate to Other Topics</strong></h3>

<p>Mapped types build upon foundational TypeScript concepts:</p>

<ol>
  <li><strong>Generics</strong>: Mapped types often use generics to create reusable type transformations.</li>
  <li><strong>Type Inference</strong>: TypeScript infers types within mapped types to ensure transformations are type-safe.</li>
  <li><strong>Union and Intersection Types</strong>: Mapped types frequently operate on unions or intersecting types to create flexible transformations.</li>
</ol>

<p><br /></p>

<h3 id="conclusion"><strong>Conclusion</strong></h3>

<p>Mapped types are a cornerstone of TypeScript’s type system, enabling developers to create dynamic, reusable, and type-safe transformations. By leveraging features like key modifiers, utility types, and conditional types, you can write more expressive and maintainable code tailored to your application’s needs. They provide the flexibility to adapt types without losing TypeScript’s static type-checking benefits.</p>]]></content><author><name>Anusree Anilkumar</name></author><category term="typescript" /><category term="mapped types" /><summary type="html"><![CDATA[Mapped Types in TypeScript Mapped types are a powerful feature in TypeScript that allow you to create new types by transforming the properties of existing types. They are especially useful for modifying the shape or behavior of types dynamically, enabling more flexible and reusable code. 1. Syntax of Mapped Types The basic syntax for creating a mapped type is: type NewType&lt;T&gt; = { [Key in keyof T]: TransformedType }; keyof T: Extracts all keys from the type T as a union of string or symbol literal types. [Key in keyof T]: Iterates over each key in the type T. T[Key]: Accesses the type of the value corresponding to the key Key in T. Modifiers (readonly, ?): Used to adjust the properties (e.g., making them readonly or optional). 2. Examples of Mapped Types 2.1 Readonly Type Transforms all properties of an object into readonly properties, preventing them from being reassigned. type Readonly&lt;T&gt; = { readonly [Key in keyof T]: T[Key] }; interface Person { name: string; age: number; } type ReadonlyPerson = Readonly&lt;Person&gt;; const person: ReadonlyPerson = { name: "Alice", age: 30 }; // person.name = "Bob"; // Error: cannot assign to 'name' because it is a read-only property. 2.2 Partial Type Makes all properties of an object optional. type Partial&lt;T&gt; = { [Key in keyof T]?: T[Key] }; interface Person { name: string; age: number; } type PartialPerson = Partial&lt;Person&gt;; const person: PartialPerson = { name: "Alice" }; // `age` is optional 2.3 Required Type Makes all properties of an object required. type Required&lt;T&gt; = { [Key in keyof T]-?: T[Key] }; interface Person { name?: string; age?: number; } type RequiredPerson = Required&lt;Person&gt;; const person: RequiredPerson = { name: "Alice", age: 30 }; // All properties are required 2.4 Record Type Creates an object type where keys are specified and values have a uniform type. type Record&lt;K extends keyof any, T&gt; = { [Key in K]: T }; type Roles = "admin" | "user" | "guest"; type Permissions = Record&lt;Roles, string&gt;; const permissions: Permissions = { admin: "all", user: "read-only", guest: "none", }; 2.5 Pick Type Extracts a subset of properties from an object. type Pick&lt;T, K extends keyof T&gt; = { [Key in K]: T[Key] }; interface Person { name: string; age: number; address: string; } type NameAndAge = Pick&lt;Person, "name" | "age"&gt;; const person: NameAndAge = { name: "Alice", age: 30 }; // Only name and age are allowed 2.6 Omit Type Removes specific properties from an object type. type Omit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;; interface Person { name: string; age: number; address: string; } type WithoutAddress = Omit&lt;Person, "address"&gt;; const person: WithoutAddress = { name: "Alice", age: 30 }; // Address is omitted 3. Key Modifiers in Mapped Types 3.1 readonly Modifier Applies the readonly modifier to all properties, making them immutable. type Readonly&lt;T&gt; = { readonly [Key in keyof T]: T[Key] }; 3.2 ? Modifier Applies the optional (?) modifier to all properties. type Partial&lt;T&gt; = { [Key in keyof T]?: T[Key] }; 3.3 -? Modifier Removes the optional modifier from all properties. type Required&lt;T&gt; = { [Key in keyof T]-?: T[Key] }; 3.4 -readonly Modifier Removes the readonly modifier from all properties. type Mutable&lt;T&gt; = { -readonly [Key in keyof T]: T[Key] }; 4. Combining Mapped Types with Utility Types Mapped types can be combined with other TypeScript features like utility types, union types, and conditional types. 4.1 Combining with Union Types You can use mapped types to iterate over a union of keys. type OptionsFlags&lt;T&gt; = { [Key in keyof T]: boolean }; interface Features { darkMode: () =&gt; void; newUser: () =&gt; void; } type FeatureFlags = OptionsFlags&lt;Features&gt;; const flags: FeatureFlags = { darkMode: true, newUser: false }; 4.2 Using Conditional Types You can conditionally modify the properties of a mapped type. type Nullable&lt;T&gt; = { [Key in keyof T]: T[Key] | null }; interface User { id: number; name: string; } type NullableUser = Nullable&lt;User&gt;; const user: NullableUser = { id: null, name: "Alice" }; // Properties can be null 5. Advanced Use Cases 5.1 Deep Readonly Make all properties of an object (and its nested objects) readonly. type DeepReadonly&lt;T&gt; = { readonly [Key in keyof T]: T[Key] extends object ? DeepReadonly&lt;T[Key]&gt; : T[Key]; }; interface NestedObject { level1: { level2: { value: string; }; }; } const obj: DeepReadonly&lt;NestedObject&gt; = { level1: { level2: { value: "Hello", }, }, }; // obj.level1.level2.value = "New Value"; // Error 5.2 Filtering Keys Extract keys from an object based on their types. type FilterKeys&lt;T, U&gt; = { [Key in keyof T]: T[Key] extends U ? Key : never }[keyof T]; interface Example { name: string; age: number; isActive: boolean; } type StringKeys = FilterKeys&lt;Example, string&gt;; // "name" 6. How Mapped Types Relate to Other Topics Mapped types build upon foundational TypeScript concepts: Generics: Mapped types often use generics to create reusable type transformations. Type Inference: TypeScript infers types within mapped types to ensure transformations are type-safe. Union and Intersection Types: Mapped types frequently operate on unions or intersecting types to create flexible transformations. Conclusion Mapped types are a cornerstone of TypeScript’s type system, enabling developers to create dynamic, reusable, and type-safe transformations. By leveraging features like key modifiers, utility types, and conditional types, you can write more expressive and maintainable code tailored to your application’s needs. They provide the flexibility to adapt types without losing TypeScript’s static type-checking benefits.]]></summary></entry><entry><title type="html">More about Module Augmentation</title><link href="https://anusree6154s.github.io/documentation/module-augmentation" rel="alternate" type="text/html" title="More about Module Augmentation" /><published>2025-01-19T00:00:00+00:00</published><updated>2025-01-19T00:00:00+00:00</updated><id>https://anusree6154s.github.io/documentation/module-augmentation</id><content type="html" xml:base="https://anusree6154s.github.io/documentation/module-augmentation"><![CDATA[<h3 id="1-module-augmentation">1. <strong>Module Augmentation</strong></h3>

<ul>
  <li><strong>What It Is</strong>: Allows you to extend or modify the functionality of existing modules (third-party libraries or built-in modules).</li>
  <li><strong>How It Works</strong>:
    <ul>
      <li>You use the <code class="language-plaintext highlighter-rouge">declare module</code> syntax to tell TypeScript that you’re adding or modifying properties or types within an existing module.</li>
      <li>TypeScript merges your changes with the existing module definitions.</li>
    </ul>
  </li>
  <li><strong>Use Cases</strong>:
    <ul>
      <li>Add custom properties to objects from third-party libraries (e.g., adding properties to Express’s <code class="language-plaintext highlighter-rouge">Request</code> object).</li>
      <li>Modify existing interfaces or classes to match specific application requirements.</li>
    </ul>
  </li>
  <li>
    <p><strong>Example</strong>: Adding a <code class="language-plaintext highlighter-rouge">user</code> property to the <code class="language-plaintext highlighter-rouge">Request</code> interface in Express:
<code class="language-plaintext highlighter-rouge">typescript
 declare module "express" {
 interface Request {
   user?: string;
 }
 }
 </code></p>

    <p><br /></p>
  </li>
</ul>

<h3 id="2-global-module-augmentation">2. <strong>Global Module Augmentation</strong></h3>

<ul>
  <li><strong>What It Is</strong>: Extends or modifies global objects like <code class="language-plaintext highlighter-rouge">window</code> (in browsers) or <code class="language-plaintext highlighter-rouge">process</code> (in Node.js).</li>
  <li><strong>How It Works</strong>:
    <ul>
      <li>Use <code class="language-plaintext highlighter-rouge">declare global</code> within a <code class="language-plaintext highlighter-rouge">.d.ts</code> declaration file to augment global objects.</li>
      <li>This applies the modifications globally across your entire application.</li>
    </ul>
  </li>
  <li><strong>Use Cases</strong>:
    <ul>
      <li>Add custom properties to global objects that are available throughout the application.</li>
    </ul>
  </li>
  <li>
    <p><strong>Example</strong>: Augmenting the <code class="language-plaintext highlighter-rouge">window</code> object in a browser environment:
<code class="language-plaintext highlighter-rouge">typescript
 declare global {
 interface Window {
   user?: string;
 }
 }
 // Now you can access `window.user` anywhere in your code
 window.user = "Alice"; 
</code></p>

    <p><br /></p>
  </li>
</ul>

<h3 id="3-key-concepts">3. <strong>Key Concepts</strong></h3>

<ul>
  <li><strong>Declaration Merging</strong>: When you augment a module or global object, TypeScript merges your new declarations with the original module definitions.</li>
  <li><strong>Type Safety</strong>: TypeScript ensures that the augmentations are type-safe, preventing errors when accessing augmented properties.</li>
  <li>
    <p><strong>Modifying Existing Modules</strong>: You can modify an existing module’s interfaces, classes, or methods without modifying the original module code.</p>

    <p><br /></p>
  </li>
</ul>

<h3 id="4-examples-of-module-augmentation">4. <strong>Examples of Module Augmentation</strong></h3>

<ul>
  <li><strong>Extending Express’s <code class="language-plaintext highlighter-rouge">Request</code> object</strong>:
    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">declare</span> <span class="kr">module</span> <span class="dl">"</span><span class="s2">express</span><span class="dl">"</span> <span class="p">{</span>
  <span class="kr">interface</span> <span class="nx">Request</span> <span class="p">{</span>
    <span class="nl">user</span><span class="p">?:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Augmenting the <code class="language-plaintext highlighter-rouge">process</code> object in Node.js</strong>:
<code class="language-plaintext highlighter-rouge">typescript
 declare global {
 namespace NodeJS {
   interface Process {
     myCustomProperty?: string;
   }
 }
 }
 </code>
<br /></li>
</ul>

<h3 id="5-why-use-module-and-global-augmentation">5. <strong>Why Use Module and Global Augmentation?</strong></h3>

<ul>
  <li><strong>Third-party Libraries</strong>: Modify and extend third-party libraries without changing their code.</li>
  <li><strong>Customization</strong>: Customize existing global objects to fit your application’s needs (e.g., adding properties to <code class="language-plaintext highlighter-rouge">window</code> or <code class="language-plaintext highlighter-rouge">process</code>).</li>
  <li>
    <p><strong>Type Safety</strong>: TypeScript ensures that your augmentations are compatible with the existing types in the module or global object.</p>

    <p><br /></p>
  </li>
</ul>

<h3 id="6-best-practices">6. <strong>Best Practices</strong></h3>

<ul>
  <li><strong>Use <code class="language-plaintext highlighter-rouge">.d.ts</code> Files</strong>: Keep augmentations in separate <code class="language-plaintext highlighter-rouge">.d.ts</code> declaration files to maintain type safety and organization.</li>
  <li><strong>Be Cautious with Global Augmentations</strong>: Augmenting global objects affects the entire application, so use this feature carefully to avoid conflicts.</li>
  <li><strong>Namespace Management</strong>: When augmenting global types (like <code class="language-plaintext highlighter-rouge">process</code> or <code class="language-plaintext highlighter-rouge">window</code>), always use the <code class="language-plaintext highlighter-rouge">declare global</code> syntax to avoid conflicts with other modules.</li>
</ul>

<p><br /></p>

<h3 id="summary">Summary:</h3>

<ul>
  <li><strong>Module Augmentation</strong>: Extends or modifies existing modules (e.g., Express, React) to add custom functionality.</li>
  <li><strong>Global Module Augmentation</strong>: Extends or modifies global objects (like <code class="language-plaintext highlighter-rouge">window</code>, <code class="language-plaintext highlighter-rouge">process</code>) to add custom properties accessible across your entire application.</li>
  <li><strong>Declaration Merging</strong>: TypeScript merges your changes with the original declarations, allowing you to safely extend third-party modules and global objects.</li>
</ul>]]></content><author><name>Anusree Anilkumar</name></author><category term="typescript" /><category term="module augmentation" /><summary type="html"><![CDATA[1. Module Augmentation What It Is: Allows you to extend or modify the functionality of existing modules (third-party libraries or built-in modules). How It Works: You use the declare module syntax to tell TypeScript that you’re adding or modifying properties or types within an existing module. TypeScript merges your changes with the existing module definitions. Use Cases: Add custom properties to objects from third-party libraries (e.g., adding properties to Express’s Request object). Modify existing interfaces or classes to match specific application requirements. Example: Adding a user property to the Request interface in Express: typescript declare module "express" { interface Request { user?: string; } } 2. Global Module Augmentation What It Is: Extends or modifies global objects like window (in browsers) or process (in Node.js). How It Works: Use declare global within a .d.ts declaration file to augment global objects. This applies the modifications globally across your entire application. Use Cases: Add custom properties to global objects that are available throughout the application. Example: Augmenting the window object in a browser environment: typescript declare global { interface Window { user?: string; } } // Now you can access `window.user` anywhere in your code window.user = "Alice"; 3. Key Concepts Declaration Merging: When you augment a module or global object, TypeScript merges your new declarations with the original module definitions. Type Safety: TypeScript ensures that the augmentations are type-safe, preventing errors when accessing augmented properties. Modifying Existing Modules: You can modify an existing module’s interfaces, classes, or methods without modifying the original module code. 4. Examples of Module Augmentation Extending Express’s Request object: declare module "express" { interface Request { user?: string; } } Augmenting the process object in Node.js: typescript declare global { namespace NodeJS { interface Process { myCustomProperty?: string; } } } 5. Why Use Module and Global Augmentation? Third-party Libraries: Modify and extend third-party libraries without changing their code. Customization: Customize existing global objects to fit your application’s needs (e.g., adding properties to window or process). Type Safety: TypeScript ensures that your augmentations are compatible with the existing types in the module or global object. 6. Best Practices Use .d.ts Files: Keep augmentations in separate .d.ts declaration files to maintain type safety and organization. Be Cautious with Global Augmentations: Augmenting global objects affects the entire application, so use this feature carefully to avoid conflicts. Namespace Management: When augmenting global types (like process or window), always use the declare global syntax to avoid conflicts with other modules. Summary: Module Augmentation: Extends or modifies existing modules (e.g., Express, React) to add custom functionality. Global Module Augmentation: Extends or modifies global objects (like window, process) to add custom properties accessible across your entire application. Declaration Merging: TypeScript merges your changes with the original declarations, allowing you to safely extend third-party modules and global objects.]]></summary></entry></feed>