[
  
    {
      "title": "Flutter Setup Guide",
      "url": "/documentation/setting-up-flutter",
      "date": "2025-07-13",
      "content": "I have been looking on how to create my own gujrati learning app and thought, well why not learn something that’s used in my office. And so I chose flutter. Now I was used to using vs code. So went and prompted gpt to help me set up flutter in vs code, and this is its response that worked well for me:  🚀 Flutter Development with VS Code            ✅ 1. Install Prerequisites                        📦 Flutter SDK                      Go to: https://docs.flutter.dev/get-started/install            Download for your OS (Windows/Linux/macOS)            Extract and add the flutter/bin folder to your system PATH                                To verify installation:                    flutter --version                                    💻 Install VS Code                      Download: https://code.visualstudio.com/                                    🧩 Install Extensions in VS Code                      Open VS Code            Go to Extensions (Ctrl+Shift+X)                          Install these:                              ✅ Flutter (by Dart Code)                ✅ Dart (automatically gets installed with Flutter)                                                              📱 Install Android Studio (for Android SDK &amp; Emulator)                      You don’t need to use Android Studio, but you do need its SDK + emulator                                Install: https://developer.android.com/studio            During setup, check: Android SDK + Emulator                          After install, open Android Studio &gt; Preferences &gt; SDK Manager                              Ensure Android SDK, platform tools, and at least one API version are installed                                                          For emulator:                                Create one using AVD Manager inside Android Studio            Or use a real Android device in developer mode + USB debugging                                      ⚙️ 2. Check Flutter Environment      Run:      flutter doctor            ✅ It should show checkmarks for:              Flutter        Dart        Android toolchain        VS Code        (iOS only if on macOS)                    📁 3. Create a New Flutter Project      In terminal or VS Code terminal:      flutter create my_appcd my_appcode .    ## opens the project in VS Code                    👨‍💻 4. Run Your App              Connect your Android device or start an emulator                  In terminal:          flutter run                              Or use F5 in VS Code to launch the debugger.              📂 5. Start Coding              Your main file: lib/main.dart        Modify the default code or replace with your own UI                    🔁 6. Hot Reload / Restart              Save file to see changes instantly (hot reload)        Use r or R in terminal when app is running        Or use the Flutter toolbar in VS Code              🛠 Optional: Android App Icon &amp; Name      Edit in android/app/src/main/AndroidManifest.xml    Use package: flutter_launcher_icons  "
    },
  
    {
      "title": "Basics of Dart",
      "url": "/documentation/basics-of-dart",
      "date": "2025-07-13",
      "content": "Since I began learning flutter, dart was a new language for me. I came to know that dart is the most similar to java language which also I was just partially informed in.And there I was stuckSo here goes a small basics chart I made gpt give me that seems to be quite helpful in catching the basic flow of the code it generates futher for my dart project:  ✅ Essential Dart Concepts for Flutter Beginners  1. Variables &amp; Data Types  int age = 25;double price = 9.99;String name = 'Anu';bool isLoggedIn = true;var anything = 'Can be any type';        var = type inferred automatically          final / const = cannot be changed after initialization      final name = 'Anu';  // run-time constantconst pi = 3.14;     // compile-time constant              2. Functions  String greet(String name) {  return 'Hello, $name!';}void printMessage() {  print('Hi there!');}              You can also write short functions like:      int square(int x) =&gt; x * x;              3. Classes &amp; Objects  class Person {  String name;  int age;  Person(this.name, this.age);  void introduce() {    print('I am $name and I am $age years old.');  }}              Create an object:      var p = Person('Anu', 21);p.introduce();              4. Constructors            Default, named, and optional constructors:      class Product {  String name;  double price;  Product({required this.name, required this.price});}var p = Product(name: 'Shoes', price: 99.99);              5. Collections: Lists, Maps, Sets  Lists (Arrays)  List&lt;String&gt; fruits = ['apple', 'banana'];fruits.add('mango');    Maps (Key-Value pairs)  Map&lt;String, int&gt; scores = {'math': 90, 'english': 85};print(scores['math']);    Sets (Unique items)  Set&lt;String&gt; cities = {'Paris', 'London', 'Paris'};print(cities.length);  // 2    6. Control Flow      If/Else, For, While, Switch    if (age &gt; 18) {  print('Adult');} else {  print('Minor');}for (var i = 0; i &lt; 3; i++) {  print(i);}    7. Null Safety      Dart doesn’t allow null unless you tell it:    String? name;  // nullablename = null;   // OKString name2 = 'Anu';// name2 = null; // ❌ Error    8. Async / Await &amp; Futures  Used when dealing with APIs, delays, etc.  Future&lt;String&gt; fetchData() async {  await Future.delayed(Duration(seconds: 2));  return 'Data loaded';}void main() async {  print('Start');  String data = await fetchData();  print(data);}    9. Getters &amp; Setters  class Rectangle {  double width, height;  Rectangle(this.width, this.height);  double get area =&gt; width * height;  set resize(double factor) {    width *= factor;    height *= factor;  }}    10. Basic Error Handling  try {  int result = 10 ~/ 0;} catch (e) {  print('Caught error: $e');}    🧠 Bonus: Flutter-Specific Must-Knows                    Concept        Why it matters                            main()        Entry point of every Dart/Flutter app                    Widget        Everything is a widget (UI blocks)                    StatelessWidget        For static UIs                    StatefulWidget        For interactive UIs                    setState()        Rebuilds part of the UI                    async/await        Needed for API, DB, etc. in Flutter              ✅ Summary: Start With These 10                    ✅ Must-Learn Concepts                            ✅ Variables &amp; Types                    ✅ Functions                    ✅ Classes &amp; Objects                    ✅ Collections                    ✅ Null Safety                    ✅ Control Flow                    ✅ Async/Await                    ✅ Constructors                    ✅ Getters/Setters                    ✅ Error Handling            "
    },
  
    {
      "title": "Using Bootstrap Icons",
      "url": "/documentation/bootstrap-icons-usage",
      "date": "2025-03-04",
      "content": "1. Install Bootstrap Icons (Recommended - I use this)If you’re using a package manager like npm or yarn, install Bootstrap Icons:npm install bootstrap-iconsoryarn add bootstrap-iconsThen, import the CSS in your index.js or App.js:import 'bootstrap-icons/font/bootstrap-icons.css';Now, you can use icons like this in your components:&lt;i className=\"bi bi-heart\"&gt;&lt;/i&gt;2. Use Bootstrap Icons via CDN (Alternative)If you don’t want to install the package, add this CDN link in your index.html (inside &lt;head&gt;):&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css\"&gt;Then, you can use icons directly in your components:&lt;i className=\"bi bi-heart\"&gt;&lt;/i&gt;3. Using Icons as React Components (For Better Performance)Instead of &lt;i&gt; tags, you can import SVG icons directly:import { ReactComponent as HeartIcon } from 'bootstrap-icons/icons/heart.svg';const MyComponent = () =&gt; {  return &lt;HeartIcon width=\"24\" height=\"24\" fill=\"red\" /&gt;;};"
    },
  
    {
      "title": "Tailwind styling without inline",
      "url": "/documentation/tailwing-styling-without-inline",
      "date": "2025-03-03",
      "content": "1️⃣ Use @apply in a Global CSS FileYou can define reusable styles in a CSS file and use @apply to apply Tailwind classes.🔹 Steps:  Create a global CSS file (e.g., globals.css).  Define your reusable styles using @apply.  Import the CSS file into your project (usually in _app.js or layout.tsx).📌 Example (globals.css):/* Define reusable styles */.btn-primary {  @apply bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600 transition;}.card {  @apply p-6 shadow-md border border-gray-200 rounded-lg bg-white;}📌 Usage in a Component:&lt;button className=\"btn-primary\"&gt;Click Me&lt;/button&gt;&lt;div className=\"card\"&gt;This is a card&lt;/div&gt;2️⃣ Use Tailwind’s Config File (tailwind.config.js)If you need custom colors, spacing, or typography, you can extend Tailwind’s configuration.📌 Example (tailwind.config.js):module.exports = {  theme: {    extend: {      colors: {        primary: \"#1D4ED8\", // Custom primary color      },    },  },};📌 Usage in Components:&lt;button className=\"bg-primary text-white px-4 py-2 rounded-md\"&gt;Click Me&lt;/button&gt;3️⃣ Use Component-Specific Styling in a module.css FileIf you’re using Next.js or a module-based approach, you can create a module.css file.📌 Example (Button.module.css):.btn {  @apply bg-green-500 text-white px-4 py-2 rounded-md hover:bg-green-600;}📌 Usage in Component:import styles from \"./Button.module.css\";&lt;button className={styles.btn}&gt;Click Me&lt;/button&gt;;4️⃣ Use Tailwind with a Component-Based ApproachIf you’re using React/Next.js, you can create reusable styled components.📌 Example (Button.tsx):const Button = ({ children }) =&gt; {  return &lt;button className=\"bg-blue-500 text-white px-4 py-2 rounded-md\"&gt;{children}&lt;/button&gt;;};export default Button;📌 Usage in a File:&lt;Button&gt;Click Me&lt;/Button&gt;"
    },
  
    {
      "title": "External Image Optimisation",
      "url": "/documentation/optimise-img-external",
      "date": "2025-03-03",
      "content": "Optimising image imported from external sourceIn order to optimise image there are various methods:  Reduce image size (while importing with external source permits)  Reduce image quality (while importing with external source permits)  Import as webp if external source permitsSome methods I’ve used so far:      When nothing could be done while importing, this method has been applied    It involves editing the image, drawing it in a canvas and display the redrawn image.    code:     import React, { useState, useEffect } from \"react\"; const ImageTransformer = ({ src, maxWidth = 500, quality = 0.7 }) =&gt; { const [compressedSrc, setCompressedSrc] = useState(null); useEffect(() =&gt; {     const compressImage = async () =&gt; {     const img = new Image();     img.crossOrigin = \"anonymous\"; // Prevent CORS issues     img.src = src;     img.onload = () =&gt; {         const canvas = document.createElement(\"canvas\");         const ctx = canvas.getContext(\"2d\");         // Resize while keeping aspect ratio         const scale = maxWidth / img.width;         canvas.width = maxWidth;         canvas.height = img.height * scale;         // Draw image on the canvas         ctx.drawImage(img, 0, 0, canvas.width, canvas.height);         // Convert to compressed WebP format         const compressedDataUrl = canvas.toDataURL(\"image/webp\", quality);         setCompressedSrc(compressedDataUrl);     };     };     compressImage(); }, [src, maxWidth, quality]); return (     &lt;img src={compressedSrc || src} alt=\"Compressed\" width=\"100%\" /&gt; ); }; export default ImageTransformer;      "
    },
  
    {
      "title": "Vercel .env extraction",
      "url": "/documentation/vercel-env",
      "date": "2025-02-27",
      "content": "Vercel Env Variable ExtractionTo extract environment variables from an app deployed in vercel, from vercel to our local IDE, we just have to do the following:  Open the respective app in your IDE  run vercel pull and link with your existing deployed vercel app  run vercel env pull .env or vercel env pull .env.localThe env variables will appear in your IDE in a dedicated file easily!"
    },
  
    {
      "title": "MongoDB Concepts Guide",
      "url": "/documentation/react",
      "date": "2025-02-25",
      "content": "  Topics Constituting Basic MongoDB    1. Introduction to MongoDB    2. MongoDB Installation and Setup    3. CRUD Operations  4. MongoDB Data Types5. Collections and Documents6. Querying Data7. Indexing Basics8. Aggregation Basics9. Basic Security10. MongoDB Drivers and Tools  Topics Constituting Advanced MongoDB    1. Advanced Indexing  2. Aggregation Framework3. Schema Design4. Transactions5. Replication6. Sharding7. Performance Optimization8. MongoDB Atlas9. Backup and Restore10. Security Enhancements11. MongoDB and Big Data Integration12. Advanced Query Techniques13. Horizontal Scaling and High Availability14. Customizations and Plugins"
    },
  
    {
      "title": "FE-101 HTML",
      "url": "/documentation/crio-interview-questions-node-202",
      "date": "2025-02-20",
      "content": ""
    },
  
    {
      "title": "FE-101 HTML",
      "url": "/documentation/crio-interview-questions-node-201",
      "date": "2025-02-20",
      "content": ""
    },
  
    {
      "title": "FE-101 HTML",
      "url": "/documentation/crio-interview-questions-mern-2",
      "date": "2025-02-20",
      "content": ""
    },
  
    {
      "title": "FE-101 HTML",
      "url": "/documentation/crio-interview-questions-hld-1",
      "date": "2025-02-20",
      "content": ""
    },
  
    {
      "title": "FE-101 HTML",
      "url": "/documentation/crio-interview-questions-fe-intv-1",
      "date": "2025-02-20",
      "content": ""
    },
  
    {
      "title": "FE-101 HTML",
      "url": "/documentation/crio-interview-questions-fe-302",
      "date": "2025-02-20",
      "content": ""
    },
  
    {
      "title": "FE-101 HTML",
      "url": "/documentation/crio-interview-questions-fe-301",
      "date": "2025-02-20",
      "content": ""
    },
  
    {
      "title": "FE-101 HTML",
      "url": "/documentation/crio-interview-questions-fe-202",
      "date": "2025-02-20",
      "content": ""
    },
  
    {
      "title": "FE-101 HTML",
      "url": "/documentation/crio-interview-questions-fe-201",
      "date": "2025-02-20",
      "content": ""
    },
  
    {
      "title": "FE-101 HTML",
      "url": "/documentation/crio-interview-questions-fe-103",
      "date": "2025-02-20",
      "content": ""
    },
  
    {
      "title": "FE-101 HTML",
      "url": "/documentation/crio-interview-questions-fe-102",
      "date": "2025-02-20",
      "content": ""
    },
  
    {
      "title": "FE-101 HTML",
      "url": "/documentation/crio-interview-questions-fe-101",
      "date": "2025-02-20",
      "content": "Crio Questions  How does the browser load HTML and JS files upon visiting a particular website?  What is the purpose of the ‘doctype’ declaration in HTML documents?  What are the differences between block elements, inline elements, and inline-block elements?  What are the differences between HTML and HTML5?  What are the differences between semantic and non-semantic HTML tags?  Explain CSS selectors and their types.  What is CSS selector specificity and how does it work?  What is CSS Box Model?  What is the difference between absolute and relative length units in CSS? Provide examples.  What is CSS Flexbox?  What is responsive web design?  What are the differences between CSS Grids and Flexbox?  What is Bootstrap?  What are the different CSS position property values?  What is z-index in CSS?GPT Answers1. How does the browser load HTML and JS files upon visiting a particular website?When you visit a website, the browser follows these steps to load HTML and JavaScript files:  DNS Resolution: The browser resolves the domain name into an IP address using the Domain Name System (DNS).  Sending HTTP Request: The browser sends an HTTP request to the server where the website is hosted.  Server Response: The server responds by sending the requested HTML document (and any associated assets like CSS, JavaScript, images, etc.).  Parsing HTML: The browser begins parsing the HTML document and constructing the DOM (Document Object Model) tree.  Fetching External Resources:          The browser identifies external resources like CSS and JavaScript files (linked with &lt;link&gt; or &lt;script&gt; tags).      It sends additional HTTP requests to fetch those resources.      JavaScript files are executed in the order they appear (unless async or defer attributes are used).        Applying Styles: The browser parses CSS files and applies styles to the DOM elements.  Rendering: After the HTML and CSS are parsed and styles are applied, the browser renders the page on the screen.  Execution of JS: JavaScript files can manipulate the DOM and CSSOM to update the content and style dynamically (e.g., user interactions, animations, etc.).2. What is the purpose of the ‘doctype’ declaration in HTML documents?The &lt;!DOCTYPE&gt; declaration:  Tells the browser which version of HTML the document is written in, ensuring that the page is rendered correctly.  In modern web development, &lt;!DOCTYPE html&gt; is used to declare the document type as HTML5, instructing the browser to render the document in standards mode.  Without a doctype declaration, browsers may switch to quirks mode, which can lead to inconsistent rendering across different browsers.3. What are the differences between block elements, inline elements, and inline-block elements?  Block Elements:          Occupy the entire width of their parent container.      Always start on a new line (stacked vertically).      Examples: &lt;div&gt;, &lt;p&gt;, &lt;h1&gt;, &lt;ul&gt;.        Inline Elements:          Do not start on a new line and only occupy the width necessary for their content.      Can be placed inside block elements and other inline elements.      Examples: &lt;span&gt;, &lt;a&gt;, &lt;strong&gt;, &lt;em&gt;.        Inline-block Elements:          Behave like inline elements (do not start on a new line), but they can have set widths and heights like block elements.      Examples: &lt;button&gt;, &lt;img&gt;, &lt;input&gt;.      4. What are the differences between HTML and HTML5?HTML5 is the latest version of HTML and includes new features and improvements over previous versions of HTML.Key Differences:  New Semantic Elements: Tags like &lt;article&gt;, &lt;section&gt;, &lt;nav&gt;, &lt;header&gt;, &lt;footer&gt; improve the structure and meaning of web content.  Audio and Video: HTML5 has native support for embedding audio and video using the &lt;audio&gt; and &lt;video&gt; tags, without third-party plugins like Flash.  Local Storage: Introduces localStorage and sessionStorage for storing data on the client side.  Geolocation API: Allows websites to access the user’s location.  Forms: Adds new input types (e.g., email, date, range) and attributes (e.g., placeholder, required).  Deprecated Tags: Tags like &lt;font&gt;, &lt;center&gt;, and &lt;marquee&gt; have been deprecated.5. What are the differences between semantic and non-semantic HTML tags?  Semantic HTML Tags:          These tags describe the meaning of the content enclosed within them, providing context for developers and search engines.      Examples: &lt;article&gt;, &lt;section&gt;, &lt;header&gt;, &lt;footer&gt;, &lt;nav&gt;, &lt;main&gt;.      They improve accessibility and SEO (Search Engine Optimization).        Non-Semantic HTML Tags:          These tags do not convey any meaning about their content; they are used mainly for structuring or styling the page.      Examples: &lt;div&gt;, &lt;span&gt;.      These elements require additional context or class names to define their purpose.      6. Explain CSS selectors and their types.CSS selectors are patterns used to select and style elements in an HTML document. Common types include:  Universal Selector (*): Selects all elements.```css          {color: red;}```        Type Selector (Element Selector): Selects all elements of a specific type.    p {  font-size: 16px;}        Class Selector (.): Selects all elements with a specific class.    .my-class {  background-color: yellow;}        ID Selector (#): Selects a specific element with an ID.    #my-id {  border: 1px solid black;}        Attribute Selector: Selects elements with a specific attribute.    a[href] {  color: blue;}        Pseudo-classes (:): Selects elements based on their state.    a:hover {  text-decoration: underline;}        Pseudo-elements (::): Selects parts of an element.    p::first-letter {  font-size: 2em;}      7. What is CSS selector specificity and how does it work?CSS specificity determines which CSS rule is applied when multiple rules target the same element. The more specific the selector, the higher its priority.Specificity Hierarchy:  Inline styles: style=\"color: red;\" (highest specificity).  IDs: #id-name.  Classes, attributes, pseudo-classes: .class-name, [type=\"text\"], :hover.  Elements and pseudo-elements: div, p, ::before (lowest specificity).Example:#header { color: blue; }        /* Specificity: 1 (ID selector) */.container { color: green; }    /* Specificity: 10 (Class selector) */div { color: red; }             /* Specificity: 100 (Element selector) */In case of conflicting styles, the rule with higher specificity is applied.8. What is the CSS Box Model?The CSS Box Model describes the rectangular boxes generated for elements in the document. It consists of:  Content: The actual content of the box (text, images).  Padding: Space between the content and the border.  Border: Surrounds the padding (optional).  Margin: Space outside the border, separating the element from others.Diagram:| Margin | Border | Padding | Content |Total Width and Height:  Total Width = Content Width + Left Padding + Right Padding + Left Border + Right Border + Left Margin + Right Margin.  Total Height = Content Height + Top Padding + Bottom Padding + Top Border + Bottom Border + Top Margin + Bottom Margin.9. What is the difference between absolute and relative length units in CSS? Provide examples.  Absolute Length Units: Fixed units that are not affected by other factors (e.g., screen size, parent elements).Examples: px, cm, mm, in, pt, pc.    width: 200px;height: 5in;        Relative Length Units: Units that are relative to other factors, such as the parent element or viewport size.Examples: %, em, rem, vw, vh, ch.    width: 50%;font-size: 2em;height: 100vh;      Relative units like em and rem scale dynamically, making them useful for responsive design, while absolute units like px are fixed.10. What is CSS Flexbox?CSS Flexbox (Flexible Box Layout) is a layout model that allows you to design complex layouts using a one-dimensional space (either horizontally or vertically). It enables more efficient alignment, distribution of space, and resizing of elements within a container.Key Features:  Flex container: The parent element where the flex properties are applied.  Flex items: The child elements within the flex container.  Flex direction: Defines the direction of the flex container (row or column).  Justify-content: Aligns items along the main axis (horizontal or vertical).  Align-items: Aligns items along the cross axis (perpendicular to the main axis).  Align-self: Allows individual items to be aligned differently than the others.  **Flex-grow, flex-shrink, and flex-basis**: Control how the items grow, shrink, or maintain their size.Flexbox is ideal for creating layouts that need to adjust dynamically to different screen sizes and content sizes.11. What is responsive web design?Responsive Web Design is an approach to web design that makes web pages render well on a variety of devices and screen sizes, from small mobile screens to large desktop monitors.Key Principles:  Fluid grids: Use relative units like percentages instead of fixed pixel values for layout elements.  Media queries: Apply different styles based on the screen size, resolution, or orientation of the device.  Flexible images: Images and other media resize to fit different screen sizes using CSS techniques like max-width: 100%.This approach ensures a consistent and optimized experience across devices.12. What are the differences between CSS Grids and Flexbox?Both CSS Grid and CSS Flexbox are powerful layout systems, but they serve different purposes:CSS Grid:  Designed for two-dimensional layouts (both rows and columns).  Suitable for complex layouts with multiple rows and columns.  Provides precise control over positioning and sizing.  Example:    .grid-container {  display: grid;  grid-template-columns: repeat(3, 1fr);  grid-gap: 10px;}      CSS Flexbox:  Designed for one-dimensional layouts (rows or columns).  Great for aligning items along a single axis.  More straightforward for simpler layouts.  Example:    .flex-container {  display: flex;  justify-content: space-between;}      When to Use:  Flexbox: Ideal for linear layouts (e.g., navigation bars or form layouts).  Grid: Best for complex layouts with control over both rows and columns.13. What is Bootstrap?Bootstrap is a popular front-end framework for building responsive, mobile-first web applications quickly. It provides:  Grid system: A 12-column responsive grid system.  Pre-styled components: Includes buttons, forms, navigation bars, modals, and more.  Customizable themes: Allows customization using Sass variables.  JavaScript components: Includes interactive elements like carousels, tooltips, and modals.Bootstrap helps streamline development and ensures consistent styling across browsers.14. What are the different CSS position property values?The position property in CSS specifies how an element is positioned within its container. Key values include:  static: Default position, follows normal document flow.    position: static;        relative: Positioned relative to its normal position.    position: relative;top: 10px;        absolute: Positioned relative to the nearest positioned ancestor (non-static).    position: absolute;top: 20px;left: 10px;        fixed: Positioned relative to the viewport; stays in place when scrolling.    position: fixed;top: 0;left: 0;        sticky: Treated as relative until a certain scroll threshold, then becomes fixed.    position: sticky;top: 0;      15. What is z-index in CSS?The z-index property in CSS controls the stacking order of elements on the z-axis (perpendicular to the screen).Key Points:  Higher z-index values appear in front of lower values.  Only elements with a position other than static can have a z-index applied.Example:div {  position: absolute;  z-index: 10;}div.overlay {  position: absolute;  z-index: 20; /* The overlay will appear on top of the first div */}"
    },
  
    {
      "title": "High Level Design Guide",
      "url": "/documentation/hld",
      "date": "2025-02-20",
      "content": "Table of Contents  Basic          System Architecture      Functional Specifications      Data Flow and Control Flow      Technology Choices      Integration Points      System Deployment      Scalability and Performance      Security Considerations        Advanced          Advanced Architectural Patterns      Detailed Scalability Strategies      Performance Optimization      Distributed System Design      Resilience and Fault Tolerance      Advanced Security Design      Data Management      Compliance and Standards      Monitoring and Observability      Tooling and Automation      "
    },
  
    {
      "title": "Low Level Design Guide",
      "url": "/documentation/lld",
      "date": "2025-02-19",
      "content": "Table of Contents  Basic          Object-Oriented Programming (OOP) Fundamentals      Class Design and Relationships      Design Patterns (Foundational)      Basic UML Diagrams      Error Handling and Exception Design      Coding Principles      Code Modularity      Data Structures      Testing Fundamentals        Advanced          Advanced Design Patterns      SOLID Principles      Clean Code Practices      Advanced UML Diagrams      Concurrency and Parallelism      Microservices and API Design      Data-Intensive Design      Advanced Testing9.Performance Considerations      Event-Driven Architecture      Domain-Driven Design (DDD)      Security and Resilience in Design        Interview QuestionsBasicLow-level design (LLD) is the process of detailing the components and modules of a system, creating a blueprint that focuses on the implementation aspects. It is concerned with specifying the internal structure and interactions of individual modules and their components.Object-Oriented Programming (OOP) FundamentalsOOP is a programming paradigm based on the concept of “objects”, which bundle data (attributes) and methods (functions) together. OOP enables better organization, reusability, and scalability in programming.      Classes and Objects:          Class: A blueprint for creating objects, defining their attributes and behaviors.      Object: An instance of a class containing real values instead of variables.            Inheritance:          A mechanism where a new class (subclass) inherits properties and methods from an existing class (superclass). It promotes code reuse.      Example: A Dog class can inherit from a Animal class.            Encapsulation:          Encapsulation refers to the bundling of data and the methods that operate on the data into a single unit (class). It also restricts direct access to some of the object’s components (through access modifiers like private, protected).      This is done using getters and setters to access private fields.            Polymorphism:          Polymorphism means “many shapes” and refers to the ability of different classes to provide different implementations of the same method.      It can be achieved through method overriding (runtime polymorphism) and method overloading (compile-time polymorphism).            Abstraction:          Abstraction hides the complexity by exposing only essential features of an object. It can be achieved through abstract classes or interfaces, allowing the user to focus on high-level operations.      Class Design and RelationshipsClass design involves creating the structure and behavior of classes, ensuring that classes are well-organized and efficient.      Cohesion:          Cohesion refers to how closely related and focused the responsibilities of a class or module are. High cohesion means the class has a clear, single responsibility, leading to better maintainability and readability.            Coupling:          Coupling refers to the degree of dependence between classes. Low coupling means fewer dependencies between classes, which makes the system more flexible and easier to change.      Ideally, classes should be loosely coupled.            Relationships:          Aggregation: A “has-a” relationship, where one object contains another, but the contained object can exist independently of the container.      Composition: A stronger form of aggregation where the contained object cannot exist without the container. It’s a “part-of” relationship.      Association: A relationship where objects can interact with each other, typically by using each other’s methods.      Dependency: A weaker relationship, where one object relies on another for certain functionality.      Design Patterns (Foundational)Design patterns are standard solutions to common design problems.      Singleton:          Ensures a class has only one instance and provides a global point of access to it. Often used for resources like database connections or configuration settings.            Factory Method:          Defines an interface for creating objects, but allows subclasses to alter the type of objects that will be created. It decouples object creation from its usage.            Strategy:          Defines a family of algorithms, encapsulates each one, and makes them interchangeable. This allows the algorithm to be selected at runtime.            Observer:          Defines a dependency between objects so that when one object changes state, all its dependent objects are notified and updated automatically.            Adapter:          Allows incompatible interfaces to work together. The adapter pattern acts as a bridge between two incompatible interfaces.      Basic UML DiagramsUnified Modeling Language (UML) is a standardized way to visualize the design of a system.      Class Diagrams:          Represent the static structure of a system, showing the system’s classes, their attributes, methods, and relationships.            Sequence Diagrams:          Illustrate how objects interact in a particular sequence of events. They focus on the order of messages exchanged between objects.            Component Diagrams:          Show the components or modules of a system and their interactions. They provide a high-level view of system architecture.      Error Handling and Exception DesignDesigning robust systems requires handling errors gracefully.      Exception Hierarchies:          Organizing exceptions into a hierarchy allows for better management and classification of errors. For example, IOException could be a subclass of Exception.            Graceful Error Handling Mechanisms:          Ensures that an application does not crash due to errors and can recover or provide useful feedback to users. Using try-catch blocks and handling exceptions at appropriate levels in the system is crucial.      Coding PrinciplesThese principles help maintain clean, readable, and maintainable code.      DRY (Don’t Repeat Yourself):          Avoid duplication by ensuring that every piece of knowledge or logic has a single, unambiguous representation.            KISS (Keep It Simple, Stupid):          Focus on simplicity. The simpler a solution is, the easier it is to maintain and extend.            YAGNI (You Aren’t Gonna Need It):          Avoid adding functionality until it’s necessary. This principle helps prevent overengineering and unnecessary complexity.      Code ModularityDesigning software with modular components improves reusability, testability, and maintainability.  Designing Modules or Components for Reusability and Testability:          Each module should have a single responsibility, be easily reusable across the system, and be easy to test in isolation (using unit tests).      Data StructuresData structures are used to store and organize data efficiently.      Array:          A collection of elements, identified by index or key. Fixed in size.            Linked List:          A linear data structure where elements (nodes) are linked using pointers. It can grow dynamically.            Stack:          A collection where elements are added and removed in a Last In First Out (LIFO) order.            Queue:          A collection where elements are added and removed in a First In First Out (FIFO) order.            Hash Table:          A data structure that stores key-value pairs. It allows for efficient lookups, insertions, and deletions based on keys.            Basic Tree Structures (Binary Tree, Binary Search Tree):          Binary Tree: A tree data structure where each node has at most two children.      Binary Search Tree: A binary tree where nodes are arranged such that for each node, its left child is smaller and its right child is larger.      Testing FundamentalsTesting is crucial to ensure the correctness and reliability of the system.      Unit Testing:          Involves testing individual units or components of the software in isolation to ensure that each part functions as expected.            Mocking and Stubbing:          Mocking: Creating fake objects that simulate the behavior of real objects for testing purposes.      Stubbing: Providing predefined responses to function calls during testing.            Integration Testing Basics:          Focuses on testing the interactions between different components or systems to ensure that they work together as expected.      AdvancedLow-level design refers to the detailed design of individual components, functions, and modules within a system. Advanced topics delve into the strategies for creating more efficient and maintainable designs.Advanced Design PatternsDesign patterns are standard solutions to common problems in software design. Here’s an overview of the ones you listed:      Builder Pattern          Separates the construction of a complex object from its representation, allowing for different representations to be created using the same construction process.      Useful for constructing objects with many parameters or optional configurations.            Prototype Pattern          Used to create new objects by copying an existing object, often known as the prototype.      Helps in creating objects with complex states without knowing their exact class.            Mediator Pattern          Defines an object that controls how a set of objects interact, preventing direct communication between them.      Used to reduce dependencies between objects and to centralize communication logic.            Chain of Responsibility Pattern          Allows a chain of objects to handle a request, passing it along the chain until one object processes it.      Useful for situations where multiple handlers might need to process a request, like in event processing.            Command Pattern          Encapsulates a request as an object, allowing for parameterization of clients with queues, requests, and operations.      Often used in undo/redo systems or event handling.            Visitor Pattern          Lets you add further operations to objects without having to modify the objects themselves.      Used to separate an algorithm from the objects it operates on, ideal for operations on complex object structures.            Decorator Pattern          Attaches additional responsibilities to an object dynamically.      Provides a flexible alternative to subclassing for extending functionality.      SOLID PrinciplesSOLID is a set of principles that guide software design to make systems more understandable, flexible, and maintainable:      Single Responsibility Principle (SRP)          A class should have only one reason to change, meaning it should have one job or responsibility.            Open/Closed Principle (OCP)          Software entities (classes, modules, functions) should be open for extension but closed for modification.      New functionality should be added through extension, not by modifying existing code.            Liskov Substitution Principle (LSP)          Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.      Subtypes must behave in a way that doesn’t alter the expected behavior of the base class.            Interface Segregation Principle (ISP)          A client should not be forced to implement interfaces it doesn’t use.      Split larger interfaces into smaller ones so that clients only implement what they need.            Dependency Inversion Principle (DIP)          High-level modules should not depend on low-level modules. Both should depend on abstractions.      Abstractions should not depend on details; details should depend on abstractions.      Clean Code PracticesClean code is code that is easy to read, maintain, and understand. Some important practices are:  Writing maintainable, readable, and scalable code: Code should be easy to understand and adapt to changing requirements. It’s about clarity over cleverness.  Refactoring legacy code: Continuously improving and simplifying existing code, without changing its behavior, to keep it maintainable.  Effective naming conventions: Descriptive, clear, and consistent names for variables, functions, and classes that convey their purpose.Advanced UML DiagramsUML (Unified Modeling Language) diagrams help visualize system design and architecture. Advanced UML diagrams include:      State Diagrams          Illustrate the states an object can be in and the transitions between these states.      Useful in modeling finite state machines or complex lifecycle processes.            Activity Diagrams          Represent workflows of activities and actions, often used to show the flow of control or data in a process.      Useful for modeling business processes or algorithms.            Deployment Diagrams          Show the physical deployment of artifacts (like code and database) on hardware nodes.      Helpful in understanding the distribution of software in a system.      Concurrency and ParallelismConcurrency involves managing multiple tasks at once, while parallelism is executing tasks simultaneously. Key topics include:  Thread safety and synchronization: Ensures that shared data is protected from race conditions and inconsistent states when accessed by multiple threads.  Deadlock detection and prevention: Identifying and avoiding situations where threads are stuck waiting on each other.  Asynchronous programming: Writing programs that can perform tasks in the background without blocking the main thread.  Design patterns for concurrency: Patterns like Producer-Consumer and Thread Pool manage concurrency by structuring how tasks are processed.Microservices and API DesignMicroservices involve designing applications as a collection of loosely coupled services. Key considerations are:  API versioning and design best practices: Ensuring backward compatibility while evolving APIs.  Contract-first design: Designing the API contract (e.g., Swagger/OpenAPI) before implementing the API.  API security: Authenticating and authorizing users or services using techniques like OAuth.  Fault tolerance patterns:          Circuit Breaker: Prevents system overload by detecting failures.      Retry: Retries a failed operation a set number of times.      Bulkhead: Isolates failure to prevent it from affecting the whole system.      Data-Intensive DesignDesigning systems that deal with large volumes of data. Key considerations are:  Advanced data structures: Structures like AVL trees, Red-Black Trees, Tries, and Graphs help in optimizing data retrieval and storage.  Caching mechanisms: Techniques like LRU cache reduce repeated access to slow resources like databases.  Memory optimization techniques: Efficient use of memory through data structure design, object pooling, and garbage collection optimization.Advanced TestingAdvanced testing techniques ensure high-quality and reliable software:  Test-driven development (TDD): Writing tests before code to guide development and ensure correctness.  Behavior-driven development (BDD): Extending TDD by writing tests in a more natural language format, describing behaviors.  Integration and end-to-end testing: Testing the interaction of multiple components and the entire system from the user’s perspective.Performance ConsiderationsPerformance is critical for high-traffic systems:  Big-O complexity analysis: Understanding the time and space complexity of algorithms to choose efficient solutions.  Profiling and optimization: Identifying and removing performance bottlenecks in your code.  Database query optimization: Writing efficient SQL queries and designing efficient database schemas.Event-Driven ArchitectureEvent-driven architecture (EDA) revolves around systems reacting to events or changes in state:  Event sourcing: Storing all changes to application state as a sequence of events.  CQRS: Separates the command (write) and query (read) sides of a system, allowing for more scalable solutions.  Messaging systems: Technologies like RabbitMQ or Kafka facilitate the decoupling of system components by enabling asynchronous communication.Domain-Driven Design (DDD)DDD focuses on modeling systems based on the domain they are solving problems for:  Entities, Value Objects, Aggregates: Core building blocks of DDD, where entities have identities, value objects have no identity, and aggregates are collections of related entities.  Repositories: Abstraction for accessing and persisting aggregates.  Bounded Contexts: Defining clear boundaries around a specific part of the domain, ensuring teams work with a consistent model.  Ubiquitous language: A common language shared by both developers and business experts to describe the system and its domain.Security and Resilience in DesignSecurity and resilience are key to creating robust systems:  Secure coding practices: Writing code to protect against vulnerabilities such as SQL injection, XSS, etc.  Threat modeling and mitigation: Identifying potential threats and designing the system to mitigate those risks.  Resilient system design: Patterns like fallbacks, circuit breakers, and retry mechanisms to ensure a system continues to function even when some components fail.Interview QuestionsBasic-Level Design QuestionsThese questions are intended to test a candidate’s understanding of basic design principles, object-oriented design, and familiarity with common patterns and algorithms.      Design a parking lot system:          Design classes for parking spots, vehicles, and the parking lot.      What types of vehicles should your system support?      How would you handle parking spot availability?            Design a library management system:          Create a system for borrowing and returning books.      How will you manage book inventory?      How would you handle overdue books?            Design a basic ATM system:          Design classes for account management, transactions, and receipts.      How would you implement security (PIN, transaction limits)?      How would you handle different account types (checking, savings)?            Design a simple file system:          What classes would be involved in a file system?      How would you manage files and directories?      How would you handle file permissions?            Design a simple email system:          What classes would you need for email management?      How would you structure the system to send, receive, and delete emails?      How would you implement spam filters?            Design a simple messaging app (chat system):          Design classes for sending, receiving, and storing messages.      How would you implement message encryption?      How would you handle user authentication and message delivery?      Intermediate-Level Design QuestionsThese questions often involve more complex systems and integration of multiple components or subsystems. Candidates should also consider scalability, reliability, and performance.      Design an online bookstore system:          How would you handle inventory management, order processing, and payment systems?      What database schemas would you consider for book information, users, and orders?      How would you handle discounts, promotions, and recommendations?            Design a URL shortening service (like bit.ly):          How would you generate unique shortened URLs?      How would you store mappings between original and shortened URLs?      How would you ensure the system is scalable to handle billions of URLs?            Design a movie ticket booking system:          How would you design the system to manage theaters, showtimes, and reservations?      How would you handle overbookings and seat availability?      How would you manage user preferences, payments, and cancellations?            Design a notification system (e.g., push notifications, emails):          How would you handle different types of notifications (emails, SMS, in-app)?      How would you ensure the system can handle millions of notifications per day?      How would you prioritize or throttle notifications?            Design a social media platform (e.g., Twitter):          How would you design the architecture to support following, posting, and likes?      How would you scale the system to handle millions of users and posts?      How would you design a feed system with personalized recommendations?            Design an e-commerce shopping cart system:          How would you design cart items, user sessions, and payment processing?      How would you implement pricing calculations, discounts, and tax calculations?      How would you manage cart persistence (e.g., between sessions)?      Advanced-Level Design QuestionsThese questions are for senior positions and require candidates to design highly scalable, fault-tolerant, and performant systems with a strong focus on trade-offs, edge cases, and real-world constraints.      Design a distributed cache (e.g., Redis or Memcached):          How would you design a distributed caching system to store key-value pairs?      How would you ensure consistency and handle cache invalidation?      How would you implement replication and sharding in the cache?            Design a real-time collaborative document editing system (e.g., Google Docs):          How would you handle concurrent edits from multiple users in real time?      How would you design a conflict resolution mechanism?      How would you implement offline support and eventual consistency?            Design a large-scale file storage system (e.g., Dropbox, Google Drive):          How would you handle file uploads, downloads, and synchronization across devices?      How would you ensure fault tolerance and data redundancy?      How would you design a system to manage access control, versioning, and sharing?            Design a recommendation system (e.g., for an e-commerce platform or a movie app):          How would you build a recommendation engine based on user preferences and behaviors?      What algorithms would you use (collaborative filtering, content-based filtering)?      How would you handle cold starts, scalability, and personalization?            Design a real-time stock trading platform:          How would you design a system that supports buying and selling of stocks in real time?      How would you handle trading volumes, low latency, and transaction consistency?      How would you ensure market data updates and provide order matching?            Design a large-scale event logging and monitoring system:          How would you design a system to handle billions of events and logs per day?      How would you ensure the system is fault-tolerant and scalable?      How would you handle querying, indexing, and storing log data for quick access?      General Design and Best Practices      Explain the SOLID principles:          How do each of the SOLID principles help improve the design and maintainability of a system?            Discuss the trade-offs between different types of databases (SQL vs. NoSQL):          How would you decide whether to use a relational database or a NoSQL database in your system?            How do you ensure the scalability and reliability of your system?          What strategies would you use to scale a system horizontally or vertically?      How do you handle failover and fault tolerance?            Design a multi-tiered application:          How would you separate the concerns of your application into multiple layers (e.g., presentation, business logic, data access)?      What kind of communication would occur between the layers, and how would you ensure loose coupling?            Explain how you would perform load testing and capacity planning for your system.  Behavioral Design QuestionsThese assess the candidate’s thought process and approach to designing systems, especially when under constraints.  What steps would you take if you were asked to design a system that must be highly available and fault-tolerant?  How do you ensure that your system design is flexible and can accommodate future changes?  How would you approach debugging and optimizing a low-level design?  Can you describe a situation where you had to make a difficult design trade-off? What was your reasoning?Tips for Preparing  Practice UML diagrams (Class, Sequence, Use Case, etc.) to represent your design.  Focus on designing systems that are modular, scalable, and maintainable.  Be ready to discuss performance, complexity, and edge cases during the design.  Communicate clearly and break down the design problem step by step.Basic-Level LLD Questions      Design a ticket reservation system:          What classes and data structures would you need?      How would you handle seat availability, cancellations, and booking limits?      What would happen if a user tries to book the same seat simultaneously?            Design a basic cash register system:          How would you implement classes for cash registers, transactions, and receipts?      How would you handle discount and tax calculations?      How would you implement inventory management for products?            Design an online voting system:          How would you store and validate votes?      How would you ensure that multiple users cannot vote more than once?      How would you handle the results calculation and the integrity of voting data?            Design a system for managing a conference schedule:          How would you design a system to handle sessions, speakers, and attendees?      How would you manage session timings and conflicts?      How would you allow attendees to register and track their sessions?            Design a simple calendar application:          How would you handle recurring events and reminders?      How would you design the system to allow multiple users to add events?      How would you manage different time zones for events?      Intermediate-Level LLD Questions      Design a payment gateway system:          How would you handle multiple types of payment methods (credit card, PayPal, etc.)?      How would you implement fraud detection and security?      How would you design the system to handle successful, pending, or failed transactions?            Design a ride-sharing application (like Uber or Lyft):          How would you handle the matching of drivers with riders?      How would you design the system to track real-time location updates?      How would you handle surge pricing based on demand?            Design an inventory management system:          How would you manage stock levels, suppliers, and product catalog?      How would you design it to handle inventory across multiple warehouses?      How would you handle product return and exchange?            Design a logging and monitoring system (e.g., for server logs):          How would you store logs for querying and reporting?      How would you handle log levels (e.g., info, warn, error)?      How would you ensure logs are processed and stored at scale in real-time?            Design a file compression tool (like ZIP or TAR):          How would you design the algorithm to compress and decompress files?      How would you handle large file sizes and compression ratios?      How would you optimize the performance of compression and decompression?            Design a URL shortener service (e.g., bit.ly):          How would you generate a unique short URL for a long URL?      How would you store the mapping of short URLs to long URLs?      How would you ensure scalability as the service grows?      Advanced-Level LLD Questions      Design a distributed message queue system (like Kafka or RabbitMQ):          How would you design the architecture for high throughput and low latency?      How would you handle message persistence, ordering, and delivery guarantees?      How would you handle message acknowledgment, retries, and failure handling?            Design a multi-user online game system (like Chess, Checkers, etc.):          How would you manage users, game states, and moves?      How would you handle real-time communication between players (web sockets, polling)?      How would you design for scaling with millions of simultaneous players?            Design a global search engine (like Google):          How would you handle crawling and indexing the web?      How would you design the ranking algorithm (PageRank, etc.)?      How would you scale the search engine to handle billions of queries per day?            Design a distributed file system (like HDFS or GFS):          How would you handle file storage, redundancy, and replication across multiple nodes?      How would you design the system to ensure fault tolerance in case of server failures?      How would you manage file access, permissions, and metadata?            Design a social networking platform (like Facebook or Instagram):          How would you design a user feed, including posts, likes, and comments?      How would you handle friend relationships and privacy settings?      How would you manage scalability as the user base grows?            Design a real-time chat application (like Slack or WhatsApp):          How would you manage user connections, message delivery, and presence status?      How would you design it to scale with millions of users and messages?      How would you implement message encryption and privacy?            Design a distributed caching system (e.g., for large-scale web applications):          How would you ensure that the cache can scale horizontally and handle high loads?      How would you manage cache eviction policies (LRU, LFU)?      How would you design a system to ensure consistency between the cache and the underlying database?      Edge Cases and Performance-Oriented LLD Questions      Design a rate-limiting system (e.g., for API calls or user actions):          How would you design the system to limit requests per user or IP address?      What algorithms would you use (Token Bucket, Leaky Bucket)?      How would you handle burst traffic and ensure fair rate-limiting?            Design a system to detect duplicate images (e.g., in an image hosting platform):          How would you compare images to detect similarity?      What hashing or fingerprinting algorithms would you use (e.g., perceptual hash)?      How would you scale this for millions of images?            Design a system for calculating distance between locations (like Google Maps):          How would you calculate the shortest path between two locations?      How would you handle real-time traffic data in the system?      How would you manage scalability if the system needs to serve millions of requests?            Design a logging and alerting system that can handle millions of events per second:          How would you ensure real-time ingestion and storage of log data?      How would you process logs for alert generation and anomaly detection?      How would you design the system to scale and handle both high throughput and low latency?      Behavioral and Problem-Solving LLD Questions      Design a system that must be both highly available and partition-tolerant (using CAP Theorem):          How would you make trade-offs between consistency, availability, and partition tolerance?      How would you design for eventual consistency in this system?            How would you design a system with the following constraints:          High throughput and low latency.      Fault tolerance and high availability.      Real-time data processing.      How would you balance these requirements in your design?            Design a system where multiple components need to collaborate, but you cannot modify all the components:          How would you implement communication between these components?      How would you ensure that each component can evolve independently?            How would you design a system that needs to ensure data consistency across multiple data stores (e.g., SQL and NoSQL)?          What patterns would you apply (e.g., event sourcing, CQRS)?      How would you handle conflicts and ensure the system remains consistent?      System Design Trade-offs and Optimizations      How would you optimize the performance of a system under heavy load (e.g., millions of requests per second)?          How would you handle bottlenecks in databases, CPU, memory, or network?      How would you scale the system horizontally and vertically?            Explain how you would handle data migrations when updating a system:          How would you ensure minimal downtime?      How would you design the system to be backward compatible during the migration?            Design a system that requires high fault tolerance but also needs to perform background tasks at regular intervals (e.g., scheduled jobs):          How would you ensure that tasks complete even if part of the system fails?      How would you schedule tasks without blocking critical system processes?      Advanced Algorithms and Data Structures Questions      Design an autocomplete feature using a trie data structure:          How would you implement the search and insert operations efficiently?      How would you scale the autocomplete service to handle large dictionaries?            Design a distributed rate limiter for a global API:          How would you ensure fair distribution of requests and prevent abuse?      How would you handle distributed state in the rate limiter?      "
    },
  
    {
      "title": "React Concepts Guide",
      "url": "/documentation/react",
      "date": "2025-01-22",
      "content": "Table of Concepts  Basic React          Core Concepts      Rendering      Handling Events      Forms      Styling      State Management (Basic)      Routing      Error Handling      Working with APIs      Performance Optimization (Introductory)        Advanced React          Hooks (Advanced)      State Management (Advanced)      Code Splitting and Lazy Loading      Server-Side Rendering (SSR)      Testing      Performance Optimization (Advanced)      TypeScript with React      Animations      Patterns and Architecture      GraphQL Integration      WebSockets and Real-Time Updates      Custom Rendering      Advanced Routing      Accessibility      Internationalization (i18n)      Certainly! Here’s an explanation of the key React topics you mentioned. React is a JavaScript library for building user interfaces, particularly for single-page applications. Below, I’ll break down the basics of each topic:Core ConceptsJSX (JavaScript XML)  JSX is a syntax extension for JavaScript that looks similar to HTML.  It allows you to write HTML elements and components directly in your JavaScript code.  Example:    const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;        JSX gets transpiled into standard JavaScript using tools like Babel.Components (Functional and Class)  Functional Components: These are simple JavaScript functions that return JSX.    const Greeting = () =&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt;;        Class Components: ES6 classes that extend React.Component and include a render method.    class Greeting extends React.Component {  render() {    return &lt;h1&gt;Hello, World!&lt;/h1&gt;;  }}      Props and State  Props: Short for “properties,” they are inputs passed to components.    const Welcome = (props) =&gt; &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;        State: A component’s internal data that changes over time, used with useState (functional components) or this.state (class components).Component Lifecycle (Class Components)Lifecycle methods manage what happens at different stages of a component’s life:  componentDidMount(): Runs after the component is mounted.  componentDidUpdate(): Runs after the component updates.  componentWillUnmount(): Runs before the component is removed.RenderingConditional Rendering  Rendering elements based on conditions.    const isLoggedIn = true;return isLoggedIn ? &lt;h1&gt;Welcome back!&lt;/h1&gt; : &lt;h1&gt;Please sign in.&lt;/h1&gt;;      Lists and Keys  Rendering a list of items with the map method.  Keys help React identify which items have changed.    const items = ['Item 1', 'Item 2'];return items.map((item, index) =&gt; &lt;li key={index}&gt;{item}&lt;/li&gt;);      Handling EventsEvent Handling  React uses camelCase for event names (e.g., onClick).    const handleClick = () =&gt; alert('Clicked!');&lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;;      Synthetic Events  A cross-browser wrapper around the browser’s native event.FormsControlled vs. Uncontrolled Components  Controlled: Component controls form input values using state.    const [value, setValue] = useState('');return &lt;input value={value} onChange={(e) =&gt; setValue(e.target.value)} /&gt;;        Uncontrolled: Use ref to access DOM elements directly.Form Handling and Validation  Handle form submissions and validate input values programmatically.    const handleSubmit = (e) =&gt; {  e.preventDefault();  if (value.trim() === '') alert('Value required');};      StylingInline Styles  Define styles directly in JSX.    const style = { color: 'blue', fontSize: '20px' };return &lt;h1 style={style}&gt;Styled Text&lt;/h1&gt;;      CSS Modules  Locally scoped CSS classes by importing CSS files as modules.    /* styles.module.css */.header { color: red; }        import styles from './styles.module.css';&lt;h1 className={styles.header}&gt;Hello&lt;/h1&gt;;      Styled-Components (Optional)  CSS-in-JS library to style components.    import styled from 'styled-components';const StyledButton = styled.button`background: blue; color: white;`;      State Management (Basic)Using the useState Hook  Manages state in functional components.    const [count, setCount] = useState(0);      Context API (Introduction)  Provides a way to pass data through the component tree without props.    const ThemeContext = React.createContext('light');      RoutingReact Router Basics (v6+)  Define routes for navigation.    import { BrowserRouter, Routes, Route } from 'react-router-dom';&lt;BrowserRouter&gt;  &lt;Routes&gt;    &lt;Route path=\"/\" element={&lt;Home /&gt;} /&gt;  &lt;/Routes&gt;&lt;/BrowserRouter&gt;;      Navigation and Link Components  Use Link to navigate between routes without refreshing.    &lt;Link to=\"/about\"&gt;About&lt;/Link&gt;;      Error HandlingError Boundaries (Class Components)  Catch errors in a component tree using componentDidCatch and getDerivedStateFromError.    class ErrorBoundary extends React.Component {  componentDidCatch(error, info) { console.error(error); }  render() { return this.props.children; }}      Working with APIsFetching Data (Using Fetch or Axios)  Use fetch or axios to get data.    useEffect(() =&gt; {  fetch('https://api.example.com/data')    .then((res) =&gt; res.json())    .then((data) =&gt; setData(data));}, []);      Handling Promises and Async/Await  Prefer async/await for cleaner asynchronous code.    const fetchData = async () =&gt; {  const response = await fetch('https://api.example.com/data');  const data = await response.json();  setData(data);};      Performance Optimization (Introductory)React.memo  Prevents unnecessary re-renders by memoizing components.    const MemoizedComponent = React.memo(MyComponent);      useCallback and useMemo (Basic Use Cases)  useCallback: Memoizes functions.    const memoizedCallback = useCallback(() =&gt; { doSomething(); }, [dependencies]);        useMemo: Memoizes values.    const computedValue = useMemo(() =&gt; computeExpensiveValue(), [dependencies]);      This overview provides a foundation for React. Let me know if you’d like a deeper dive into any specific topic!"
    },
  
    {
      "title": "Crio Interview Questions",
      "url": "/documentation/crio-interview-questions",
      "date": "2025-01-22",
      "content": "Table of Contents  FE-101 - HTML  FE-102 - Javascript  FE-103 - Javascript  FE-201 - React  FE-202 - React  FE-301 - Redux  FE-302 -  Tailwind, Webpack, CDN, Nextjs  MERN-2 - Nodejs  FE-INTV-1 - Takehome assessments  NODE-201 - Nodejs  NODE-202 - SQL  HLD-1 - HLD"
    },
  
    {
      "title": "Interview Questions",
      "url": "/documentation/interview-questions",
      "date": "2025-01-22",
      "content": "Table of Contents  Crio Interview Questions  HTML  Javascript  React  Redux  Tailwind, Webpack, CDN, Nextjs  Nodejs  SQL  HLD"
    },
  
    {
      "title": "More about Type Manipulation",
      "url": "/documentation/type-manipulation",
      "date": "2025-01-19",
      "content": "Type Manipulation in TypeScriptType manipulation in TypeScript refers to the ability to transform or infer types based on certain conditions, allowing you to create more flexible and reusable code. TypeScript provides powerful tools for manipulating types, such as infer, conditional types, and utility types, among others. Here’s an overview of these key concepts:1. Conditional TypesConditional types allow you to select one type over another based on a condition. This is similar to a ternary operator (condition ? true : false) but for types.Basic Syntax:type ConditionalType&lt;T&gt; = T extends SomeCondition ? TrueType : FalseType;In this example, T is checked against SomeCondition. If it matches, the result is TrueType; otherwise, it will be FalseType.2. infer Keyword for Type InferenceThe infer keyword allows you to extract a type from a more complex type within conditional types. It’s especially useful for situations where you want to infer the type of a function’s return value, arguments, or other components without having to explicitly define it.Example of infer with ReturnType:type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never;Here, ReturnType&lt;T&gt; is a conditional type that:  Checks if T is a function (denoted by (...args: any[]) =&gt;).  If T is a function, it infers the return type of that function and assigns it to R.  If T is not a function, it returns never (meaning an invalid type).Usage Example:type MyFunction = (x: number, y: number) =&gt; string;type Result = ReturnType&lt;MyFunction&gt;;  // Result will be `string`Here, the type Result will be string because the function MyFunction returns a string. The ReturnType utility extracts that return type.3. Common Use Cases for Type ManipulationExtracting Function ArgumentsYou can use the infer keyword to extract the types of function parameters as well.type ParameterType&lt;T&gt; = T extends (arg: infer U) =&gt; any ? U : never;type MyFunction = (x: number) =&gt; string;type Param = ParameterType&lt;MyFunction&gt;;  // Param will be `number`In this example, ParameterType extracts the type of the parameter passed to the function. If MyFunction takes a number, then Param will be number.Discriminated Unions with inferYou can use infer to narrow types in conditional types when dealing with discriminated unions.type Shape =   | { kind: 'circle', radius: number }  | { kind: 'square', sideLength: number };type GetShapeType&lt;T&gt; = T extends { kind: 'circle' } ? 'Circle' :                      T extends { kind: 'square' } ? 'Square' :                      never;type CircleType = GetShapeType&lt;{ kind: 'circle', radius: 10 }&gt;;  // 'Circle'type SquareType = GetShapeType&lt;{ kind: 'square', sideLength: 20 }&gt;;  // 'Square'Here, we use a conditional type to map over a discriminated union to extract the types based on the kind property.4. Using Utility Types for Type TransformationTypeScript also offers a range of utility types that make it easier to manipulate types in common scenarios. These types include Partial, Required, Readonly, Record, etc.Example: Pick, Omit, and Excludeinterface Person {  name: string;  age: number;  address: string;}// Pick specific keys from the interfacetype NameAndAge = Pick&lt;Person, 'name' | 'age'&gt;;  // { name: string; age: number }// Omit specific keys from the interfacetype WithoutAddress = Omit&lt;Person, 'address'&gt;;  // { name: string; age: number }// Exclude specific types from a uniontype WithoutString = Exclude&lt;string | number | boolean, string&gt;;  // number | boolean  Pick&lt;T, K&gt;: Picks a subset of properties from a type T.  Omit&lt;T, K&gt;: Omit specific properties from a type T.  Exclude&lt;T, U&gt;: Excludes types from a union type.These utility types are often used for type manipulation, allowing you to create new types based on existing ones.5. Key Takeaways of Type Manipulation            Concept      Explanation      Example                  Conditional Types      Types that select one type over another based on a condition.      type IsString&lt;T&gt; = T extends string ? true : false;              infer Keyword      Extracts a type within a conditional type, useful for inferring function return types or extracting types from more complex types.      type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never;              Function Arguments      Extracts the types of function arguments.      type Param&lt;T&gt; = T extends (arg: infer U) =&gt; any ? U : never;              Discriminated Unions      Conditional types combined with discriminated unions to narrow down types.      type ShapeType&lt;T&gt; = T extends { kind: 'circle' } ? 'Circle' : T extends { kind: 'square' } ? 'Square' : never;              Utility Types      Built-in utility types like Pick, Omit, Partial, Required, and Exclude allow transformation of types in useful ways.      type NameAndAge = Pick&lt;Person, 'name' | 'age'&gt;;      6. ConclusionType manipulation in TypeScript allows you to create flexible, reusable, and strongly typed code by leveraging the power of conditional types, infer, and utility types. These tools enable complex type transformations that are both expressive and maintainable, making TypeScript a robust language for building large and scalable applications."
    },
  
    {
      "title": "More about Type Aliases",
      "url": "/documentation/type-aliases",
      "date": "2025-01-19",
      "content": "1. Advanced Use Cases1. Recursive Types:Type aliases can define recursive types, which are useful for defining data structures like trees or JSON.Example:type JSONValue = string | number | boolean | null | JSONValue[] | { [key: string]: JSONValue };const data: JSONValue = {  name: \"Alice\",  age: 30,  preferences: {    theme: \"dark\",    notifications: true,  },  hobbies: [\"reading\", \"gaming\"],};Here, JSONValue is a recursive type alias that describes valid JSON values.2. Conditional Types:Type aliases can use conditional types for more advanced use cases.Example:type IsString&lt;T&gt; = T extends string ? true : false;type Test1 = IsString&lt;string&gt;;  // truetype Test2 = IsString&lt;number&gt;;  // falseHere, IsString is a conditional type that evaluates to true if the input type T is string, and false otherwise.2. Best Practices for Type Aliases  Use Descriptive Names: Make type alias names clear and meaningful to convey their purpose.    type ProductID = string;        Use for Non-Object Types: Prefer type aliases when working with primitives, unions, intersections, or complex types.    type Coordinate = [number, number];        Use Interfaces for Objects: When defining object shapes that might need to be extended or merged, prefer interfaces.    interface User {  name: string;  age: number;}        Avoid Overusing Aliases: Don’t alias everything—use them where they improve readability or reduce repetition."
    },
  
    {
      "title": "Tuples and how it differs from Arrays",
      "url": "/documentation/tuples",
      "date": "2025-01-19",
      "content": "Table of Contents  What is Tuple  Key Characteristics of Tuples  Optional and Rest Elements in Tuples  Tuples with Named Types or Objects  Destructuring Tuples  Readonly Tuples  Using Tuples with Functions  Differences Between Arrays and Tuples1. What is TupleA tuple is a special type of array in TypeScript where the number of elements and their types are fixed. Unlike regular arrays, where all elements must be of the same type, a tuple can contain elements of different types, and the number of elements is fixed when the tuple is created.Syntax for TuplesA tuple is defined using square brackets [], with types specified for each element. The order of the types in the tuple corresponds to the order of the elements in the tuple.Example:let tuple: [string, number] = [\"Alice\", 30];  The first element is a string, and the second element is a number.  The tuple can only contain exactly two elements, and the types must match exactly: the first element must always be a string, and the second must always be a number.2. Key Characteristics of Tuples  Fixed Size: The size of a tuple is fixed. You cannot add or remove elements without causing a type error.let tuple: [string, number] = [\"Alice\", 30];tuple.push(100); // Error: Tuple type '[string, number]' of length '2' has no element at index '2'.  Mixed Types: Each element in a tuple can be of a different type.let user: [string, number, boolean] = [\"Alice\", 30, true];Here, the tuple has three elements:  The first is a string.  The second is a number.      The third is a boolean.    Accessing Elements: You can access the elements of a tuple using their index, just like arrays.let user: [string, number] = [\"Alice\", 30];console.log(user[0]); // Output: \"Alice\"console.log(user[1]); // Output: 30TypeScript will enforce the correct types when you access the elements, ensuring that the type of the value at the specified index matches the type in the tuple’s definition.3. Optional and Rest Elements in TuplesTuples in TypeScript can also support optional elements (using ?) and rest elements (using ...), allowing for more flexibility when defining the tuple’s structure.Optional ElementsOptional elements in tuples can be used when an element is not always required. This is done by adding a ? after the element’s type.Example:let user: [string, number?, boolean?] = [\"Alice\"];console.log(user); // Output: [\"Alice\"]user = [\"Bob\", 25];console.log(user); // Output: [\"Bob\", 25]user = [\"Charlie\", 35, true];console.log(user); // Output: [\"Charlie\", 35, true]In this case:  The second element (number) and the third element (boolean) are optional.  The tuple can have 1, 2, or 3 elements.Rest ElementsRest elements allow you to define a tuple that can accept additional elements beyond the ones specified in the tuple’s definition. Rest elements are placed after the fixed elements and are prefixed with ....Example:let coordinates: [number, number, ...number[]] = [0, 0, 1, 2, 3];console.log(coordinates); // Output: [0, 0, 1, 2, 3]In this example:  The tuple starts with two number elements ([0, 0]).  Then it can accept any number of additional number values after the first two elements.4. Tuples with Named Types or ObjectsYou can also use named types or objects in a tuple. This allows you to combine the benefits of tuples and objects, making it possible to work with structured data in a more readable way.Example:let employee: [string, number, { role: string }] = [  \"Alice\",  30,  { role: \"Engineer\" },];In this example, the third element in the tuple is an object with a property role that is a string. This allows you to store more complex data in tuples while preserving type safety.5. Destructuring TuplesTypeScript allows destructuring of tuples just like arrays, making it easy to extract values from a tuple and assign them to variables.Example:let person: [string, number] = [\"John\", 25];let [name, age] = person;console.log(name); // Output: \"John\"console.log(age); // Output: 25Here, we use array destructuring syntax to extract the name and age from the person tuple.6. Readonly TuplesIf you want to prevent modification of a tuple’s elements after its creation, you can use the readonly modifier to create a readonly tuple. This ensures that once the tuple is created, its values cannot be changed.Example:let person: readonly [string, number] = [\"John\", 25];person[0] = \"Jane\"; // Error: Index signature in type 'readonly [string, number]' only permits reading.In this example, person is a readonly tuple, so trying to modify its elements will result in an error.7. Using Tuples with FunctionsYou can also use tuples as function return types or arguments. This is useful when a function returns multiple values of different types.Example:function getUserInfo(): [string, number] {  return [\"John\", 25];}let [name, age] = getUserInfo();console.log(name); // Output: \"John\"console.log(age); // Output: 258. Differences Between Arrays and TuplesWhile both arrays and tuples can store multiple values, they differ in the following key ways:  Arrays are homogeneous collections, meaning all elements are of the same type (e.g., an array of numbers, an array of strings).  Tuples are heterogeneous collections, meaning the elements can be of different types, and the types are fixed and predefined.Example of an Array:let numbers: number[] = [1, 2, 3, 4]; // All elements are of type 'number'Example of a Tuple:let user: [string, number, boolean] = [\"Alice\", 30, true]; // Different typesConclusion  Tuples are a special type of array that allows you to store values of different types in a fixed-length collection. Tuples are useful when you want to represent heterogeneous data in a fixed order.  Both arrays and tuples are essential for organizing collections of values, with arrays offering flexibility for homogeneous collections and tuples offering structure and type safety for heterogeneous collections.By using arrays and tuples effectively, you can write more robust, maintainable, and type-safe code in TypeScript."
    },
  
    {
      "title": "More about Namespaces in Typescript",
      "url": "/documentation/namespace",
      "date": "2025-01-19",
      "content": "Namespaces in TypeScriptNamespaces are a TypeScript feature used to organize and group related code together under a common name. They provide a logical structure to the code and avoid naming conflicts by creating an encapsulated scope. While modules (ES6 style) are preferred in modern TypeScript, namespaces are still used in some scenarios, particularly in legacy systems or for organizing large codebases.1. What Are Namespaces?A namespace is a construct that wraps code (e.g., interfaces, classes, functions, or variables) in a named scope. This allows the code to be accessed without polluting the global scope.Basic Syntaxnamespace MyNamespace {  export interface User {    name: string;    age: number;  }  export function greet(user: User): string {    return `Hello, ${user.name}!`;  }}// Using the namespaceconst user: MyNamespace.User = { name: \"Alice\", age: 25 };console.log(MyNamespace.greet(user)); // Hello, Alice!  Keyword namespace: Used to define a namespace.  export keyword: Makes members (interfaces, classes, functions, variables) available outside the namespace.2. Key Features of NamespacesEncapsulationNamespaces encapsulate related code into a single logical group, preventing naming conflicts in large projects.namespace Physics {  export const speedOfLight = 299792458; // meters per second  export const gravitationalConstant = 6.67430e-11;}namespace Chemistry {  export const speedOfLight = \"N/A\"; // Different interpretation}console.log(Physics.speedOfLight); // 299792458console.log(Chemistry.speedOfLight); // N/ANested NamespacesNamespaces can be nested within one another, creating a hierarchical structure.namespace Geometry {  export namespace Shapes {    export class Circle {      constructor(public radius: number) {}      area(): number {        return Math.PI * this.radius ** 2;      }    }  }}const circle = new Geometry.Shapes.Circle(5);console.log(circle.area()); // 78.53981633974483Merging NamespacesMultiple declarations of the same namespace are automatically merged, similar to declaration merging.namespace MyNamespace {  export const greeting = \"Hello\";}namespace MyNamespace {  export function sayHello(): void {    console.log(greeting);  }}MyNamespace.sayHello(); // Hello3. Namespaces vs. ModulesIn modern TypeScript development, ES6 modules (import/export) are preferred over namespaces. However, namespaces can still be useful in some scenarios.            Feature      Namespaces      Modules                  Scope      Logical grouping within a single file or project.      Based on file structure.              Usage      Used with &lt;script&gt; in browsers or older systems.      Preferred for modern JavaScript.              Import Syntax      Accessed using the namespace prefix.      Explicit import/export.              Preferred Use Case      Legacy projects or internal libraries.      Most modern TypeScript projects.      Example of a Module (Modern Syntax):// file1.tsexport interface User {  name: string;  age: number;}// file2.tsimport { User } from \"./file1\";const user: User = { name: \"Bob\", age: 40 };4. Advanced Features of NamespacesAugmenting Built-in Types with NamespacesYou can extend built-in types like Array or String using namespaces.namespace ArrayExtensions {  export function last&lt;T&gt;(arr: T[]): T | undefined {    return arr[arr.length - 1];  }}const nums = [1, 2, 3];console.log(ArrayExtensions.last(nums)); // 3Namespace AliasesUse import to create an alias for a namespace, making it easier to reference deeply nested namespaces.namespace LongNamespaceName {  export const value = 42;}import LNN = LongNamespaceName;console.log(LNN.value); // 425. Practical Applications of Namespaces  Grouping Related Code:          Combine related classes, interfaces, or functions under one namespace.        namespace UI {  export interface Button {    label: string;  }  export function render(button: Button): void {    console.log(`Rendering button: ${button.label}`);  }}const button: UI.Button = { label: \"Submit\" };UI.render(button); // Rendering button: Submit        Extending External Libraries:          Add custom logic to third-party libraries without modifying their source code.        namespace Express {  export interface Request {    user?: string;  }}        Code Organization for Large Projects:          Split namespaces across multiple files for better structure.        // file1.tsnamespace Utils {  export function log(message: string): void {    console.log(message);  }}// file2.tsnamespace Utils {  export function error(message: string): void {    console.error(message);  }}Utils.log(\"This is a log message.\");Utils.error(\"This is an error message.\");      Summary of Key Topics            Topic      Description      Example                  Namespaces      Logical groups for related code. Encapsulate members and avoid naming conflicts.      namespace Shapes { export interface Circle { radius: number; } }              Nested Namespaces      Namespaces can be nested for hierarchical organization.      namespace A { namespace B { export const value = 10; } }              Merging Namespaces      Multiple declarations of the same namespace are merged.      namespace N { export const a = 1; } and namespace N { export const b = 2; }              Namespace Aliases      Shorten long namespace names using import.      import Short = LongNamespace;              Namespaces vs Modules      Namespaces group code logically; modules group code based on files.      namespace MathUtils {} vs. import { add } from './math';      Namespaces are still relevant for certain scenarios, particularly in legacy projects, libraries, or environments where ES6 modules cannot be used. For modern projects, ES6 modules are the preferred approach for modularizing code.😊"
    },
  
    {
      "title": "More about Modules in Typescript",
      "url": "/documentation/modules",
      "date": "2025-01-19",
      "content": "1. Exporting TypesYou can export types such as interfaces, type aliases, and enums in addition to functions, classes, and variables.// types.tsexport interface Person {  name: string;  age: number;}export type ID = string | number;// main.tsimport { Person, ID } from \"./types\";const user: Person = { name: \"Alice\", age: 30 };const userId: ID = 123;console.log(user, userId);2. Re-exportsYou can re-export a module’s exports without explicitly importing them.// math.tsexport const add = (a: number, b: number) =&gt; a + b;export const subtract = (a: number, b: number) =&gt; a - b;// operations.tsexport * from \"./math\";// main.tsimport { add, subtract } from \"./operations\";console.log(add(3, 2));       // Output: 5console.log(subtract(5, 2));  // Output: 33. Import AliasesYou can use aliases to rename imports for better readability or to avoid conflicts.// utils.tsexport const calculate = (a: number, b: number) =&gt; a + b;// main.tsimport { calculate as add } from \"./utils\";console.log(add(5, 3)); // Output: 84. Importing All ExportsYou can import everything from a module as a single object.// math.tsexport const add = (a: number, b: number) =&gt; a + b;export const multiply = (a: number, b: number) =&gt; a * b;// main.tsimport * as MathUtils from \"./math\";console.log(MathUtils.add(2, 3));        // Output: 5console.log(MathUtils.multiply(2, 3));  // Output: 65. Dynamic ImportsDynamic imports allow you to load modules at runtime, which is useful for lazy-loading or conditional imports.// file1.tsexport const greet = (name: string) =&gt; `Hello, ${name}`;// main.tsasync function loadGreet() {  const { greet } = await import(\"./file1\");  console.log(greet(\"Alice\")); // Output: Hello, Alice}loadGreet();6. Module ResolutionTypeScript uses a module resolution strategy to locate and import modules. The two strategies are:Node.js (CommonJS) Resolution:  Used by default when working in a Node.js environment.  Looks for .ts, .tsx, .js, or .json files in the specified path.ES Module (ECMAScript) Resolution:  Used for modern JavaScript projects with ES Modules.  Requires setting module to ESNext or ESModule in tsconfig.json.7. Configuring Modules in TypeScriptTypeScript’s module system is configured in the tsconfig.json file. Important options include:module:Specifies the output module format (e.g., CommonJS, ESNext, or AMD).{  \"compilerOptions\": {    \"module\": \"CommonJS\"  }}moduleResolution:Controls how modules are resolved. Can be set to node or classic.{  \"compilerOptions\": {    \"moduleResolution\": \"node\"  }}baseUrl and paths:Used to define aliases for module paths.{  \"compilerOptions\": {    \"baseUrl\": \"./\",    \"paths\": {      \"@utils/*\": [\"src/utils/*\"]    }  }}// main.tsimport { calculate } from \"@utils/math\";8. Module Best Practices  Use Named Exports for Multiple Items: Default exports can cause confusion in larger projects.    export const add = (a: number, b: number) =&gt; a + b;export const subtract = (a: number, b: number) =&gt; a - b;            Organize Files Logically: Group related files into folders and avoid long import paths by using aliases.    Avoid Importing from Deep Paths:    // Badimport { something } from \"../../utils/math\";// Goodimport { something } from \"@utils/math\";        Prefer Type-Only Imports: Use import type for importing only types to reduce runtime overhead.    import type { Person } from \"./types\";      "
    },
  
    {
      "title": "More about Module Augmentation",
      "url": "/documentation/module-augmentation",
      "date": "2025-01-19",
      "content": "1. Module Augmentation  What It Is: Allows you to extend or modify the functionality of existing modules (third-party libraries or built-in modules).  How It Works:          You use the declare module syntax to tell TypeScript that you’re adding or modifying properties or types within an existing module.      TypeScript merges your changes with the existing module definitions.        Use Cases:          Add custom properties to objects from third-party libraries (e.g., adding properties to Express’s Request object).      Modify existing interfaces or classes to match specific application requirements.            Example: Adding a user property to the Request interface in Express:typescript declare module \"express\" { interface Request {   user?: string; } }       2. Global Module Augmentation  What It Is: Extends or modifies global objects like window (in browsers) or process (in Node.js).  How It Works:          Use declare global within a .d.ts declaration file to augment global objects.      This applies the modifications globally across your entire application.        Use Cases:          Add custom properties to global objects that are available throughout the application.            Example: Augmenting the window object in a browser environment:typescript declare global { interface Window {   user?: string; } } // Now you can access `window.user` anywhere in your code window.user = \"Alice\";       3. Key Concepts  Declaration Merging: When you augment a module or global object, TypeScript merges your new declarations with the original module definitions.  Type Safety: TypeScript ensures that the augmentations are type-safe, preventing errors when accessing augmented properties.      Modifying Existing Modules: You can modify an existing module’s interfaces, classes, or methods without modifying the original module code.      4. Examples of Module Augmentation  Extending Express’s Request object:    declare module \"express\" {  interface Request {    user?: string;  }}        Augmenting the process object in Node.js:typescript declare global { namespace NodeJS {   interface Process {     myCustomProperty?: string;   } } } 5. Why Use Module and Global Augmentation?  Third-party Libraries: Modify and extend third-party libraries without changing their code.  Customization: Customize existing global objects to fit your application’s needs (e.g., adding properties to window or process).      Type Safety: TypeScript ensures that your augmentations are compatible with the existing types in the module or global object.      6. Best Practices  Use .d.ts Files: Keep augmentations in separate .d.ts declaration files to maintain type safety and organization.  Be Cautious with Global Augmentations: Augmenting global objects affects the entire application, so use this feature carefully to avoid conflicts.  Namespace Management: When augmenting global types (like process or window), always use the declare global syntax to avoid conflicts with other modules.Summary:  Module Augmentation: Extends or modifies existing modules (e.g., Express, React) to add custom functionality.  Global Module Augmentation: Extends or modifies global objects (like window, process) to add custom properties accessible across your entire application.  Declaration Merging: TypeScript merges your changes with the original declarations, allowing you to safely extend third-party modules and global objects."
    },
  
    {
      "title": "More about Mapped Types",
      "url": "/documentation/mapped-types",
      "date": "2025-01-19",
      "content": "Mapped Types in TypeScriptMapped types are a powerful feature in TypeScript that allow you to create new types by transforming the properties of existing types. They are especially useful for modifying the shape or behavior of types dynamically, enabling more flexible and reusable code.1. Syntax of Mapped TypesThe basic syntax for creating a mapped type is:type NewType&lt;T&gt; = { [Key in keyof T]: TransformedType };  keyof T: Extracts all keys from the type T as a union of string or symbol literal types.  [Key in keyof T]: Iterates over each key in the type T.  T[Key]: Accesses the type of the value corresponding to the key Key in T.  Modifiers (readonly, ?): Used to adjust the properties (e.g., making them readonly or optional).2. Examples of Mapped Types2.1 Readonly TypeTransforms all properties of an object into readonly properties, preventing them from being reassigned.type Readonly&lt;T&gt; = { readonly [Key in keyof T]: T[Key] };interface Person {  name: string;  age: number;}type ReadonlyPerson = Readonly&lt;Person&gt;;const person: ReadonlyPerson = { name: \"Alice\", age: 30 };// person.name = \"Bob\"; // Error: cannot assign to 'name' because it is a read-only property.2.2 Partial TypeMakes all properties of an object optional.type Partial&lt;T&gt; = { [Key in keyof T]?: T[Key] };interface Person {  name: string;  age: number;}type PartialPerson = Partial&lt;Person&gt;;const person: PartialPerson = { name: \"Alice\" }; // `age` is optional2.3 Required TypeMakes all properties of an object required.type Required&lt;T&gt; = { [Key in keyof T]-?: T[Key] };interface Person {  name?: string;  age?: number;}type RequiredPerson = Required&lt;Person&gt;;const person: RequiredPerson = { name: \"Alice\", age: 30 }; // All properties are required2.4 Record TypeCreates an object type where keys are specified and values have a uniform type.type Record&lt;K extends keyof any, T&gt; = { [Key in K]: T };type Roles = \"admin\" | \"user\" | \"guest\";type Permissions = Record&lt;Roles, string&gt;;const permissions: Permissions = {  admin: \"all\",  user: \"read-only\",  guest: \"none\",};2.5 Pick TypeExtracts a subset of properties from an object.type Pick&lt;T, K extends keyof T&gt; = { [Key in K]: T[Key] };interface Person {  name: string;  age: number;  address: string;}type NameAndAge = Pick&lt;Person, \"name\" | \"age\"&gt;;const person: NameAndAge = { name: \"Alice\", age: 30 }; // Only name and age are allowed2.6 Omit TypeRemoves specific properties from an object type.type Omit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;interface Person {  name: string;  age: number;  address: string;}type WithoutAddress = Omit&lt;Person, \"address\"&gt;;const person: WithoutAddress = { name: \"Alice\", age: 30 }; // Address is omitted3. Key Modifiers in Mapped Types3.1 readonly ModifierApplies the readonly modifier to all properties, making them immutable.type Readonly&lt;T&gt; = { readonly [Key in keyof T]: T[Key] };3.2 ? ModifierApplies the optional (?) modifier to all properties.type Partial&lt;T&gt; = { [Key in keyof T]?: T[Key] };3.3 -? ModifierRemoves the optional modifier from all properties.type Required&lt;T&gt; = { [Key in keyof T]-?: T[Key] };3.4 -readonly ModifierRemoves the readonly modifier from all properties.type Mutable&lt;T&gt; = { -readonly [Key in keyof T]: T[Key] };4. Combining Mapped Types with Utility TypesMapped types can be combined with other TypeScript features like utility types, union types, and conditional types.4.1 Combining with Union TypesYou can use mapped types to iterate over a union of keys.type OptionsFlags&lt;T&gt; = { [Key in keyof T]: boolean };interface Features {  darkMode: () =&gt; void;  newUser: () =&gt; void;}type FeatureFlags = OptionsFlags&lt;Features&gt;;const flags: FeatureFlags = { darkMode: true, newUser: false };4.2 Using Conditional TypesYou can conditionally modify the properties of a mapped type.type Nullable&lt;T&gt; = { [Key in keyof T]: T[Key] | null };interface User {  id: number;  name: string;}type NullableUser = Nullable&lt;User&gt;;const user: NullableUser = { id: null, name: \"Alice\" }; // Properties can be null5. Advanced Use Cases5.1 Deep ReadonlyMake all properties of an object (and its nested objects) readonly.type DeepReadonly&lt;T&gt; = {  readonly [Key in keyof T]: T[Key] extends object ? DeepReadonly&lt;T[Key]&gt; : T[Key];};interface NestedObject {  level1: {    level2: {      value: string;    };  };}const obj: DeepReadonly&lt;NestedObject&gt; = {  level1: {    level2: {      value: \"Hello\",    },  },};// obj.level1.level2.value = \"New Value\"; // Error5.2 Filtering KeysExtract keys from an object based on their types.type FilterKeys&lt;T, U&gt; = { [Key in keyof T]: T[Key] extends U ? Key : never }[keyof T];interface Example {  name: string;  age: number;  isActive: boolean;}type StringKeys = FilterKeys&lt;Example, string&gt;; // \"name\"6. How Mapped Types Relate to Other TopicsMapped types build upon foundational TypeScript concepts:  Generics: Mapped types often use generics to create reusable type transformations.  Type Inference: TypeScript infers types within mapped types to ensure transformations are type-safe.  Union and Intersection Types: Mapped types frequently operate on unions or intersecting types to create flexible transformations.ConclusionMapped types are a cornerstone of TypeScript’s type system, enabling developers to create dynamic, reusable, and type-safe transformations. By leveraging features like key modifiers, utility types, and conditional types, you can write more expressive and maintainable code tailored to your application’s needs. They provide the flexibility to adapt types without losing TypeScript’s static type-checking benefits."
    },
  
    {
      "title": "Typescript Interfaces Usecases",
      "url": "/documentation/interfaces-usecases",
      "date": "2025-01-19",
      "content": "InterfacesAn interface defines the structure of an object by specifying its properties and methods. However, interfaces are not limited to describing objects. They can also define function types, arrays, hybrid types, and even work with generics.1. Defining Object StructuresThe most common use case for interfaces is to describe the shape of an object, including its properties and methods.interface Person {  name: string;  age: number;  greet(): string;}const person: Person = {  name: \"Alice\",  age: 30,  greet() {    return `Hello, my name is ${this.name}`;  },};2. Defining Function TypesInterfaces can specify the structure of a function, including its parameter types and return type.interface GreetFunction {  (name: string, age: number): string;}const greet: GreetFunction = (name, age) =&gt; {  return `Hello, my name is ${name} and I am ${age} years old.`;};console.log(greet(\"Alice\", 30)); // Hello, my name is Alice and I am 30 years old.3. Defining Array TypesInterfaces can describe the shape of arrays, specifying the types of elements they contain.Example: Array with specific element typesinterface StringArray {  [index: number]: string;}const fruits: StringArray = [\"apple\", \"banana\", \"cherry\"];Example: Associative array (key-value pairs)interface Dictionary {  [key: string]: number;}const inventory: Dictionary = {  apples: 10,  bananas: 20,};4. Using Interfaces with ClassesInterfaces can act as contracts that classes must adhere to, ensuring the class implements specific properties and methods.interface Animal {  name: string;  makeSound(): void;}class Dog implements Animal {  name: string;  constructor(name: string) {    this.name = name;  }  makeSound() {    console.log(\"Woof!\");  }}const dog = new Dog(\"Buddy\");dog.makeSound(); // Woof!5. Extending InterfacesInterfaces can extend other interfaces, allowing you to build on existing definitions.interface Shape {  color: string;}interface Circle extends Shape {  radius: number;}const circle: Circle = {  color: \"red\",  radius: 10,};6. Hybrid TypesInterfaces can describe entities that act as both objects and functions.interface Counter {  (start: number): string; // Function signature  count: number;           // Property}const counter: Counter = (start: number) =&gt; {  counter.count = start;  return `Counter started at ${start}`;};counter.count = 0;console.log(counter(10)); // Counter started at 10console.log(counter.count); // 107. Using Generics with InterfacesInterfaces can be generic, making them reusable for various types.interface Box&lt;T&gt; {  content: T;}const stringBox: Box&lt;string&gt; = { content: \"Hello\" };const numberBox: Box&lt;number&gt; = { content: 42 };console.log(stringBox.content); // Helloconsole.log(numberBox.content); // 428. Index SignaturesInterfaces can define objects with dynamic keys where the key type is known, but the exact keys are not predefined.interface Roles {  [role: string]: string;}const userRoles: Roles = {  admin: \"Administrator\",  editor: \"Content Editor\",  viewer: \"Read-Only User\",};9. Intersection Types with InterfacesInterfaces can be combined with other types using intersection (&amp;) or union (|) types.interface User {  name: string;}interface Admin {  admin: boolean;}type AdminUser = User &amp; Admin;const admin: AdminUser = {  name: \"Alice\",  admin: true,};10. Interfaces vs. Type AliasesWhile interfaces and type aliases can overlap in functionality, interfaces are better suited for object-like structures, while type aliases excel with unions and complex compositions.For example:// Interface for object-like structureinterface Person {  name: string;  age: number;}// Type alias for union typestype Role = \"admin\" | \"user\";// Type alias for complex composition (union + intersection)type Employee = Person &amp; { role: Role };11. Optional Properties in InterfacesYou can make certain properties of an interface optional by adding a question mark (?) after the property name. This allows objects that implement the interface to omit these properties.Example:interface Car {  make: string;  model: string;  year?: number;  // Optional property}const myCar: Car = {  make: \"Toyota\",  model: \"Corolla\",};In this case, year is optional, so the myCar object can still be valid even without it.SummaryInterfaces in TypeScript are a powerful tool that extends far beyond simply defining object shapes. They can describe:  Object structures.  Function types.  Array types.  Classes (via contracts).  Hybrid types (both objects and functions).  Generic structures.  Indexable types.Their versatility makes interfaces a foundational feature for designing flexible and type-safe TypeScript applications."
    },
  
    {
      "title": "More about Inferences in Typescript",
      "url": "/documentation/inferences",
      "date": "2025-01-19",
      "content": "1. Contextual TypingTypeScript uses the surrounding context to infer types, especially in scenarios like function callbacks.Example:const names = [\"Alice\", \"Bob\", \"Charlie\"];// The type of `name` is inferred as stringnames.forEach((name) =&gt; {  console.log(name.toUpperCase());});Here, the type of name is inferred from the array names, which is of type string[].2. Best Common TypeWhen inferring the type of a more complex expression, TypeScript tries to find the best common type.Example:const mixedArray = [1, \"string\", true]; // Type: (string | number | boolean)[]TypeScript combines all the types in the array and assigns the union type (string | number | boolean) to the mixedArray variable.3. Type Assertions with InferenceSometimes, you may know more about a type than TypeScript does. In such cases, you can use type assertions to explicitly tell TypeScript what type to consider.Example:let someValue: unknown = \"Hello, world!\";let stringLength = (someValue as string).length; // Type: number4. Limitations of Type InferenceType inference works well for simple cases but may require explicit types in more complex scenarios.Example:function parseInput(input: string | number) {  if (typeof input === \"string\") {    return input.toUpperCase(); // Return type inferred as string  } else {    return input.toFixed(2); // Return type inferred as string  }}Here, TypeScript infers the return type as string, but using explicit typing can clarify intent.5. Inference in GenericsGenerics also benefit from type inference, allowing you to omit the generic type when TypeScript can infer it.Example:function identity&lt;T&gt;(value: T): T {  return value;}let inferredString = identity(\"Hello\"); // T inferred as stringlet inferredNumber = identity(42);      // T inferred as number6. Return Type Inference in Arrow FunctionsTypeScript can infer the return type of arrow functions based on their bodies.Example:const multiply = (a: number, b: number) =&gt; a * b; // Return type inferred as numberExplicit return types are still helpful for clarity:const multiply = (a: number, b: number): number =&gt; a * b;7. Type Inference with DestructuringTypeScript infers types even in destructuring assignments.Example:const point = { x: 10, y: 20 };// x and y inferred as numberconst { x, y } = point;const colors = [\"red\", \"blue\", \"green\"];const [firstColor, secondColor] = colors; // Inferred as string"
    },
  
    {
      "title": "Generics Examples",
      "url": "/documentation/generics",
      "date": "2025-01-19",
      "content": "1. Generic InterfacesA generic interface allows you to define type-safe interfaces that work with various types.Example with Object Structures:interface Pair&lt;K, V&gt; {  key: K;  value: V;}const numberPair: Pair&lt;string, number&gt; = {  key: \"age\",  value: 30,};console.log(numberPair.key); // Output: ageconsole.log(numberPair.value); // Output: 30Example with Function Types:interface GenericFunction&lt;T&gt; {  (arg: T): T;}const stringFunction: GenericFunction&lt;string&gt; = (arg) =&gt; arg.toUpperCase();console.log(stringFunction(\"hello\")); // Output: HELLO2. Generic Constraints with keyofThe keyof keyword allows you to constrain a generic to the keys of an object.Example:function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {  return obj[key];}const person = { name: \"Alice\", age: 30 };console.log(getProperty(person, \"name\")); // Output: Aliceconsole.log(getProperty(person, \"age\"));  // Output: 30// Error: Argument of type '\"address\"' is not assignable to parameter of type 'keyof T'// console.log(getProperty(person, \"address\"));Here, K is constrained to be a key of the type T.3. Generics with Default TypesYou can provide default types for generics to make them optional when the type isn’t explicitly specified.Example:class BoxWithDefault&lt;T = string&gt; {  value: T;  constructor(value: T) {    this.value = value;  }  getValue(): T {    return this.value;  }}const defaultBox = new BoxWithDefault(\"Default Value\");console.log(defaultBox.getValue()); // Output: Default Valueconst numberBox = new BoxWithDefault&lt;number&gt;(42);console.log(numberBox.getValue()); // Output: 424. Benefits of Generics  Type Safety: Generics enforce type constraints, reducing runtime errors caused by incorrect types.  Reusability: Create reusable components that work across various data types.  Flexibility: Allow defining types dynamically while maintaining strong typing.  Readability: Simplify complex types and make the intent of the code clear."
    },
  
    {
      "title": "More about Discriminated Unions",
      "url": "/documentation/discriminated-unions",
      "date": "2025-01-19",
      "content": "Discriminated Unions in TypeScriptDiscriminated unions, also known as tagged unions or algebraic data types, are a powerful feature in TypeScript. They enable you to work with union types that include a shared property (discriminant) to help narrow down specific types in a type-safe way. This makes it easier to work with complex types and ensures type safety during development.1. What Are Discriminated Unions?A discriminated union is a union type where each variant (type in the union) has a unique literal property, often called a discriminant or tag. The discriminant property is used to determine which variant of the union is currently being used.Key Components:  Union Types: A type composed of multiple possible types.You define it by using the | (pipe) symbol to combine multiple types.type Shape =  | { kind: \"circle\"; radius: number }  | { kind: \"square\"; sideLength: number };  Discriminant Property: A shared property that uniquely identifies each member of the union. It often uses a literal value like “circle\" or \"square\".type Shape =  | { kind: \"circle\"; radius: number }  | { kind: \"square\"; sideLength: number };  Narrowing: TypeScript uses the discriminant to refine the type within specific branches of code.function area(shape: Shape): number {  if (shape.kind === \"circle\") {    return Math.PI * shape.radius ** 2; // shape is narrowed to { kind: \"circle\"; radius: number }  } else {    return shape.sideLength ** 2; // shape is narrowed to { kind: \"square\"; sideLength: number }  }}  Explanation: Inside the if and else branches, TypeScript narrows the type based on the value of shape.kind. If shape.kind is \"circle\", TypeScript knows it’s a circle and can access the radius property. Similarly, if shape.kind is \"square\", TypeScript knows it’s a square and can access the sideLength property.2. Example: Discriminated UnionsHere’s an example where kind is the discriminant property:type Shape =  | { kind: \"circle\"; radius: number }  | { kind: \"square\"; sideLength: number }  | { kind: \"rectangle\"; width: number; height: number };function area(shape: Shape): number {  switch (shape.kind) {    case \"circle\":      return Math.PI * shape.radius ** 2;    case \"square\":      return shape.sideLength ** 2;    case \"rectangle\":      return shape.width * shape.height;    default:      throw new Error(\"Unknown shape\");  }}const circle: Shape = { kind: \"circle\", radius: 10 };console.log(area(circle)); // 314.15926535897933. How Discriminated Unions WorkTypeScript uses control flow analysis to refine types within a block of code. When it detects a comparison or check against the discriminant property, it narrows the type automatically.Example:type Animal =  | { type: \"dog\"; bark: () =&gt; void }  | { type: \"cat\"; meow: () =&gt; void };function makeSound(animal: Animal): void {  if (animal.type === \"dog\") {    animal.bark(); // TypeScript knows this is a dog  } else {    animal.meow(); // TypeScript knows this is a cat  }}4. Benefits of Discriminated Unions  Type Safety: Ensures only valid properties and methods are accessed.  Readability: The discriminant property makes it easy to distinguish between types.  Error Prevention: TypeScript catches missing cases in functions and ensures exhaustive checks when using switch statements.  Code Clarity: Clear separation of logic for each type in the union.5. Exhaustiveness CheckingTypeScript helps ensure that all possible variants of a discriminated union are handled. If you miss a case, TypeScript can throw an error.Example: Adding a never Casefunction area(shape: Shape): number {  switch (shape.kind) {    case \"circle\":      return Math.PI * shape.radius ** 2;    case \"square\":      return shape.sideLength ** 2;    case \"rectangle\":      return shape.width * shape.height;    default:      const _exhaustiveCheck: never = shape; // TypeScript error if a new variant is added      throw new Error(`Unhandled shape: ${_exhaustiveCheck}`);  }}6. Practical Use CasesDiscriminated unions are widely used for scenarios where you need to handle multiple related types with unique behaviors.6.1 State Managementtype State =  | { status: \"loading\" }  | { status: \"success\"; data: string }  | { status: \"error\"; error: string };function handleState(state: State): void {  switch (state.status) {    case \"loading\":      console.log(\"Loading...\");      break;    case \"success\":      console.log(`Data: ${state.data}`);      break;    case \"error\":      console.error(`Error: ${state.error}`);      break;  }}6.2 API Responsestype ApiResponse =  | { status: \"ok\"; data: any }  | { status: \"error\"; error: string };function handleResponse(response: ApiResponse): void {  if (response.status === \"ok\") {    console.log(\"Data:\", response.data);  } else {    console.error(\"Error:\", response.error);  }}"
    },
  
    {
      "title": "More about Decorators in Typescript",
      "url": "/documentation/decorators",
      "date": "2025-01-19",
      "content": "Decorators in TypeScriptDecorators are a powerful feature in TypeScript that allows you to annotate and modify classes, methods, properties, and parameters at runtime. They provide a clean way to apply reusable behaviors or metadata to your code. Decorators are particularly useful in frameworks like Angular, where they are extensively used for dependency injection and metadata annotation.1. What Are Decorators?A decorator is a special kind of declaration attached to a class, method, accessor, property, or parameter. Decorators are defined using the @ symbol followed by a function.Decorator Syntax@decoratorclass MyClass {}2. Enabling DecoratorsDecorators are an experimental feature in TypeScript and must be explicitly enabled in the tsconfig.json:{  \"experimentalDecorators\": true}3. Types of DecoratorsTypeScript provides several types of decorators:            Decorator Type      Targeted Element                  Class Decorator      Classes              Method Decorator      Methods              Accessor Decorator      Getters and setters              Property Decorator      Properties              Parameter Decorator      Function or constructor parameters      4. Class DecoratorsA class decorator applies to a class declaration. It can modify or replace the class definition.Example 1: Logging Class Creationfunction logClass(target: Function) {  console.log(`${target.name} class is being created!`);}@logClassclass MyClass {}const instance = new MyClass(); // Logs: MyClass class is being created!Example 2: Adding Static Propertiesfunction addTimestamp(target: Function) {  target.prototype.timestamp = Date.now();}@addTimestampclass MyClass {}const instance = new MyClass();console.log((instance as any).timestamp); // Logs the timestamp5. Method DecoratorsA method decorator is applied to a method of a class. It can modify the method or add functionality.Example: Logging Method Callsfunction logMethod(  target: any,  propertyKey: string,  descriptor: PropertyDescriptor) {  const originalMethod = descriptor.value;  descriptor.value = function (...args: any[]) {    console.log(`Calling ${propertyKey} with arguments:`, args);    return originalMethod.apply(this, args);  };}class MyClass {  @logMethod  sayHello(name: string) {    console.log(`Hello, ${name}!`);  }}const instance = new MyClass();instance.sayHello(\"Alice\");// Logs:// Calling sayHello with arguments: [ 'Alice' ]// Hello, Alice!6. Property DecoratorsA property decorator applies to class properties. It allows you to attach metadata or modify how the property is used.Example: Marking Required Propertiesfunction required(target: any, propertyKey: string) {  console.log(`Property \"${propertyKey}\" is required.`);}class MyClass {  @required  name!: string;}// Logs: Property \"name\" is required.7. Accessor DecoratorsAccessor decorators are used on getters and setters of properties.Example: Validating Property Accessfunction logAccess(  target: any,  propertyKey: string,  descriptor: PropertyDescriptor) {  const originalGet = descriptor.get;  descriptor.get = function () {    console.log(`Accessing property \"${propertyKey}\"`);    return originalGet?.apply(this);  };}class MyClass {  private _value = 42;  @logAccess  get value() {    return this._value;  }}const instance = new MyClass();console.log(instance.value);// Logs:// Accessing property \"value\"// 428. Parameter DecoratorsA parameter decorator applies to the parameters of a method or constructor. It’s often used for dependency injection or metadata collection.Example: Logging Parameter Metadatafunction logParameter(  target: any,  propertyKey: string,  parameterIndex: number) {  console.log(    `Parameter at index ${parameterIndex} in method \"${propertyKey}\" is being logged.`  );}class MyClass {  greet(@logParameter name: string) {    console.log(`Hello, ${name}`);  }}const instance = new MyClass();instance.greet(\"Alice\");// Logs:// Parameter at index 0 in method \"greet\" is being logged.// Hello, Alice9. Composing Multiple DecoratorsYou can stack multiple decorators on a single element. Decorators are applied in reverse order (bottom to top).function first(target: any, propertyKey: string) {  console.log(\"First decorator\");}function second(target: any, propertyKey: string) {  console.log(\"Second decorator\");}class MyClass {  @first  @second  method() {}}// Logs:// Second decorator// First decorator10. Practical Use Cases for Decorators  Dependency Injection: Used in frameworks like Angular for injecting dependencies into classes.  Logging: Automatically log class instantiation, method calls, or property accesses.  Validation: Mark required properties or validate method arguments.  Metadata: Attach additional metadata to classes or members, useful for libraries like reflect-metadata.Summary of All Topics            Feature      Description      Example                  Class Decorator      Modifies or replaces class definitions.      @logClass              Method Decorator      Enhances or overrides method behavior.      @logMethod              Property Decorator      Adds metadata or modifies properties.      @required              Accessor Decorator      Applies to getters or setters to log or modify access behavior.      @logAccess              Parameter Decorator      Logs or injects data into parameters.      @logParameter              Indexed Access Types      Retrieves the type of a property dynamically.      type Name = Person[\"name\"];              Template Literal Types      Constructs string types dynamically.      type API = \\${\"GET\" | \"POST\"} /${\"users\"}\\              Utility Types      Built-in types for manipulating types (Partial, Readonly, Pick, Omit).      type PartialPerson = Partial&lt;Person&gt;;              Conditional Types      Constructs types conditionally based on logic (extends ? :).      type IsString&lt;T&gt; = T extends string ? true : false;              Mapped Types      Creates new types by transforming existing ones (readonly, optional).      type Readonly&lt;T&gt; = { readonly [K in keyof T]: T[K] };              Keyof and Lookup Types      Dynamically access object keys and properties.      type Key = keyof Person;              Generics      Enables reusable, flexible code for any type.      function identity&lt;T&gt;(arg: T): T;              Modules      Allows splitting code into separate files for better organization (import/export).      import { greet } from \"./file\";      "
    },
  
    {
      "title": "More about Declaration Merging",
      "url": "/documentation/declaration-merging",
      "date": "2025-01-19",
      "content": "Declaration Merging in TypeScriptDeclaration merging is a feature in TypeScript where two or more declarations with the same name are automatically combined into a single definition. This feature is particularly useful for extending existing types, interfaces, namespaces, and modules. It ensures that TypeScript provides flexible and extensible code constructs.1. How Declaration Merging WorksWhen TypeScript encounters multiple declarations of the same name, it merges their members into a single composite type. The way merging happens depends on the type of the declaration:  Interfaces: Members are combined.  Namespaces: Members are combined.  Enums: Members are combined.  Functions and Classes: Overloads are created.2. Interface MergingInterfaces with the same name are automatically merged, with their members combined into a single definition.Example: Merging Interfacesinterface Person {  name: string;}interface Person {  age: number;}const person: Person = {  name: \"Alice\",  age: 30,}; // Both `name` and `age` are available due to mergingRules for Interface Merging  If two members have the same name and type, they are compatible.  If two members have the same name but different types, a compilation error occurs.Example: Conflicting Membersinterface Animal {  name: string;}interface Animal {  name: number; // Error: Subsequent property declarations must have the same type}3. Namespace MergingNamespaces with the same name are merged, and their members are combined into a single namespace.Example: Merging Namespacesnamespace MyNamespace {  export const greeting = \"Hello\";}namespace MyNamespace {  export function sayHello() {    console.log(greeting);  }}MyNamespace.sayHello(); // Logs: HelloUse Case: Extending External LibrariesDeclaration merging can extend third-party libraries by adding additional functionality.namespace Express {  export interface Request {    user?: string;  }}4. Enum MergingEnums with the same name are merged, combining their members into a single enum.Example: Merging Enumsenum Colors {  Red,}enum Colors {  Blue = 2,}console.log(Colors.Red);  // 0console.log(Colors.Blue); // 25. Function and Class MergingFor functions or classes, declaration merging results in overload declarations.Example: Function Mergingfunction add(x: number): number;function add(x: string): string;function add(x: any): any {  return x;}console.log(add(10));     // 10console.log(add(\"hello\")); // helloExample: Class Merging with Namespaceclass Car {  constructor(public make: string) {}}namespace Car {  export const numberOfWheels = 4;}const myCar = new Car(\"Toyota\");console.log(Car.numberOfWheels); // 46. Practical Applications of Declaration Merging  Extending Third-Party Libraries          Adding additional members to interfaces from external libraries.        interface Window {  customProperty: string;}window.customProperty = \"Hello, world!\";        Combining Related Code          Grouping related declarations (interfaces, namespaces, etc.) without modifying original declarations.        Creating Overloads          Defining multiple versions of functions or methods using merging.      Key Topics Recap            Topic      Description      Example                  Declaration Merging      Combining multiple declarations of the same name into one.      Merging interfaces, namespaces, enums, or creating function overloads.              Interfaces      Members are combined into one.      interface A { x: number; } and interface A { y: string; } =&gt; { x: number; y: string }              Namespaces      Members are merged into the same namespace.      Adding methods to an existing namespace.              Enums      Enum members are merged into one enum.      enum Colors { Red } and enum Colors { Blue } =&gt; Colors.Red and Colors.Blue.              Functions and Classes      Overloads are created during merging.      Adding a namespace to a class or defining multiple function signatures.      "
    },
  
    {
      "title": "More about Conditional Types",
      "url": "/documentation/conditional-types",
      "date": "2025-01-19",
      "content": "1. Syntax of Conditional TypesThe syntax for a conditional type is:T extends U ? X : Y  T: The type to evaluate.  U: The condition to check (T extends U).  X: The type returned if the condition is true.  Y: The type returned if the condition is false.2. Example: Basic Conditional TypeThe following example checks if a type T is a string:type IsString&lt;T&gt; = T extends string ? true : false;type Test1 = IsString&lt;string&gt;; // truetype Test2 = IsString&lt;number&gt;; // falseHere, Test1 resolves to true because string extends string, while Test2 resolves to false because number does not extend string."
    },
  
    {
      "title": "More about Advanced Decorator",
      "url": "/documentation/advanced-decorator",
      "date": "2025-01-19",
      "content": "Advanced Decorator UsageDecorators in TypeScript are a powerful feature, primarily used for metadata reflection in frameworks like Angular. They allow you to modify or annotate classes, methods, properties, and parameters. In Angular, decorators are extensively used for features like dependency injection, routing, and more.Key Concepts:      What is a Decorator?          A decorator is a special kind of function that can be attached to a class, method, property, or parameter to modify or add metadata to it.      Decorators are commonly used in frameworks like Angular and NestJS to add extra functionality to components, services, and other entities.            Types of Decorators:          Class Decorators: Used to modify or annotate classes.      Method Decorators: Used to modify methods.      Property Decorators: Used to modify properties.      Parameter Decorators: Used to modify method parameters.            Class Decorators:          Class decorators are functions that take the class constructor as an argument and can modify its behavior or add metadata.        Example: A simple class decorator:    function Injectable(target: Function) {  console.log(`Injectable: ${target.name}`);}@Injectableclass MyService {}              How it works:                  The Injectable decorator takes the class constructor (target) and logs a message with the class name.          The @Injectable decorator is applied to the MyService class, making it injectable (this concept is widely used in Angular for dependency injection).                          Decorator Syntax:          Decorator Declaration: A decorator is defined as a function that typically takes arguments like the target class, method, or property.      Decorator Application: You apply a decorator by prefixing it with the @ symbol before a class, method, property, or parameter.            Advanced Use Cases for Decorators:                  Metadata Reflection:                  Decorators are often used in frameworks like Angular for dependency injection, routing, and more by attaching metadata to classes and methods.          For instance, Angular uses the @Injectable decorator to mark services that can be injected into other components or services.                            Method Decorators:                  You can create decorators to modify or enhance the behavior of methods, such as logging, authentication, etc.                Example:        function Log(  target: any,  propertyKey: string,  descriptor: PropertyDescriptor) {  const originalMethod = descriptor.value;  descriptor.value = function (...args: any[]) {    console.log(      `Calling ${propertyKey} with arguments: ${JSON.stringify(args)}`    );    return originalMethod.apply(this, args);  };}class Calculator {  @Log  add(a: number, b: number) {    return a + b;  }}const calc = new Calculator();calc.add(2, 3); // Logs: Calling add with arguments: [2,3]                          How it works: The @Log decorator wraps the add method to log the arguments every time it’s called.                          Dependency Injection in Angular (Example):          Decorators like @Injectable, @Component, and @Directive in Angular are used to add metadata for dependency injection and component configuration.        Example: Angular-style @Injectable decorator:    function Injectable(target: Function) {  console.log(`${target.name} is injectable!`);}@Injectableclass MyService {  // Service logic}              How it works: The @Injectable decorator marks MyService as a service that can be injected into other parts of the application, helping Angular’s dependency injection system manage instances of MyService.            Parameter Decorators:          These decorators are used to modify the behavior or add metadata to method parameters.        Example:    function Param(target: any, propertyKey: string, parameterIndex: number) {  console.log(    `Parameter at index ${parameterIndex} in method ${propertyKey} was decorated`  );}class MyClass {  greet(@Param name: string) {    console.log(`Hello, ${name}!`);  }}            Use Cases for Decorators in Frameworks:          Angular: Dependency injection, lifecycle hooks, component metadata, routing.      NestJS: Controllers, services, and route handlers.      Logging: Method decorators for logging inputs and outputs.      Access Control: Decorators for controlling access to methods based on user roles (e.g., @Role('admin')).      Summary:  Decorators in TypeScript are used to modify or annotate classes, methods, properties, and parameters with additional functionality or metadata.  They are widely used in frameworks like Angular for dependency injection and NestJS for routing and middleware handling.  Advanced usage includes using decorators for metadata reflection, logging, dependency injection, and more.  Examples of common decorators include @Injectable, @Component, @Log, and custom decorators to modify method behavior."
    },
  
    {
      "title": "Jekyll Github Pages Website",
      "url": "/documentation/jekyll-github-pages-website",
      "date": "2025-01-18",
      "content": "This is my personal guide related to all about making github pages with and without jekyll.1. Github pages website (without jekyll + only markdown files)  Reference Repo: this  Reference Website: this  It contains no themes, no extra github pages features, etc. Just the simplest form of github pages website.  Process:          Initialise a repo      Add a readme and any other markdown files that you want to put.      Go to settings tab of repo, pages sections, these choose main branch and root directory. In sometime the website url will apear in the current page (just reload after a while)        Features:          Allows normal features of markdown files: links, markdown syntax etc      No themes, automatic navbar, etc      2. Github pages website (with jekyll theme + only markdown files)  Reference Repo: this  Reference Website: this  Process:          Steps 1 to 3 same as above      Add a _config.yml file which contains a theme supported by github and other configuration respective to that theme provide its repo.        Features:          Allows normal features of markdown files: links, markdown syntax etc      Github supported themes and any features respective to that theme alone (no custom configurations outside of what that theme can provide)      3. Autogenerated Github pages website ( with jekyll theme + markdown + html files)  Reference Repo: this  Reference Website: this  Pre-requisites:          Ruby installed (For windows - https://rubyinstaller.org/downloads/), the one with devkit      Jekyll and bundler installed - gem install jekyll bundler        Process:          Creating webpage: run jekyll new my-site      Running webpage locally: run bundle exec jekyll serve      Running webpage with github: push to repo and setup github pages via settings (as point 3 in here)        Features:          Neccessary markdown and html files, Gemfile with predefined gems, _config.yml with preset configurations and theme.      Just have to add more markdown files into _posts folder to add more posts to the website. Everything else is autogenerated      4. Github pages website from scratch (with jekyll +  markdown + html files + github pages workflows)  Reference Repo: this  Reference Website: this  Pre-requisites:          Ruby installed (For windows - https://rubyinstaller.org/downloads/), the one with devkit      jekyll and bundler installed - gem install jekyll bundler        Process:          Create a _config.yml                  For properties, visit https://json.schemastore.org/jekyll.json. In that go to the key called properties and under it every key is a possible property that can be added to the config file.          For default properties specific to any particular theme or website template, visit that template and read its documentation or code base to identiy what variables are used in its code.          Finding variables :                              We will be using architect theme from https://github.com/pages-themes/architect. I’ll just go ahead and copy info from its _config.yml                    Create a file called Gemfile                  Its like package.json but for ruby. It contains gems (packages for installation)          In it add necessary gems for jekyll, and those related to the respective theme/template. (example)          Bundle the gemfile by running bundle install or just bundle                    Create a file called .gitignore specific to jekyll, automatically by running npx gitignore jekyll      Adding files:                  Add a readme file that acts a starting point          Add additonal frontmatter to any post or page that you make. (example)          Add custom markdown pages [optional]. (example)          Add custom html pages [optional]. (example)                      Running:          Running webpage locally: run bundle exec jekyll serve      Running webpage with github: push to repo and setup github pages via settings      5. Github pages website from scratch (with jekyll + markdown + html files + custom github workflows)  Reference Repo: this  Reference Website: This current blog website  Process:          Every thing same as 4, but we will build our own workflow.      This is required when we make any changes in jekyll core code, because github-pages gem do not consider any changes that is made in jekyll core code like this. So we make our own github workflow.        Github Workflow:          Add a folder named .github, within which you add another folder workflows, within which you add a file named jekyll.yml      In that file you add the following code        Running:          Same as 4      Running webpage locally: run bundle exec jekyll serve      Running webpage with github: push to repo and setup github pages via settings      ◈ Additional Notes:  List of starter file of some simple and pretty github pages websites:          https://github.com/cotes2020/chirpy-starter      https://github.com/jekyll/minima/tree/v2.5.2      https://github.com/jsanz/gh-pages-minima-starter      https://github.com/alshedivat/al-folio        Some other references for github pages website setup:          https://github.com/jekyll/jekyll/blob/master/lib/site_template/_config.yml      https://opensource.com/article/21/11/jekyll-config-files      https://nainagurung.medium.com/publish-github-pages-using-jekyll-369a8e2800b7      "
    },
  
    {
      "title": "Typescript learners guide",
      "url": "/documentation/typescript-learners-guide",
      "date": "2025-01-18",
      "content": "To study basic and advanced typescript:Table of Contents  Basic          Basic Types      Type Annotations      Interfaces      Classes      Enums      Functions      Arrays and Tuples      Union and Intersection Types      Type Aliases      Generics      Modules      Type Inference        Advanced          Advanced Types      Type Guards      Discriminated Unions      Keyof and Lookup Types      Template Literal Types      Decorators      Declaration Merging      Namespace      Type Manipulation      Module Augmentation      Strict Type Checking      Advanced Generics      Dynamic Import Types      Compiler Configuration      Advanced Decorator Usage        Interview QuestionsBasic Typescript Concepts1. Basic TypesTypeScript provides a set of basic types for handling data:string, number, booleanlet name: string = \"Alice\";let age: number = 30;let isActive: boolean = true;null, undefined, void  null and undefined represent absence of value.  void is used for functions that don’t return a value.let emptyValue: null = null;let notAssigned: undefined = undefined;function logMessage(): void {  console.log(\"Hello!\");}any, unknown  any allows any type and essentially disables type checking.  unknown is similar to any, but more restrictive, requiring type checking before usage.let anything: any = 42;anything = \"Now a string\"; // No errorlet uncertain: unknown = 42;if (typeof uncertain === \"string\") {  console.log(uncertain.toUpperCase()); // OK after checking the type}nevernever is used for functions that never return a value, like functions that throw exceptions or enter infinite loops.function throwError(message: string): never {  throw new Error(message);}2. Type AnnotationsType annotations specify the type of variables, function parameters, and return values explicitly.let x: number = 10; // Type annotation for a numberfunction greet(name: string): string {  return `Hello, ${name}`;}3. InterfacesAn interface defines the structure of an object by specifying its properties and methods. However, interfaces are not limited to describing objects. They can also define function types, arrays, hybrid types, and even work with generics.Defining Object StructuresThe most common use case for interfaces is to describe the shape of an object, including its properties and methods.interface Person {  name: string;  age: number;  greet(): string;}const person: Person = {  name: \"Alice\",  age: 30,  greet() {    return `Hello, my name is ${this.name}`;  },};For other use cases visit here4. ClassesClasses allow you to define blueprints for objects, including properties and methods.class Animal {  name: string;  constructor(name: string) {    this.name = name;  }  speak(): void {    console.log(`${this.name} makes a sound`);  }}class Dog extends Animal {  constructor(name: string) {    super(name);  }  speak(): void {    console.log(`${this.name} barks`);  }}let dog = new Dog(\"Buddy\");dog.speak(); // Buddy barksAccess Modifiers  public: Can be accessed from anywhere (default).  private: Can only be accessed within the class.  protected: Can be accessed within the class and subclasses.class User {  public name: string;  private password: string;  constructor(name: string, password: string) {    this.name = name;    this.password = password;  }  showName() {    console.log(this.name);  }}5. EnumsEnums define named constant values. TypeScript supports numeric and string enums.Numeric Enum:enum Direction {  Up = 1,  Down,  Left,  Right,}console.log(Direction.Up); // 1String Enum:enum Status {  Pending = \"PENDING\",  InProgress = \"IN_PROGRESS\",  Completed = \"COMPLETED\",}console.log(Status.Pending); // \"PENDING\"6. FunctionsTypeScript allows specifying types for function parameters and return values. It also supports optional, default, and rest parameters.Parameter Types and Return Typesfunction add(a: number, b: number): number {  return a + b;}Optional Parameters (?)function greet(name: string, age?: number): string {  return age ? `${name} is ${age} years old` : `${name}`;}console.log(greet(\"Alice\")); // Aliceconsole.log(greet(\"Bob\", 30)); // Bob is 30 years oldDefault Parametersfunction greet(name: string, age: number = 25): string {  return `${name} is ${age} years old`;}Rest Parameters (...args)function sum(...numbers: number[]): number {  return numbers.reduce((acc, num) =&gt; acc + num, 0);}console.log(sum(1, 2, 3, 4)); // 107. Arrays and TuplesTyped ArraysArrays can be strongly typed.let numbers: number[] = [1, 2, 3];let strings: Array&lt;string&gt; = [\"a\", \"b\", \"c\"];TuplesTuples are arrays with fixed sizes and types for each element.let tuple: [string, number] = [\"Alice\", 30];More about tuples, and difference between tuples and arrays here8. Union and Intersection TypesUnion Types (|)A variable can hold multiple types.function print(value: string | number): void {  console.log(value);}print(\"Hello\");print(42);Intersection Types (&amp;)Combining multiple types into one.interface Person {  name: string;  age: number;}interface Employee {  employeeId: string;  role: string;}type EmployeePerson = Person &amp; Employee;const emp: EmployeePerson = {  name: \"Alice\",  age: 30,  employeeId: \"E123\",  role: \"Engineer\",};9. Type AliasesType aliases allow creating custom types that can be reused across the codebase.type ID = string | number;function getUser(id: ID): void {  console.log(`Fetching user with ID: ${id}`);}getUser(1);getUser(\"abc123\");More about type aliases here10. GenericsGenerics allow writing functions, classes, and interfaces that work with any data type, providing more flexibility and reusability.function identity&lt;T&gt;(arg: T): T {  return arg;}let output = identity&lt;string&gt;(\"Hello\");console.log(output); // Hellolet numberOutput = identity&lt;number&gt;(100);console.log(numberOutput); // 100Generic Classesclass Box&lt;T&gt; {  value: T;  constructor(value: T) {    this.value = value;  }  getValue(): T {    return this.value;  }}const stringBox = new Box&lt;string&gt;(\"Hello\");console.log(stringBox.getValue()); // HelloMore of generic types and examples here11. ModulesModules allow code to be split into separate files, which can be imported/exported.// file1.tsexport function greet(name: string): string {  return `Hello, ${name}`;}// file2.tsimport { greet } from \"./file1\";console.log(greet(\"Alice\")); // Hello, AliceMore about modules here12. Type InferenceTypeScript automatically infers the type of a variable when the type is not explicitly declared.let inferredString = \"Hello\"; // inferred as stringlet inferredNumber = 42; // inferred as number// TypeScript can infer types from function return values as wellfunction multiply(x: number, y: number) {  return x * y; // inferred return type is number}let result = multiply(3, 4);More about inferences hereAdvanced Typescript Concepts1. Advanced TypesMapped TypesMapped types allow you to create a new type based on an existing one by transforming its properties. You can modify the properties or their types.Example: Create a Readonly type that marks all properties of an object as readonly:type Readonly&lt;T&gt; = { readonly [K in keyof T]: T[K] };interface Person {  name: string;  age: number;}type ReadonlyPerson = Readonly&lt;Person&gt;;const person: ReadonlyPerson = { name: \"Alice\", age: 30 };// person.name = 'Bob'; // Error: cannot assign to 'name' because it is a read-only property.Here, in type Readonly&lt;T&gt; = { readonly [K in keyof T]: T[K] };  Readonly&lt;T&gt;: This is a type alias that accepts a generic type parameter T. This means that T can be any type (such as an object, interface, etc.).  { readonly [K in keyof T]: T[K] }: This is a mapped type that iterates over all the keys of type T and makes each of them readonly. Let’s break it down further:          keyof T: This expression gets all the keys (property names) of type T as a union of string literals. For example, if T is { name: string; age: number; }, then keyof T would be \"name\" | \"age\".      [K in keyof T]: This is the syntax for a mapped type that iterates over each key K in keyof T. Essentially, K will take each key of T one by one.      T[K]: This accesses the type of the property K in type T. For example, if T is { name: string; age: number; }, then T[\"name\"] would be string and T[\"age\"] would be number.        readonly [K in keyof T]: T[K]: The readonly modifier makes each property of type T immutable. This means that once a property is assigned a value, it cannot be changed. So, the final result is that for every property K in type T, the property is transformed into a readonly version.More about mapped types hereConditional TypesConditional types use the extends keyword to define conditional logic based on the type of a variable.Example: Check if a type T is string:type IsString&lt;T&gt; = T extends string ? true : false;type Test1 = IsString&lt;string&gt;; // truetype Test2 = IsString&lt;number&gt;; // falseMore about conditional types hereUtility TypesTypeScript provides several built-in utility types that help manipulate types.  Partial&lt;T&gt;: Makes all properties of T optional.  Required&lt;T&gt;: Makes all properties of T required.  Readonly&lt;T&gt;: Makes all properties of T read-only.  Pick&lt;T, K&gt;: Picks a subset of properties K from type T.  Omit&lt;T, K&gt;: Omits properties K from type T.interface Person {  name: string;  age: number;  address?: string;}type PartialPerson = Partial&lt;Person&gt;; // All properties are optionaltype RequiredPerson = Required&lt;Person&gt;; // All properties are requiredtype NameOnly = Pick&lt;Person, \"name\"&gt;; // Only `name` is pickedtype WithoutAddress = Omit&lt;Person, \"address\"&gt;; // `address` is omitted2. Type GuardsType guards help narrow the type within a conditional block using x is Type syntax or built-in checks.Custom Type GuardYou can create your own type guards to narrow types based on logic.function isString(value: any): value is string {  return typeof value === \"string\";}const input: any = \"Hello, world!\";if (isString(input)) {  // TypeScript now knows that `input` is a string here.  console.log(input.toUpperCase()); // OK}instanceof and typeofinstanceof and typeof are used for runtime type checks.class Dog {  bark() {    console.log(\"Woof!\");  }}const pet = new Dog();if (pet instanceof Dog) {  pet.bark(); // OK, `pet` is now recognized as a `Dog`}const value = 42;if (typeof value === \"number\") {  console.log(value.toFixed(2)); // OK}3. Discriminated UnionsDiscriminated unions allow for union types that include a tag (discriminant) to help narrow down types.Example: Different actions for different shapes using a type property:type Shape =  | { kind: \"circle\"; radius: number }  | { kind: \"square\"; sideLength: number };function area(shape: Shape): number {  if (shape.kind === \"circle\") {    return Math.PI * shape.radius ** 2;  } else {    return shape.sideLength ** 2;  }}More about Discriminated Unions here4. Keyof and Lookup Typeskeyof and lookup types allow you to dynamically access the keys and values of a type.keyof OperatorThe keyof operator creates a union of string literal types representing the keys of an object type.Get the keys of an object type as a union of string literals.      Definition:    keyof T              T: An object type.      Result: A union of string literal types representing all keys of T            Example:    interface Person {  name: string;  age: number;}type Key = keyof Person; // \"name\" | \"age\"      Lookup TypesLookup types also called as Indexed Access Types let you access the type of a specific property dynamically using bracket notation (T[K]).Access the value of a specific property dynamically.  Definition:    T[K];              T: An object type.      K: A key in T (must be assignable to keyof T).      Result: The type of the property K in T.        Example:    interface Person {  name: string;  age: number;}type Value = Person[\"name\"]; // string      5. Template Literal TypesTemplate literal types allow you to construct types by combining string literals, creating dynamic string types.type Greeting = `Hello, ${string}!`;const greeting: Greeting = \"Hello, Alice!\"; // Valid// const invalidGreeting: Greeting = \"Hi, Alice!\";  // Error: doesn't match `Hello, ${string}!`6. DecoratorsDecorators are an experimental feature that allows you to modify the behavior of classes, methods, or properties. Decorators are defined using the @ symbol followed by a function.  Decorator Syntax:    @decoratorclass MyClass {}            Example: A simple class decorator that logs class creation.    ```typescriptfunction logClass(target: Function) {console.log(`${target.name} class is being created!`);}@logClassclass MyClass {}const instance = new MyClass(); // Logs: MyClass class is being created!```        More about decorators here  7. Declaration MergingDeclaration merging occurs when multiple declarations of the same type or interface are combined into one.      Example:    interface Person {  name: string;}interface Person {  age: number;}const person: Person = {  name: \"Alice\",  age: 30,}; // Declaration of `Person` is merged      More about Declaration Merging here8. NamespaceNamespaces are used to organize code into logical groups (legacy feature but still used in some scenarios).namespace Shapes {  export interface Circle {    radius: number;  }  export interface Square {    sideLength: number;  }}const circle: Shapes.Circle = { radius: 5 };const square: Shapes.Square = { sideLength: 10 };More about Namespace here9. Type ManipulationAdvanced type manipulation allows you to infer types using infer and perform conditional type transformations. The infer keyword allows you to extract a type from a more complex type within conditional typestype ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never;type MyFunction = (x: number, y: number) =&gt; string;type Result = ReturnType&lt;MyFunction&gt;; // stringHere, ReturnType&lt;T&gt; is a conditional type that:  Checks if T is a function (denoted by (...args: any[]) =&gt;).  If T is a function, it infers the return type of that function and assigns it to R.  If T is not a function, it returns never (meaning an invalid type).More about Type Manipulation here10. Module AugmentationModule augmentation allows you to extend or modify existing modules, adding new functionality.Example: Augmenting a module to add new properties to an existing interface.// Augmenting a global module or third-party library// express.d.ts (this can be a separate declaration file or inside your main code)declare module \"express\" {  interface Request {    user?: string;  }}Now you can edit/access user property on Request:import express from \"express\";const app = express();// Middleware to add a user to the requestapp.use((req, res, next) =&gt; {  req.user = \"Alice\"; // Adding a `user` property to the Request object  next();});// Route handler that accesses the augmented `user` propertyapp.get(\"/\", (req, res) =&gt; {  if (req.user) {    res.send(`Hello, ${req.user}!`); // TypeScript recognizes `req.user` due to augmentation  } else {    res.send(\"Hello, guest!\");  }});More about module augmentation here11. Strict Type CheckingEnable strict type checking options to enforce safer coding practices.In tsconfig.json:{  \"compilerOptions\": {    \"strict\": true,    \"strictNullChecks\": true,    \"noImplicitAny\": true  }}strictNullChecks ensures that null and undefined are not assignable to other types by default. noImplicitAny disallows variables from being implicitly typed as any.12. Advanced GenericsGeneric Constraints (T extends U)Restrict the types that can be used with generics.function echo&lt;T extends string&gt;(value: T): T {  return value;}echo(\"Hello\"); // OK// echo(123);  // Error: Argument of type 'number' is not assignable to parameter of type 'string'.Default Generic ParametersYou can set default types for generics.function identity&lt;T = string&gt;(value: T): T {  return value;}identity(\"Hello\"); // stringidentity(42); // numberRecursive GenericsGenerics can be recursive, allowing more complex types.The type List&lt;T&gt; is defined in such a way that it can refer to itself. That is, it can be an array of List&lt;T&gt;, or a single value of type T. This allows the type to represent a list that can contain other lists, and so on, creating a recursive structure.type List&lt;T&gt; = T | List&lt;T&gt;[];// Example with numberslet listOfNumbers: List&lt;number&gt; = 42; // Single number (T)let nestedListOfNumbers: List&lt;number&gt; = [42, [42, 100], 57]; // Array of numbers and nested arrays13. Dynamic Import TypesUsing import() syntax to dynamically load modules at runtime.// This defines the type of the module (its exports).type Module = typeof import(\"./module\");// The async function dynamically loads the module at runtime.async function loadModule() {  const module = await import(\"./module\");  // The 'module' is dynamically loaded and now you can access its exports.  module.someFunction();  // You can also use the `Module` type to type-check the `module` variable.  let myModule: Module = module; // Ensure the module matches the defined type  myModule.someFunction(); // Now TypeScript will type-check it}14. Compiler Configurationtsconfig.json is the configuration file for TypeScript. It lets you set compiler options, such as module resolution, strict settings, and more.Example tsconfig.json:{  \"compilerOptions\": {    \"target\": \"ES2020\",    \"module\": \"commonjs\",    \"strict\": true,    \"outDir\": \"./dist\"  }}15. Advanced Decorator UsageFor frameworks like Angular, decorators play an essential role in metadata reflection. This enables functionality such as dependency injection.Example: An Angular-style decorator for a class:function Injectable(target: Function) {  console.log(`Injectable: ${target.name}`);}@Injectableclass MyService {} // Injectable: MyServiceMore about Advanced Decorator hereKey Use Cases for Advanced TopicsAdvanced TypeScript concepts often come into play when building:  Frameworks or libraries.  Complex type-safe APIs.  Enterprise-level projects requiring strict type safety.  Integration with JavaScript libraries using type declarations.Interview QuestionsHere are some commonly asked questions in TypeScript interviews:  What is TypeScript, and how does it differ from JavaScript?  What are the key benefits of using TypeScript over JavaScript?  Explain the concept of types in TypeScript.  What are the primitive types in TypeScript?  What is type inference in TypeScript?  Can you explain the any type in TypeScript? When should it be used?  What is the difference between interface and type in TypeScript?  What are generics in TypeScript? Can you provide an example?  What is the unknown type in TypeScript, and how does it differ from any?  How do you define optional properties in TypeScript interfaces or types?  What are tuples in TypeScript? Provide an example.  How does TypeScript handle null and undefined values?  What is a union type in TypeScript? Provide an example.  What is an intersection type in TypeScript? Provide an example.  Explain the concept of “type guards” in TypeScript.  What are enums in TypeScript? How are they different from strings or numbers?  How can you declare and use classes in TypeScript?  What is the never type in TypeScript? Provide a use case for it.  How do you extend interfaces or types in TypeScript?  What are decorators in TypeScript? How are they used?  What is the difference between public, private, and protected access modifiers in TypeScript?  How do you handle modules in TypeScript?  How can you use TypeScript with third-party JavaScript libraries that don’t have type definitions?  What are ambient declarations in TypeScript?  Explain the difference between const, let, and var in TypeScript.  What is the purpose of the as keyword in TypeScript?  What is the difference between type assertions and type casting in TypeScript?  What are some of the TypeScript configuration options (tsconfig.json)?  How do you configure TypeScript for a React project?  How do you work with promises and async/await in TypeScript?  What is the Readonly utility type in TypeScript?  How do you handle errors in TypeScript?  What are some common pitfalls to avoid when using TypeScript?  How does TypeScript support asynchronous programming?  What is the purpose of strict mode in TypeScript, and what are the advantages of enabling it?Here’s a mix of easy, medium, and advanced TypeScript interview questions:Easy Level:  What is TypeScript and why is it used?  How do you install TypeScript?  What is the difference between let and const in TypeScript?  What are type aliases in TypeScript, and how do you use them?  Can you explain the purpose of the void type in TypeScript?  What are the basic types in TypeScript (number, string, boolean, etc.)?  What is the syntax for defining a function in TypeScript?  How do you declare an array in TypeScript?  How do you define a parameter type in a function in TypeScript?  What are default values for function parameters in TypeScript?Medium Level:  What are the advantages of using interface over type in TypeScript?  What is the purpose of strictNullChecks in TypeScript?  Can you explain how TypeScript helps in avoiding null pointer exceptions?  What is the difference between undefined and null in TypeScript?  What is the keyof type operator in TypeScript? Provide an example.  Explain the difference between an object type and a class type in TypeScript.  How do you use readonly properties in TypeScript?  What is type widening in TypeScript? Can you give an example?  How does TypeScript handle function overloading? Provide an example.  Can you explain type inference and how it works in TypeScript?Advanced Level:  What is the purpose of generics in TypeScript? How do you implement them in functions or classes?  What is the this keyword in TypeScript, and how is its behavior different from JavaScript?  How do you use mapped types in TypeScript?  What are conditional types in TypeScript? Provide an example.  What is type narrowing, and how does TypeScript perform it?  How do you create and use custom decorators in TypeScript?  What is the never type in TypeScript? When should you use it?  Can you explain how TypeScript works with modules and namespaces?  How does TypeScript handle asynchronous programming (async/await) in terms of type safety?  What is the unknown type, and how is it different from any in TypeScript?  How can you create a union of types that only accepts a subset of values in TypeScript?  What are “advanced” types in TypeScript and how do they differ from primitive types?  How do you use declaration merging in TypeScript? Provide an example.  What is the purpose of tsconfig.json? What are some of the most commonly used options?  How can TypeScript help when working with large codebases?  What is the in operator in TypeScript, and how does it work in conjunction with type guards?  How do you declare and use abstract classes in TypeScript?  What is a construct signature in TypeScript, and when would you use it?  What are template literal types in TypeScript, and how do they work?  How do you deal with third-party libraries in TypeScript when they don’t have type definitions?"
    },
  
    {
      "title": "SSL Commands",
      "url": "/documentation/ssl-commands",
      "date": "2025-01-09",
      "content": "Generate a CA certificate:openssl genrsa -out ca.key 2048openssl req -x509 -new -nodes -key ca.key -sha256 -days 365 -out ca.crtGenerate a server certificate:openssl genrsa -out server.key 2048openssl req -new -key server.key -out server.csropenssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 365 -sha256Generate a client certificate:openssl genrsa -out client.key 2048openssl req -new -key client.key -out client.csropenssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out client.crt"
    },
  
    {
      "title": "OAuth Config Setup in Different Apps",
      "url": "/documentation/oauth-config-setup",
      "date": "2025-01-09",
      "content": "Auth AppTo study diff auth methods  Your browser does not support the video tag.NotesTable of Contents  Basic Auth  OAuth based auth  JWT token based auth  Session based auth  Passwordless auth  Open ID Connect (OIDC) based auth  mTLS based auth  Deployment  Choice of Techstack1. Basic Auth  Like Bearer Auth  Using basic-auth library  often accompanied by any other form of session/token storage to maintain session expiry2. Oauth  uses passport-google-oauth20 etc  that uses passport session to manage sessions  passport session needs express session      express session can send cookies from backend to frontned (NEEDS TO BE STUDIED. NOT SURE)          while using diff frontend andb backend hosts only if both have https      only if frontend and baclemd are on same site(using nginx proxy or setting express.static())      we are using express.static() method to access frontend files via backend [in vanilla html]            refer this for oauth apps url configurations    Tips:          use &lt;base href=\"http://localhost:8000\"&gt; in html head to avoid rewriting baseurl in html (while accessing frontend files via backend express.static()) [in case of vanilla html]      use below in nextjs avoid rewriting baseurl        async rewrites() {return [    {    source: \"/auth/:path*\", // Frontend route    destination: \"http://localhost:8000/auth/:path*\", // Backend route    },];},                    3. JWT  Redis is particularly well-suited for token blacklisting token during logout due to its speed, simplicity, and built-in expiration features. Redis is designed for low-latency operations because it stores data in memory. This makes it significantly faster than traditional disk-based databases like MongoDB or SQL.  created redis db using upstash4. Session based  Plain session based auth  It has already been used along with basic auth and oauth, but just t o study it in isolation5. Passwordless  Only for signup and signin. Verfication is through traditional jwt cookies/headers  During signin we dont use password(only email). Instead would send an otp to email and verify its expiration. And then will send the token to frontend. (an extra step like 2 factor auth)  For checking auth this token is sent via headers/stored in cookies each time for every route  To set up modemailer follow the set mentioned here https://dev.to/chandrapantachhetri/sending-emails-securely-using-node-js-nodemailer-smtp-gmail-and-oauth2-g3a  and code mentioned in claude ai code here claudeai-code.md6. OpenID Connect  We used Google as the OpenID Provider (IdP) and passport-openidconnect to help set up openid7. mTLS (Mutual Transport Layer Security) (not implemented completely cause of minor errors)  https://github.com/edum-compassuol/mTLS-nodejs-example/blob/main/server/src/server.ts  Mutual TLS (mTLS) authentication involves verifying both the client and server identities using TLS certificates.  Includes 2 steps:          creating certficated for server &amp; client      logging in after verifying the certificates (session is managed by header/cookies)        First You’ll need to create the following in a seperate folder called cert outside frotend or backend folder:          A CA certificate to sign client and server certificates.      A server certificate and private key.      A client certificate and private key.        Download ssl from https://slproweb.com/products/Win32OpenSSL.html  OpenSSL commands to create certificates in cert folder: ssl-commands.md  remember to add the folder cert/ and all the related certificate extensions as in gitignore-commands.md to gitignore before committing  If everything is configured correctly:          The server will verify the client certificate.      The client will verify the server certificate.        Common Issues          Certificate Mismatch: Ensure the client and server - certificates are signed by the same CA.      Incorrect Paths: Double-check the file paths for the keys and certificates.      Firewall/Port Issues: Ensure port 8443 is open for communication.(convetionally use port 8443 for mTLS)        Used in Banks (e.g., JPMorgan Chase, Goldman Sachs), Payment Processors (e.g., Stripe, PayPal, Square), Cloud Providers (e.g., AWS, Microsoft Azure, Google Cloud), etc  Working:          Browsers do not natively support mTLS directly due to security constraints. So we will use nextjs api to work with client certificates. (∴ cannot do directly within page.tsx)      8. Deployment  Basic typescript nodejs deployment: https://youtu.be/4mqy5SjkDec?si=rFG2Wu8NYmq-8PjD  Durig deployment, there is this whole mess. Checkout all changes I’ve made so far, all the minor fix commits to get an idea.  Express session does indeed not work with frontend and backend on diff servers.          During development it worked because the browser confused the host(localhost) of both port 8000 and 3000 as it is coming from same domain.      Added diff frontend host url as below in .env file of react to change hostname and it stopped co-operating with express-session        HOST=frontend.local                    Therefore had to serve rthe frontend build folder from backend        Render is horrible at building and starting the server by itself for frontend as well as backend (as I’ve seen so far).          Therefore I’m building the build files in both frontend and backend before commiting and pushing the build folders to github      In render I just start the backend server        Rememeber for OAuth authentication always need to update the redirect urls in case you plan to host the server in any other website.          Also update the env variables accordingly      9. Choice of Techstack  ReactJS because of not able to use express-session          NextSJ was the first choice in order to learn the techstack. But express-session was not letting me set cookies in frontend because of cross-origin. (couldnt find a simple solution in neither stackoverflow nor gpt)      So now im serving react build files directly from server      "
    },
  
    {
      "title": "OAuth/OIDC App Configurations",
      "url": "/documentation/oauth-oidc",
      "date": "2025-01-09",
      "content": "OAuth/OIDC App ConfigurationsTable of Contents  OAuth config          Google      Facebook      Twitter      Github        OIDC config          Google      OAuth ConfigurationGoogle OAuth  visit https://console.cloud.google.com/                  add project/choose project          add project                                                fill oauth consent screen. keep setting same in all. just change names wherever neccessary. fill those place that are filled                                                                                                or choose project              add credentials                      getting google api key for apps like nodemailer                                                getting google cient id and secret for oauth                                                                      adding redirect uris and source url (needs to be changed each time you change hostname or create a new deployment url)                Facebook  visit facebook developer portal https://developers.facebook.com/                  create a new app/choose existing app          create new app                                              - NOT COMPLETED BECAUSE I DONT KNO WHY BUT APP IS WORKING NO MATTER WHAT CHANGE I MAKE      Twitter                    Github                OIDC ConfigurationGoogle OIDC  follow all same steps as in google oauth, except the last step - just callback url is different                "
    },
  
    {
      "title": "Gitignore Config for Certificates",
      "url": "/documentation/gitignore-commands",
      "date": "2025-01-09",
      "content": "# config specific to the language or editor you use# Ignore certificate and key files*.key*.crt*.csr*.pem*.p12*.der*.srl# Ignore any directory containing certs or keyscerts/keys/secrets/"
    },
  
    {
      "title": "Claude AI Code for Nodemailer",
      "url": "/documentation/claudeai-code",
      "date": "2025-01-09",
      "content": "import express from \"express\";import { google } from \"googleapis\";import { OAuth2Client } from \"google-auth-library\";import nodemailer from \"nodemailer\";import Mail from \"nodemailer/lib/mailer\";import SMTPTransport from \"nodemailer/lib/smtp-transport\";import {  google_client_id,  google_client_secret,  google_refresh_token,  senders_gmail,} from \"../config/constants\";const router = express.Router();interface OTPRequest {  email: string;}const createTransporter = async (): Promise&lt;nodemailer.Transporter&gt; =&gt; {  try {    const oauth2Client = new OAuth2Client(      google_client_id,      google_client_secret,      \"https://developers.google.com/oauthplayground\"    );    oauth2Client.setCredentials({      refresh_token: google_refresh_token,    });    const accessToken = await oauth2Client.getAccessToken();    // Properly type the SMTP transport options    const transportOptions: SMTPTransport.Options = {      host: 'smtp.gmail.com',      port: 465,      secure: true,      auth: {        type: \"OAuth2\",        user: senders_gmail,        clientId: google_client_id,        clientSecret: google_client_secret,        refreshToken: google_refresh_token,        accessToken: accessToken.token || undefined,      },    };    const transporter = nodemailer.createTransport(transportOptions);    // Verify transporter configuration    await transporter.verify();    return transporter;  } catch (error) {    console.error(\"Error creating transporter:\", error);    throw new Error(\"Failed to create email transporter\");  }}async function sendEmail(to: string, otp: string): Promise&lt;void&gt; {  try {    const transporter = await createTransporter();        const mailOptions: Mail.Options = {      from: `\"Auth Service\" &lt;${senders_gmail}&gt;`,      to,      subject: \"Passwordless Authentication OTP\",      text: `Your OTP for authentication is: ${otp}`,      html: `        &lt;h2&gt;Authentication OTP&lt;/h2&gt;        &lt;p&gt;Use the following OTP to log in:&lt;/p&gt;        &lt;h3 style=\"color: #4CAF50; font-size: 24px;\"&gt;${otp}&lt;/h3&gt;        &lt;p&gt;This OTP will expire in 10 minutes.&lt;/p&gt;        &lt;p&gt;If you didn't request this OTP, please ignore this email.&lt;/p&gt;      `,    };    await transporter.sendMail(mailOptions);  } catch (error) {    console.error(\"Error sending email:\", error);    throw new Error(\"Failed to send email\");  }}router.post(\"/sendOTP\", async (req: express.Request&lt;{}, {}, OTPRequest&gt;, res: express.Response) =&gt; {  try {    const { email } = req.body;        if (!email) {      return res.status(400).json({         error: \"Email is required\"       });    }    // Validate email format    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;    if (!emailRegex.test(email)) {      return res.status(400).json({         error: \"Invalid email format\"       });    }    const otp = Math.floor(100000 + Math.random() * 900000).toString();        // Send email    await sendEmail(email, otp);    res.status(200).json({       success: true,      message: \"OTP sent successfully\"     });  } catch (error) {    console.error(\"Error in /sendOTP:\", error);    res.status(500).json({       error: \"Failed to send OTP\"     });  }});export default router;"
    },
  
    {
      "title": "Guidelines to cleaner git commits",
      "url": "/documentation/git-commit-guidelines",
      "date": "2024-10-31",
      "content": "Guidelines to cleaner git commitsStandardized documentation followed for cleaner git commits  Conventional Commit (Standard one)  Commit messages guide (Simplified one - found it useful)  Add emojis in git commits (For personal ones)To integrate git commit message helper to vs-code      via cli          commitizen-cli documentation              Method:                  npm i -g commitizen-cli in vscode terminal          to use either commitizen-cli or npx commitizen-cli (to skip first step)          then follow terminal guidelines                          vscode extension: not developed yet  Git commit practices (pulling, pushing in new branch, squash etc)  https://trunkbaseddevelopment.com/  https://profy.dev/ - website to practise git and agile"
    },
  
    {
      "title": "API Documentation Tools",
      "url": "/documentation/api-documentaion",
      "date": "2024-10-31",
      "content": "Api Documentaion ToolsFollowing are the api documentation tools that helps you create api docs in pretty websites.🔨Tools that can be used (Tried so far):  Redocs : Free and Good UI  Swagger: Free but little confusing UI  Postman: Free but bland UI      Common Docs                  Redoc and Swagger                  swagger(openapi) specification docs: https://swagger.io/specification/          example swagger(openapi) yaml code: https://github.com/Redocly/redoc/blob/main/demo/openapi-3-1.yaml          example swagger(openapi) json code: https://github.com/Redocly/redoc/blob/main/demo/big-openapi.json          exmaple website github: https://github.com/Redocly/redoc/blob/main/demo/museum.yaml          example website: https://redocly.github.io/redoc/          my own repo: https://github.com/Anusree6154s/qkart-backend-2                            Postman                  example api doc: https://www.postman.com/lunar-module-geoscientist-23775876/xflix-backend-api/collection/6wogu2r/xflix?action=share&amp;creator=33572999          above example is intuitive. follow it for other postman docs                          How to create documentaion right from the server                  Redoc              Using CDN  - In app.js  ```js  const express = require(\"express\");  const app = express();  const PORT=8082 // put your port here  app.use((req, res, next) =&gt; {      // Set Content Security Policy for running redocly via cdn      res.header(\"Content-Security-Policy\", \" script-src-elem 'self' https://cdn.redoc.ly;\");      next();  app.get('/swagger.json', (req, res) =&gt; {      // will be called when spec-url='/swagger.json' executes in docs.html      res.sendFile(path.join(__dirname, '/documentation/swagger.json'));  });  app.use('/docs', (req, res) =&gt; {      // will be called when this route will be accessed (http://localhost:PORT/docs)      res.sendFile(path.join(__dirname, 'html-docs.html'));  });  app.listen(PORT)  ```  - Make a file named swagger.js or openapi.js. In that file create a yaml or json content by referring to these docs:  - https://swagger.io/specification/  - https://github.com/Redocly/redoc/blob/main/demo/openapi-3-1.yaml  - https://github.com/Redocly/redoc/blob/main/demo/big-openapi.json  - Create a docs.html and copy the code below:  ```html  &lt;!DOCTYPE html&gt;            API Documentation                            ```  - Run `node app.js` in terminal. Api documentation will be live on url `http://localhost:8082/docs`              Using NPM package  - create swagger.js or openapi.js using above mentioned files- In app.js  ```js  const express = require(\"express\");  const app = express();  const PORT = 8082;  app.use(\"/docs\", (req, res) =&gt; {    // will be called when this route will be accessed (http://localhost:PORT/docs)    res.sendFile(path.join(__dirname, \"docs.html\"));  });  app.listen(PORT);  ```- in terminal run `npx @redocly/cli build-docs swagger.json --output docs.html` , then `node app.js`.- Api documentation will be live on url `http://localhost:8082/docs`                  Swagger                  using npm package                  in app.js            const express = require(\"express\");const app = express();const PORT = 8082; // put your port hereapp.get(\"/swagger.json\", (req, res) =&gt; {  // will be called when spec-url='/swagger.json' executes in docs.html  res.sendFile(path.join(__dirname, \"/documentation/swagger.json\"));});app.use(\"/docs\", (req, res) =&gt; {  // will be called when this route will be accessed (http://localhost:PORT/docs)  res.sendFile(path.join(__dirname, \"html-docs.html\"));});app.listen(PORT);                                in swagger.json or openapi.json, write content referring to previous docs          Api documentation will be live on url http://localhost:8082/docs                            using cdn: dont know yet              [!NOTE] &gt; Tips while using redocly      authorization error: add that url into res.header in app.js    error adding logo: add logo to your own repo, create a route for it, place that routed url in img srcrefer my own docs for eg: https://github.com/Anusree6154s/qkart-backend-2  📃 Total list of tools from gpt1. Postman  Overview: Postman is widely used for API development and testing, but it also provides features to generate and host API documentation.  Key Features:          Auto-generate documentation from collections.      Easy collaboration and sharing of documentation with team members.      Can publish documentation online or integrate with CI/CD pipelines.        Documentation Example: Postman allows you to document your API requests, responses, and workflows directly within your collections. You can then share the documentation via a public or private URL.  Website: Postman API Docs2. Redoc  Overview: Redoc is an open-source tool that renders OpenAPI (Swagger) specifications as rich and customizable HTML documentation.  Key Features:          Provides a clean and intuitive UI for API docs.      Easy to integrate into existing applications.      Supports OpenAPI 2.0 and 3.0.      The appearance of the docs can be customized to fit your branding.        Use Case: Often used as a standalone documentation renderer for OpenAPI specs.  Website: Redoc3. Slate  Overview: Slate is an open-source tool for generating beautiful, static API documentation.  Key Features:          Features three-pane design (navigation, request, and response sections).      Static site generator — docs are hosted as simple static HTML.      Markdown-based, so easy to write and maintain documentation.      Good for read-only API docs.        Use Case: Good for organizations that want static, easy-to-read documentation, and don’t need interactive API testing directly in the docs.  Website: Slate4. Apiary  Overview: Apiary, now part of Oracle, is a platform for designing, documenting, and testing APIs.  Key Features:          Supports API Blueprint (a markdown-like language for describing APIs) and OpenAPI.      Provides mock servers, documentation generation, and testing capabilities.      Collaborative design features, letting teams work on API specs together.      Hosted, so no need for infrastructure setup.        Use Case: Useful for teams who want an all-in-one solution for API design, mockups, and documentation.  Website: Apiary5. RapiDoc  Overview: RapiDoc is another OpenAPI renderer, like Redoc, that generates interactive and beautiful API documentation.  Key Features:          Fast and simple, optimized for performance.      Allows real-time API request testing directly from the documentation.      Fully customizable to match the branding of your application.        Use Case: Great for users looking to customize their API documentation with real-time testing capabilities.  Website: RapiDoc6. Docusaurus with API Docs Plugin  Overview: Docusaurus is a static site generator designed for documentation websites. Using plugins, it can also support API documentation.  Key Features:          React-based static site generator.      Easily extendable with plugins to handle API documentation.      Flexible and customizable documentation sites, supporting markdown and custom layouts.        Use Case: Great for companies or projects that need a full documentation website with an API section.  Website: Docusaurus7. Docz  Overview: Docz is a documentation tool for building beautiful and interactive API docs using MDX (a mix of Markdown and JSX).  Key Features:          Highly customizable and developer-friendly.      Interactive components (since it supports JSX).      Great for documenting components and APIs in React-based projects.        Use Case: Ideal for projects that need interactive documentation, especially in the context of React or component-based libraries.  Website: Docz8. Sphinx  Overview: Sphinx is a Python documentation generator, but it can be extended to document APIs using plugins such as sphinxcontrib-httpdomain.  Key Features:          Markdown and reStructuredText support.      Highly customizable via extensions.      Many plugins are available, including ones for API documentation.        Use Case: Often used for documenting Python projects but can be extended to other languages or APIs.  Website: Sphinx9. ReDocly  Overview: ReDocly (built on top of Redoc) is a premium solution for API documentation, offering extra features like linting, versioning, and monetization.  Key Features:          API documentation hosting with version control.      Linter for OpenAPI specifications.      Full-text search across API docs.        Use Case: Enterprise-level documentation solution for teams looking for a more comprehensive suite than Redoc.  Website: ReDocly10. Spectacle  Overview: Spectacle is an API documentation tool built on top of OpenAPI.  Key Features:          Simple and easy to set up.      Provides good visualization for OpenAPI documentation.      Can be used as a standalone documentation tool or embedded into a project.        Use Case: Good for teams using OpenAPI and looking for an alternative to Swagger UI.  Website: Spectacle11. Restlet Studio  Overview: A full-featured API development platform, Restlet Studio offers API design, testing, and documentation.  Key Features:          API designer and documentation generator.      Automatically generates interactive docs.      Supports OpenAPI and RAML.        Use Case: Useful for teams looking for a visual interface to manage API design and documentation.  Website: Restlet StudioPlease enable JavaScript to view the comments powered by Disqus."
    },
  
    {
      "title": "Readme files writing guide",
      "url": "/documentation/readme-file-writing",
      "date": "2024-10-26",
      "content": "Comprehensive Guide to Writing README Files1. Project Title  What to Include: The name of the project.  How to Format: Use a prominent heading (e.g., # Project Title).  Example:    # My Amazing Project      2. Description  What to Include: A brief overview of what the project does, its purpose, and its key features.  How to Format: Write a few sentences or a short paragraph.  Example:    My Amazing Project is a web application that helps users manage their tasks effectively. With features like task creation, deadline tracking, and file uploads, it simplifies task management for individuals and teams.      3. Table of Contents  What to Include: A list of sections in the README for easy navigation.  How to Format: Use links to section headings.  Example:```markdown    Table of Contents          Installation      Usage      Features      Contributing      License```      4. Installation  What to Include: Step-by-step instructions on how to set up the project locally. This can include prerequisites, dependencies, and installation commands.  How to Format: Use code blocks for commands and list steps clearly.  Example:    ## InstallationTo install and set up the project, follow these steps:1. Clone the repository:   ```bash   git clone https://github.com/username/my-amazing-project.git              Navigate to the project directory:        cd my-amazing-project                    Install dependencies:        npm install                ```            5. Usage  What to Include: Instructions on how to use the project after installation. Include examples and screenshots if applicable.  How to Format: Use code snippets and images to clarify usage.  Example:    ## UsageTo start the application, run the following command:```bashnpm start        Once the application is running, open your web browser and navigate to http://localhost:3000.        Example of Adding a Task          Click on the “Add Task” button.      Fill in the task details and click “Save”.```      6. Features  What to Include: A list of key features or functionalities of the project.  How to Format: Use bullet points or a numbered list.  Example:```markdown    Features          Create and manage tasks      Set deadlines and reminders      Upload files related to tasks      Mark tasks as done```      7. Contributing  What to Include: Guidelines for contributing to the project, such as how to report issues, request features, or submit pull requests.  How to Format: Clearly outline the process.  Example:    ## ContributingWe welcome contributions! To contribute, please follow these steps:1. Fork the repository.2. Create a new branch:   ```bash   git checkout -b feature/YourFeature              Make your changes and commit them.      Push to the branch:        git push origin feature/YourFeature                    Submit a pull request.```      8. License  What to Include: Information about the project’s license, including a link to the full license text.  How to Format: Mention the type of license and link to the LICENSE file.  Example:    ## LicenseThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.      9. Acknowledgments  What to Include: Acknowledge any libraries, frameworks, or resources that were helpful in developing the project.  How to Format: List the acknowledgments in bullet points.  Example:```markdown    Acknowledgments          React - A JavaScript library for building user interfaces.      MUI - React components for faster and easier web development.```      10. Badges (Optional)  What to Include: Badges for build status, coverage, npm version, etc.  How to Format: Use Markdown to add badges at the top of the README.  Example:    ![Build Status](https://img.shields.io/badge/build-passing-brightgreen)![npm version](https://img.shields.io/npm/v/npm.svg)      11. FAQ (Optional)  What to Include: Common questions and answers related to the project.  How to Format: List questions and their answers in a clear manner.  Example:    ## FAQ**Q: Can I use this project for commercial purposes?**A: Yes, you can use it as long as you comply with the license terms.**Q: Is there a demo available?**A: A live demo can be found at [Demo Link](https://example.com).      12. Contact Information (Optional)  What to Include: How users or contributors can reach out with questions or suggestions.  How to Format: Provide your email or link to a contact form.  Example:    ## ContactFor questions or suggestions, feel free to reach out to me at [your-email@example.com](mailto:your-email@example.com).      Best Practices  Clarity and Brevity: Be clear and concise in your descriptions. Avoid jargon unless necessary.  Markdown Formatting: Use Markdown syntax effectively to format your README for better readability.  Update Regularly: Keep your README updated with any changes in the project, features, or installation instructions.  Include Visuals: Use screenshots, diagrams, or GIFs to illustrate how the project works.Example README TemplateHere’s a simple template based on the structure outlined above:# Project TitleA brief description of what the project does and its purpose.## Table of Contents- [Installation](#installation)- [Usage](#usage)- [Features](#features)- [Contributing](#contributing)- [License](#license)- [Acknowledgments](#acknowledgments)## Installation1. Clone the repository:   ```bash   git clone https://github.com/username/my-amazing-project.git  Navigate to the project directory:    cd my-amazing-project        Install dependencies:    npm install      UsageTo start the application, run the following command:npm startOpen your web browser and navigate to http://localhost:3000.Features  List of features here.Contributing  Fork the repository.  Create a new branch.  Make your changes and commit them.  Push to the branch and submit a pull request.LicenseThis project is licensed under the MIT License - see the LICENSE file for details.Acknowledgments  Libraries or resources used in the project.```"
    },
  
    {
      "title": "Git Commit Standards",
      "url": "/documentation/git -commit-standards",
      "date": "2024-10-26",
      "content": "git cheat sheet: https://media.licdn.com/dms/image/v2/D4D22AQFWkWeD6D4ksA/feedshare-shrink_1280/feedshare-shrink_1280/0/1729225766763?e=1732147200&amp;v=beta&amp;t=lRJJDZeffcMU0rbvRJi0oSef2p3xGOG9BQWXG9dhrTQExample Commit Messagefeat(task-manager): add task sorting featureImplement a new feature that allows users to sort tasks by their deadlines. This improvement enhances user experience by enabling better task management.Breakdown of the Commit Message  Type:          feat: This indicates that a new feature has been added to the project.        Scope:          (task-manager): This specifies the part of the codebase that the change affects, which is the task manager component.        Description:          add task sorting feature: A brief summary of what was done. It’s clear and to the point.        Body (optional):          The body provides additional context about the change. Here, it describes what the new feature does and its benefits.      Other ExamplesBug Fixfix(task-table): resolve table sorting bugFix an issue where tasks were not sorting correctly when the user clicked the header. This resolves discrepancies in the task display order.Documentation Updatedocs: update README with setup instructionsRevise the README to include step-by-step setup instructions for new contributors, improving accessibility to the project.Style Changestyle(TaskModal): adjust button alignmentChange the alignment of the buttons in the TaskModal component to improve the visual layout without affecting functionality.Refactorrefactor(file-upload): simplify file validation logicRefactor the file validation logic in the FileUpload component to make it more readable and maintainable without changing the behavior.Test Additiontest(task-service): add unit tests for createTask functionAdd unit tests for the createTask function to ensure that it handles various input scenarios correctly.Chorechore: update dependenciesUpdate project dependencies to their latest versions to improve security and performance.SummaryBy following this structured format, your commit messages become more informative and standardized, making it easier for collaborators and contributors to understand the changes made to the codebase."
    },
  
    {
      "title": "Readme files formatting guide",
      "url": "/documentation/readme-formatting-guidelines",
      "date": "2024-10-23",
      "content": "Readme Formatting Guidelines/Rules  Majority guidelines  Image alignment/resize guidelinesGithub readme formatting styles put together by me - Read more in wiki"
    },
  
    {
      "title": "Takehome Guidelines",
      "url": "/documentation/takehome-guidelines",
      "date": "2024-10-23",
      "content": "Take home coding challengeReadmeWrite your README as if it was for a production service. Include the following items:  Description of the problem and solution.  Whether the solution focuses on back-end, front-end or if it’s full stack.  Reasoning behind your technical choices, including architectural.  Trade-offs you might have made, anything you left out, or what you might do differently if you were to spend additional time on the project.How we reviewYour application will be reviewed by at least two of our engineers. We do take into consideration your experience level.We value quality over feature-completeness. It is fine to leave things aside provided you call them out in your project’s README. The goal of this code sample is to help us identify what you consider production-ready code. You should consider this code ready for final review with your colleague, i.e. this would be the last step before deploying to production.The aspects of your code we will assess include:  Architecture: how clean is the separation between the front-end and the back-end?  Clarity: does the README clearly and concisely explains the problem and solution? Are technical tradeoffs explained?  Correctness: does the application do what was asked? If there is anything missing, does the README explain why it is missing?  Code quality: is the code simple, easy to understand, and maintainable?  Are there any code smells or other red flags? Does object-oriented code follows principles such as the single responsibility principle? Is the coding style consistent with the language’s guidelines? Is it consistent throughout the codebase?  Security: are there any obvious vulnerability?  Technical choices: do choices of libraries, databases, architecture etc. seem appropriate for the chosen application?Bonus point (those items are optional):  UX: is the web interface understandable and pleasing to use? Is the API intuitive?  Scalability: will technical choices scale well? If not, is there a discussion of those choices in the README?  Production-readiness: does the code include monitoring? logging? proper error handling?My personal notes on thisFormat  Project Name          Description                  Problem Description          Solution Description (backend, frontend, or full-stack)                    Approach                  Technology Stack (and reasons for choosing them)          Architecture          Features Implemented                    Trade-offs &amp; Improvements      Future Improvements      How to run      Demo image/gif/video      Format in detail  Project Name          Description                  Problem Description: This project solves [problem description] by addressing [specific pain points], such as improving [performance, scalability, user experience, etc.].          Solution Description: This is a [backend, frontend, or full-stack] solution using [technology stack] to tackle the identified problem.                    Approach                  Technology Stack (and Reasons for Choosing Them)                          Front-end: [React, Vue, etc.] - Chosen for its scalability and reusable components.              Back-end: [Node.js, Python, etc.] - Selected for its asynchronous processing capabilities.              Database: [PostgreSQL, MongoDB, etc.] - Picked for [structured/unstructured] data handling.              Tools: [Docker, CI/CD tools, etc.] - Used for deployment and containerization to ensure consistency across environments.                                Architecture                          The solution uses a [RESTful/Microservice] architecture with:                                  API Layer: Routes requests to services.                  Business Logic: Processes core operations like authentication, payments, etc.                  Database Layer: Manages data storage and retrieval.                                                              Features Implemented                          User Authentication: Secure sign-up, login, and session management.              Product Listings: Display dynamic product data from the database.              Shopping Cart: Add, remove, and view items in a cart with real-time updates.              Checkout Process: Integration with payment gateways to complete purchases.                                          Trade-offs &amp; Improvements                  Performance vs. Flexibility: Opted for flexibility at the expense of some performance optimization.          Initial Simplicity: Chose lightweight frameworks to facilitate rapid development, leaving room for future improvements.          Testing: Focused testing on core logic, with plans to implement more extensive end-to-end tests.                    Future Improvements                  Expand test coverage to include UI and integration testing.          Transition to microservices for improved scalability and fault isolation.          Improve CI/CD pipeline with better monitoring and automation tools.                    How to Run                  Clone the repo:            git clone https://github.com/yourusername/project.git                                Install dependencies:            npm install                                Run the server:            npm run dev                                          Demo Image/GIF/Video                  image                    ExampleLong version      eCommerce Frontend                  Description                  Problem Description: Many online stores lack modern, responsive, and performant user interfaces. This eCommerce application frontend aims to provide users with a seamless and intuitive shopping experience across devices.          Solution Description: This is a frontend solution built using React to create a dynamic and responsive user interface. The app improves user experience, enhances performance, and ensures scalability for future feature extensions.                            Approach                              Technology Stack (and Reasons for Choosing Them)                          Front-end: React – Chosen for its component-based architecture and excellent support for dynamic, state-driven UIs. React also allows easy integration of third-party libraries for UI elements.              State Management: Redux – Used to manage global state across the application, such as the user’s shopping cart, to ensure consistency and performance.              Styling: Tailwind CSS – A utility-first CSS framework that speeds up development while maintaining design consistency.              Routing: React Router – Implemented for navigation between pages, enabling smooth transitions between product listings, cart, and checkout pages.              Tools: Webpack &amp; Babel – Used for bundling and transpiling the JavaScript code for optimized performance in production.                                            Architecture                          The frontend follows a component-based architecture where each page and UI element is encapsulated into reusable React components:              Product Listing Page: Dynamically fetches product data and displays it in a grid layout with filters and sorting options.              Product Detail Page: Provides detailed information about a selected product, including images, descriptions, and reviews.              Shopping Cart: Displays the selected items, allowing users to modify quantities or remove items in real-time using state management (Redux).              Checkout Page: Guides users through the purchase process, integrating payment gateway UI elements.                                            Features Implemented                          Product Browsing: Displays a catalog of products with filtering (by category, price) and sorting (by popularity, price).              Product Search: A search bar allows users to quickly find specific products.              Shopping Cart: Users can add items to their cart, update quantities, and view a live total of the purchase.              Responsive Design: The layout adapts seamlessly across desktop, tablet, and mobile devices.              User Authentication: Integrated login/logout functionality, with access to personalized features like saved shopping carts.                                                  Trade-offs &amp; Improvements                  Performance vs. Features: Initial focus was on ensuring core eCommerce features like browsing and cart functionality, with performance optimizations to follow.          Custom Design vs. Framework: Opted for Tailwind CSS to speed up development and ensure design consistency, but custom styling may be introduced in future iterations.          Testing: Basic unit tests are implemented, but end-to-end testing for the entire user journey is a future goal.                            Future Improvements                  Improve performance by lazy-loading components and implementing server-side rendering (SSR) with Next.js.          Add more comprehensive tests using tools like Cypress for end-to-end testing.          Integrate with more third-party APIs for recommendations, reviews, and payment processing.          Implement localization and internationalization (i18n) to support multiple languages and regions.                            How to Run                  Clone the repo:            git clone https://github.com/yourusername/ecommerce-frontend.git                                Install dependencies:            npm install                                Run the server:            npm start                        The application will run on http://localhost:3000.                                      Demo Image/GIF/Video                  Here’s a preview of the eCommerce frontend in action:                                                          Or a demo of the user adding products to the cart:                                                                    Short version      eCommerce Frontend                  Description                  Problem: Many online stores lack modern, responsive interfaces.          Solution: A React-based frontend that enhances user experience, performance, and scalability for a seamless shopping experience.                            Approach                              Technology Stack                          Front-end: React for a dynamic UI.              State Management: Redux for managing the global state.              Styling: Tailwind CSS for rapid, consistent design.              Routing: React Router for smooth page transitions.              Build Tools: Webpack &amp; Babel for optimized performance.                                            Architecture                          Component-Based: Each UI element is a reusable component, including:                                  Product Listing: Displays products with filters and sorting.                  Product Detail: Detailed view of selected products.                  Shopping Cart: Real-time updates on item quantities and totals.                  Checkout Page: Guides users through the purchase process.                                                                          Features                          Product Browsing: Catalog with filtering and sorting.              Search Functionality: Quickly find products.              Responsive Design: Adapts to all devices.              User Authentication: Login/logout functionality.                                                  Trade-offs &amp; Improvements                  Focused on core features over performance; optimizations will follow.          Basic testing is in place; end-to-end tests are planned.                            Future Improvements                  Implement lazy loading and SSR with Next.js.          Enhance testing coverage.          Add localization support.                            How to Run                  Clone the repo:            git clone https://github.com/yourusername/ecommerce-frontend.git                                Install dependencies:            npm install                                Run the server:            npm start                        Access the application at http://localhost:3000.                                      Demo                            Or a demo of adding products to the cart:                                [!NOTE]can take demo and deployemnt urls to the top instead of bottom, just below the title for quicker access"
    },
  
    {
      "title": "Email Service Guide",
      "url": "/documentation/email-service",
      "date": "2024-10-22",
      "content": "From Frontend  EmailJS: https://github.com/emailjs-com/emailjs-sdkFrom backend  EmailJS :https://github.com/emailjs-com/emailjs-sdk  Nodemailer"
    },
  
    {
      "title": "Deployment Websites",
      "url": "/documentation/deployment",
      "date": "2024-09-21",
      "content": "netlify:  using netlify-cli for cli, can do from portal too  only for static websites  can do for private gitlab instances (along with github, gitlab, etc) (so from crio cli for static websites)  can do for webservers too but require to do using serverless-http which didnt work right for me (methods exist in internet)render  using cli is paid, portal is free  specially for webservers  cannot do for private gitlab instances (so not from crio cli)"
    },
  
    {
      "title": "React-Node App",
      "url": "/documentation/react-node",
      "date": "2024-08-19",
      "content": "Concepts related to React-Node Web AppTable of Contents  Approx File Organisation Template for React-Node Web App  CI  How to Set Up CI  Why Do We Need CI  Writing JSDocs for backend and frontendApprox File Organisation Template for React-Node Web AppOrganizing a project with both client-side and server-side code requires a structured approach to ensure maintainability, scalability, and clarity. Here’s a comprehensive folder structure for a project that includes client-side (React) and server-side (Node.js/Express) code, with folders for services, utilities, middlewares, and tests.Suggested Folder Structureproject-root/│├── client/                 # React frontend application│   ├── public/              # Public assets│   ├── src/                 # Source files│   │   ├── assets/          # Images, fonts, etc.│   │   ├── components/      # Reusable components│   │   ├── pages/           # Page components or views│   │   ├── services/        # API service functions│   │   ├── utils/           # Utility functions│   │   ├── hooks/           # Custom React hooks│   │   ├── contexts/        # React context providers│   │   ├── styles/          # Global styles and CSS modules│   │   ├── App.js           # Main application component│   │   ├── index.js         # Entry point for React app│   │   └── ...              # Other frontend-specific files│   ├── .env                 # Environment variables for frontend│   ├── package.json         # Frontend dependencies and scripts│   └── README.md            # Frontend documentation│├── server/                 # Node.js/Express backend application│   ├── config/             # Configuration files (e.g., database, JWT)│   ├── controllers/        # Route handlers│   ├── middlewares/        # Express middlewares (e.g., authentication, logging)│   ├── models/             # Database models│   ├── routes/             # API route definitions│   ├── services/           # Business logic and external service integration│   ├── utils/              # Utility functions│   ├── validators/         # Request validation schemas│   ├── tests/              # Unit and integration tests│   │   ├── unit/           # Unit tests│   │   ├── integration/    # Integration tests│   │   └── ...             # Other test types or configurations│   ├── app.js              # Main application entry point│   ├── server.js           # Server setup and initialization│   ├── .env                # Environment variables for backend│   ├── package.json        # Backend dependencies and scripts│   └── README.md           # Backend documentation│├── .gitignore              # Git ignore file├── docker-compose.yml      # Docker Compose configuration (if using Docker)└── README.md               # Project overview and setup instructionsExplanationClient Folder (client/)  public/: Contains static assets like index.html, favicon, and static images.  src/:          assets/: For static files like images and fonts.      components/: Reusable UI components.      pages/: Components representing pages or views.      services/: Functions for making API calls and interacting with backend services.      utils/: Utility functions and helpers.      hooks/: Custom React hooks.      contexts/: React context providers for state management.      styles/: Global styles, CSS modules, and theme settings.      App.js: Main component that wraps the entire application.      index.js: Entry point for the React application.      Server Folder (server/)  config/: Configuration files for database connections, environment variables, and other settings.  controllers/: Functions that handle requests and responses.  middlewares/: Custom Express middleware (e.g., for authentication or logging).  models/: Database schemas and models.  routes/: Definitions of API routes and their associated controllers.  services/: Business logic and integrations with external services.  utils/: Utility functions and helpers.  validators/: Request validation schemas using libraries like Joi.  tests/:          unit/: Unit tests for individual components or functions.      integration/: Integration tests that involve multiple components or services.        app.js: Main application logic.  server.js: Server initialization and startup script.Additional Considerations  Testing: You might also include separate folders for different types of tests (unit, integration) and potentially mock data if required.  Docker: If using Docker, you can include a docker-compose.yml file for defining multi-container applications.  Documentation: Each section should include its own README.md for specific instructions and details.This structure will help maintain a clean separation between client-side and server-side code, making it easier to manage and scale your application.2. CIContinuous Integration (CI) is a development practice where code changes are automatically tested and integrated into the shared repository multiple times a day. This practice helps in maintaining the quality and consistency of the codebase throughout the development process. Here’s a breakdown of CI:Key Aspects of Continuous Integration (CI)  Frequent Integration:          Developers regularly merge their code changes into a shared repository, often multiple times a day.      This frequent integration helps in identifying issues early, reducing integration problems.        Automated Testing:          Every code change triggers automated tests to verify that the new code does not break existing functionality.      Tests can include unit tests, integration tests, and end-to-end tests.        Automated Builds:          CI systems automatically build the application with every code change.      This ensures that the application compiles and runs correctly in an automated environment.        Immediate Feedback:          Developers receive immediate feedback about the health of the application after integrating their changes.      CI tools provide reports on test results, build status, and potential issues.        Version Control Integration:          CI systems are integrated with version control systems (e.g., Git) to monitor code changes and trigger automated processes.        Consistency:          CI helps maintain a consistent codebase by ensuring that all code changes are tested and built in the same environment.      Benefits of Continuous Integration  Early Detection of Issues: Bugs and integration problems are identified and fixed early in the development process.  Improved Code Quality: Regular testing and integration ensure that code quality remains high.  Faster Development Cycle: Automated processes streamline the development cycle, leading to faster releases.  Enhanced Collaboration: Regular integration helps developers stay aligned and reduces conflicts between code changes.Popular CI Tools  Jenkins: An open-source automation server that supports building, deploying, and automating any project.  Travis CI: A cloud-based CI service that integrates with GitHub and automates testing and deployment.  CircleCI: A cloud-based CI/CD platform that automates the build, test, and deployment processes.  GitHub Actions: Integrated into GitHub, it allows automation of workflows directly within the repository.  GitLab CI: Part of GitLab, providing integrated CI/CD pipelines within the GitLab ecosystem.Example Workflow  Code Commit: A developer commits code changes to the version control system.  CI Trigger: The CI system detects the commit and triggers an automated build and test process.  Build and Test: The CI system builds the application and runs tests to verify the code changes.  Feedback: The CI system provides feedback on the build and test results, highlighting any issues.  Integration: If the tests pass, the code changes are integrated into the main codebase. If issues are found, the developer is notified to address them.By incorporating CI into your development process, you can enhance the quality, reliability, and efficiency of your software projects.3. How to setup CISetting up Continuous Integration (CI) involves configuring a CI tool to automatically build, test, and sometimes deploy your application whenever changes are made to the codebase. Here’s a general guide on how to set up CI using a popular CI tool, such as GitHub Actions, Jenkins, Travis CI, or CircleCI:1. Choose a CI ToolChoose a CI tool that best fits your needs. Popular options include:  GitHub Actions: Integrated into GitHub repositories.  Jenkins: An open-source automation server.  Travis CI: Cloud-based and integrates well with GitHub.  CircleCI: Cloud-based with extensive integration capabilities.2. Set Up Your CI ToolGitHub Actions  Create a Workflow File:          In your GitHub repository, create a directory named .github/workflows/.      Inside this directory, create a YAML file (e.g., ci.yml) for defining your CI workflow.        Define the Workflow:          Here’s an example of a basic GitHub Actions workflow for a Node.js application:        name: CIon:  push:    branches:      - main  pull_request:    branches:      - mainjobs:  build:    runs-on: ubuntu-latest    steps:      - name: Checkout code        uses: actions/checkout@v2      - name: Set up Node.js        uses: actions/setup-node@v2        with:          node-version: '14'      - name: Install dependencies        run: npm install      - name: Run tests        run: npm test        Push Changes:          Commit and push the workflow file to your repository. GitHub Actions will automatically pick it up and run the defined tasks.      Jenkins  Install Jenkins:          Follow the instructions on the Jenkins website to install Jenkins on your server or use a Jenkins cloud service.        Create a New Job:          Open Jenkins and click on “New Item.”      Choose “Freestyle project” or “Pipeline” depending on your needs.        Configure the Job:          Source Code Management: Configure your repository URL and credentials.      Build Triggers: Set up triggers like “GitHub hook trigger for GITScm polling” for automatic builds.      Build Steps: Add build steps to execute commands (e.g., shell commands for testing).        Add Post-Build Actions:          Configure actions like archiving test results or deploying artifacts.        Save and Build:          Save the configuration and start a build. Jenkins will execute the configured steps and provide feedback.      Travis CI  Create a .travis.yml File:          In the root of your repository, create a .travis.yml file.        Define the Build Process:          Here’s an example configuration for a Node.js application:        language: node_jsnode_js:  - \"14\"script:  - npm install  - npm test        Enable Travis CI:          Sign in to Travis CI with your GitHub account and enable the repository.        Push Changes:          Commit and push the .travis.yml file to your repository. Travis CI will automatically start the build process.      CircleCI  Create a .circleci/config.yml File:          In the root of your repository, create a .circleci/config.yml file.        Define the Configuration:          Here’s an example configuration for a Node.js application:        version: 2.1jobs:  build:    docker:      - image: circleci/node:14    steps:      - checkout      - run:          name: Install dependencies          command: npm install      - run:          name: Run tests          command: npm testworkflows:  version: 2  build:    jobs:      - build        Sign Up and Configure:          Sign up for CircleCI and link your repository.        Push Changes:          Commit and push the configuration file to your repository. CircleCI will automatically start the build process.      3. Monitor and Maintain  Review Build Status: Monitor the CI dashboard for build results and issues.  Update Configuration: Adjust your CI configuration as needed for new dependencies, test cases, or deployment steps.  Fix Failures: Address any build or test failures promptly to maintain code quality.By following these steps, you can set up a CI pipeline that will automate the testing and integration process, improving the reliability and efficiency of your development workflow.4. Why do we need CIContinuous Integration (CI) is essential for several reasons, particularly in modern software development practices. Here’s why CI is important:1. Early Detection of Issues  Frequent Testing: CI automates the process of testing code changes as soon as they are committed, which helps in catching issues early. This reduces the likelihood of bugs accumulating over time and being discovered late in the development cycle.2. Improved Code Quality  Consistent Testing: Regular and automated testing ensures that new code does not break existing functionality, leading to a more stable and reliable codebase.  Code Review: CI systems often include linting and formatting checks, ensuring code quality and consistency.3. Faster Development Cycle  Automated Builds and Tests: CI automates the build and test processes, which speeds up development and allows developers to focus on writing code rather than manually managing builds and tests.  Quick Feedback: Immediate feedback on code changes helps developers address issues faster and iterate more quickly.4. Reduced Integration Problems  Frequent Integration: By integrating code changes multiple times a day, CI reduces the risk of integration problems that often arise when integrating large changes at the end of a development cycle.5. Increased Confidence in Code  Automated Testing: CI ensures that code changes are tested against a set of predefined tests, which increases confidence that the code is functioning as expected.  Consistent Environment: CI pipelines often run in consistent environments, reducing the risk of environment-specific issues.6. Enhanced Collaboration  Team Alignment: CI encourages frequent integration of code changes, keeping all team members aligned and reducing the likelihood of conflicts between different developers’ code.  Transparency: CI systems provide visibility into the build and test processes, making it easier for teams to collaborate and understand the current state of the project.7. Efficient Deployment  Automated Deployment: Many CI systems include Continuous Deployment (CD) capabilities, automating the deployment of code changes to staging or production environments. This streamlines the release process and reduces manual intervention.8. Documentation and Metrics  Build History: CI systems maintain a history of builds and test results, which helps in tracking the progress and identifying trends or recurring issues.  Test Reports: CI provides detailed reports on test results, code coverage, and other metrics, aiding in maintaining and improving code quality.9. Scalability  Handling Multiple Changes: CI systems can handle changes from multiple developers simultaneously, ensuring that all code changes are integrated and tested efficiently.  Scaling Teams: As teams grow, CI helps manage the complexity of integrating and testing code from multiple contributors.In summary, CI enhances the development process by ensuring that code changes are continuously tested and integrated, leading to higher quality software, faster development cycles, and better collaboration among team members.Where do we place CI in codeIn a typical project folder structure, CI-related files and configurations are usually placed in specific directories to keep them organized and easily accessible. Here’s where you might place CI-related files in your folder organization:Project Folder Structure with CI/project-root├── /src│   ├── /client       # Client-side code (React, etc.)│   └── /server       # Server-side code (Node.js, Express, etc.)│├── /config           # Configuration files│   ├── /ci           # CI-related configurations│   │   ├── github-actions.yml  # GitHub Actions workflow file│   │   ├── travis.yml          # Travis CI configuration file│   │   └── circleci.yml         # CircleCI configuration file│   ├── /database    # Database configuration│   └── /server      # Server configuration│├── /scripts         # Helper scripts│   ├── build.sh     # Build scripts│   └── deploy.sh    # Deployment scripts│├── /tests           # Test files and configurations│   ├── /unit        # Unit tests│   ├── /integration # Integration tests│   └── /e2e         # End-to-end tests│├── /public          # Public assets (e.g., images, static files)├── /docs            # Documentation│   └── README.md    # Project documentation│├── .gitignore       # Git ignore file├── package.json     # Node.js package configuration├── .eslintrc.json   # ESLint configuration└── .prettierrc      # Prettier configurationDetailed Explanation      /config/ci: This directory contains CI-related configuration files for different CI tools like GitHub Actions, Travis CI, CircleCI, etc. It’s a central place to keep all CI configurations.          github-actions.yml: For GitHub Actions workflows.      travis.yml: For Travis CI configurations.      circleci.yml: For CircleCI configurations.            /scripts: Contains helper scripts for various tasks such as building and deploying the application. Although not directly related to CI, these scripts are often used in CI pipelines.        /tests: Includes all test files and configurations. This is where you would place your unit tests, integration tests, and end-to-end tests that CI will execute.  Placing CI Files      GitHub Actions: Create .github/workflows/ in the root of your project. Files within this directory define the workflows and jobs for GitHub Actions.        Travis CI: Place the .travis.yml file in the root directory of your project.        CircleCI: Place the config.yml file in the .circleci/ directory in the root of your project.  By organizing your project with a dedicated folder for CI configurations and placing other related files in appropriate directories, you ensure that your project remains organized and maintainable. This setup makes it easier to manage and update CI configurations as needed.5. JSDocsWhen creating JSDoc comments for functions, it’s useful to follow a consistent blueprint to ensure that the documentation is clear, comprehensive, and helpful. Here’s a general blueprint you can follow:Blueprint for JSDoc Comments  Function Description:          Provide a concise description of what the function does. Explain the purpose and functionality.        Function Name:          Use the @function tag to specify the function name.        Parameters:          Use the @param tag to describe each parameter:                  Type: The type of the parameter (e.g., Object, string, number).          Name: The name of the parameter.          Description: A description of what the parameter represents and any constraints or details.                      Returns:          Use the @returns or @return tag to describe what the function returns:                  Type: The type of the return value (e.g., Promise&lt;void&gt;, Object).          Description: A description of the return value and what it represents.                      Errors:          Use the @throws tag to describe any errors or exceptions that the function might throw, including:                  Type of Error: The type or name of the error (e.g., ApiError).          Description: Conditions under which the error is thrown.                      Example (Optional):          Provide an example of how the function can be used if it adds value.      Example JSDoc CommentsHere’s how you might use this blueprint to create JSDoc comments for your functions:const { Product } = require('../model/Product.js');const catchAsync = require(\"../utils/catchAsync.util.js\");const status = require('http-status');const ApiError = require('../utils/ApiError.util.js');/** * Creates a new product. *  * @function * @name createProduct * @memberof module:controllers/productController * @param {Object} req - Express request object. * @param {Object} req.body - The product data to be created. * @param {Object} res - Express response object. * @returns {Promise&lt;void&gt;} Responds with the created product and status code 201 (Created). * @throws {Error} Forwards any errors to the error-handling middleware. */exports.createProduct = catchAsync(async (req, res) =&gt; {    const product = new Product(req.body);    const data = await product.save();    res.status(status.CREATED).json(data);});/** * Fetches products based on query parameters for filtering, sorting, and pagination. *  * @function * @name fetchAllQuery * @memberof module:controllers/productController * @param {Object} req - Express request object. * @param {Object} req.query - Query parameters for filtering and sorting: *   - `role` (optional): Role-based filtering (e.g., 'user' or 'admin'). *   - `_sort` (optional): Field to sort by. *   - `_order` (optional): Sort order, 'asc' or 'desc'. *   - `category` (optional): Filter by category. *   - `brand` (optional): Filter by brand. *   - `_page` (optional): Page number for pagination. * @param {Object} res - Express response object. * @returns {Promise&lt;void&gt;} Responds with the filtered, sorted, and paginated list of products and status code 200 (OK). * @throws {Error} Forwards any errors to the error-handling middleware. */exports.fetchAllQuery = catchAsync(async (req, res) =&gt; {    let productQuery = null;    // Filtering and sorting logic    if (req.query.role === 'user') {        productQuery = Product.find({ deleted: { $ne: true } });    } else if (req.query.role === 'admin') {        productQuery = Product.find();    }    if (req.query._sort &amp;&amp; req.query._order) {        productQuery = productQuery.sort({ [req.query._sort]: req.query._order });    }    if (req.query.category) {        const categories = req.query.category.includes(',') ? req.query.category.split(',') : req.query.category;        productQuery = productQuery.find({ category: { $in: categories } });    }    if (req.query.brand) {        const brands = req.query.brand.includes(',') ? req.query.brand.split(',') : req.query.brand;        productQuery = productQuery.find({ brand: { $in: brands } });    }    if (req.query._page) {        const pageSize = 10;        const page = req.query._page;        productQuery = productQuery.skip(pageSize * (page - 1)).limit(pageSize);    }    const data = await productQuery.exec();    res.status(status.OK).json(data);});/** * Fetches a product by its ID. *  * @function * @name fetchProductsById * @memberof module:controllers/productController * @param {Object} req - Express request object. * @param {Object} req.params - URL parameters including the `id` of the product. * @param {Object} res - Express response object. * @returns {Promise&lt;void&gt;} Responds with the product data and status code 200 (OK). * @throws {ApiError} Throws a 404 (Not Found) error if the product is not found. * @throws {Error} Forwards any other errors to the error-handling middleware. */exports.fetchProductsById = catchAsync(async (req, res) =&gt; {    const { id } = req.params;    const data = await Product.findById(id);    if (!data) {        throw new ApiError(status.NOT_FOUND, \"Product not found\");    }    res.status(status.OK).json(data);});/** * Updates a product by its ID with the data provided in the request body. *  * @function * @name updateProduct * @memberof module:controllers/productController * @param {Object} req - Express request object. * @param {Object} req.params - URL parameters including the `id` of the product to update. * @param {Object} req.body - The updated product data. * @param {Object} res - Express response object. * @returns {Promise&lt;void&gt;} Responds with the updated product data and status code 200 (OK). * @throws {ApiError} Throws a 404 (Not Found) error if the product is not found. * @throws {Error} Forwards any other errors to the error-handling middleware. */exports.updateProduct = catchAsync(async (req, res) =&gt; {    const { id } = req.params;    const data = await Product.findByIdAndUpdate(id, req.body, { new: true });    if (!data) {        throw new ApiError(status.NOT_FOUND, \"Product not found\");    }    res.status(status.OK).json(data);});Summary of the Blueprint:  Function Description: Provide a brief overview of what the function does.  Function Name: Use @function and @name tags to specify the function’s name and its purpose.  Parameters: Use @param tags to document each parameter’s type, name, and description.  Returns: Use @returns or @return to describe what the function returns.  Errors: Use @throws to document any errors that the function may throw and under what conditions.This blueprint ensures that your JSDoc comments are thorough and consistent, making your code easier to understand and maintain."
    },
  
    {
      "title": "Web development Css related",
      "url": "/documentation/web-dev",
      "date": "2024-08-19",
      "content": "CssWebsites for help  Handrawn icons/images          unDraw      storyset - Already drawn line drawings      humaaans - Mix-&amp;-match illustrations of people with a design library      openpeeps - Mix-&amp;-match illustrations of people with a design library        svg/icons          svgrepo      iconscout        Free Stock Images: Pexels  Free stck Images: PixaBay  fonts: Google Fonts  Color pallets etc: CoolorsWebsites for inspiration  DribbleWebsites to practise  Beginner practise html+css: Frontendmentor  higher level css practise: Css BattleDEVWeb Dev ideas to practise from youtube  React:          Hospital slot booking app      ReactThings to remember while starting a react app  npx create-react-app  use tailwind for css  search for libraries. dont make things from scratch.  divide code into componenets."
    },
  
    {
      "title": "Tests",
      "url": "/documentation/tests",
      "date": "2024-08-19",
      "content": "TestsTable of Contents  Overview  Test Frameworks  Pros and Cons of Each with Additional Frameworks1. OverviewTesting server-side code is crucial for ensuring that your application behaves as expected and is free of bugs. Here’s an overview of how to write tests for server-side files and the types of tests and folders commonly used:Types of Tests      Unit Tests          Purpose: Test individual functions, methods, or modules in isolation from the rest of the application.      Tools: Jest, Mocha, Chai, Jasmine      Example: Testing a utility function that formats dates.        // utils/dateFormatter.jsfunction formatDate(date) {  return date.toISOString().split(\"T\")[0];}module.exports = formatDate;// tests/unit/dateFormatter.test.jsconst formatDate = require(\"../../utils/dateFormatter\");test(\"formats date correctly\", () =&gt; {  const date = new Date(\"2024-08-19T12:00:00Z\");  expect(formatDate(date)).toBe(\"2024-08-19\");});            Integration Tests          Purpose: Test how different modules or components work together, including interactions with databases and external services.      Tools: Jest, Mocha, Chai, Supertest      Example: Testing an API endpoint to ensure it interacts correctly with the database.        // routes/user.test.jsconst request = require(\"supertest\");const app = require(\"../app\"); // Express app instanceconst mongoose = require(\"mongoose\");const User = require(\"../models/User\");beforeAll(async () =&gt; {  await mongoose.connect(\"mongodb://localhost/testdb\");});afterAll(async () =&gt; {  await mongoose.connection.close();});test(\"GET /users returns a list of users\", async () =&gt; {  await User.create({ name: \"John Doe\", email: \"john@example.com\" });  const response = await request(app).get(\"/users\");  expect(response.status).toBe(200);  expect(response.body).toHaveLength(1);  expect(response.body[0].name).toBe(\"John Doe\");});            End-to-End (E2E) Tests          Purpose: Test the entire application flow from end to end, including the frontend and backend, to ensure all parts of the system work together.      Tools: Cypress, Selenium      Example: Testing a user flow where a user logs in, performs an action, and logs out.        // e2e/login.test.jsdescribe(\"User login\", () =&gt; {  it(\"should log in successfully and redirect to dashboard\", () =&gt; {    cy.visit(\"/login\");    cy.get('input[name=\"email\"]').type(\"user@example.com\");    cy.get('input[name=\"password\"]').type(\"password123\");    cy.get('button[type=\"submit\"]').click();    cy.url().should(\"include\", \"/dashboard\");  });});      Common Folder Structure for TestsA well-organized test folder structure can help maintain clarity and manageability. Here’s a common structure:project-root/│├── src/                     # Source code│   ├── controllers/         # Controller files│   ├── models/              # Database models│   ├── routes/             # API routes│   └── utils/               # Utility functions│└── tests/                   # Test files    ├── unit/                # Unit tests    │   ├── utils/           # Tests for utility functions    │   └── models/          # Tests for database models    ├── integration/         # Integration tests    │   ├── routes/          # Tests for API routes    │   └── services/        # Tests for services    ├── e2e/                 # End-to-end tests    │   └── auth/            # E2E tests related to authentication    ├── setup/               # Test setup and teardown    │   └── jest.setup.js    # Jest setup file    └── fixtures/            # Test data and fixtures        └── users.js         # Example test data for usersTest Setup and Configuration  Test Framework: Set up Jest, Mocha, or another test framework.  Mocking: Use libraries like sinon or jest.mock to mock dependencies.  Environment: Configure test databases or services, and ensure tests run in a controlled environment.  Continuous Integration: Integrate tests into your CI/CD pipeline to run tests automatically on commits.Key Points  Isolation: Ensure unit tests run in isolation from each other and external systems.  Data Cleanup: Use setup and teardown methods to prepare and clean up test data.  Coverage: Aim for high test coverage, but focus on testing critical paths and scenarios.By implementing these practices and using this structure, you can effectively test your server-side code and ensure that your application behaves as expected.2. Test FrameworksChoosing a test framework depends on various factors like project requirements, team familiarity, and specific features you need. Here’s a brief overview of popular test frameworks to help you make an informed choice:1. Jest  Description: Developed by Facebook, Jest is a widely-used testing framework for JavaScript applications. It supports both unit and integration testing and is especially popular for testing React applications.  Features:          Built-in test runner and assertion library.      Snapshot testing for React components.      Mocking and spying capabilities.      Parallel test execution for faster results.      Zero configuration setup.            When to Use:          You need an all-in-one testing solution.      You are working with React or other JavaScript frameworks.      You prefer an easy setup and a rich feature set out of the box.        npm install --save-dev jest      2. Mocha  Description: Mocha is a flexible test framework for Node.js and browser-based JavaScript. It is known for its simplicity and extensibility.  Features:          Allows you to choose your own assertion library (e.g., Chai).      Supports asynchronous testing.      Offers a variety of reporters for test results.      Can be integrated with various plugins and libraries.            When to Use:          You prefer more control over test configuration and reporting.      You want to use different assertion libraries or plugins.      You need a framework that works well with various libraries and tools.        npm install --save-dev mocha      3. Jasmine  Description: Jasmine is a behavior-driven development (BDD) testing framework for JavaScript. It is known for its clean syntax and ease of use.  Features:          BDD syntax for writing tests.      Built-in assertion library.      No dependencies on other libraries.      Supports asynchronous testing.            When to Use:          You prefer BDD-style testing and syntax.      You want a straightforward testing framework with minimal configuration.      You need a test framework that doesn’t depend on other libraries.        npm install --save-dev jasmine      4. Ava  Description: Ava is a minimalistic test runner for Node.js that focuses on simplicity and speed.  Features:          Simple syntax and minimal configuration.      Supports parallel test execution.      Built-in assertion library.      Designed for high-performance testing.            When to Use:          You need a lightweight and fast test runner.      You prefer a straightforward and minimal configuration.      You want parallel test execution for better performance.        npm install --save-dev ava      5. Tape  Description: Tape is a minimal test framework for Node.js and browser-based JavaScript that emphasizes simplicity and ease of use.  Features:          Simple and straightforward syntax.      Provides only basic testing functionality, allowing you to integrate with other libraries as needed.      No built-in assertion library, encourages using external ones.            When to Use:          You prefer a minimalistic approach with fewer abstractions.      You want to integrate with other libraries for assertions and reporting.      You need a simple and unopinionated testing framework.        npm install --save-dev tape      How to Choose a Test Framework      Project Requirements: Choose a framework that fits your project’s needs. For example, if you’re working with React, Jest might be a better choice due to its built-in support for snapshot testing.        Team Familiarity: Consider what frameworks your team is already familiar with. This can reduce the learning curve and make adoption smoother.        Features: Evaluate the features you need, such as snapshot testing, parallel execution, or BDD syntax. Different frameworks offer varying levels of support for these features.        Performance: Consider the performance implications of the framework, especially for larger projects with extensive test suites.        Integration: Check how well the framework integrates with your existing tools and libraries, such as build systems, CI/CD pipelines, and other testing utilities.  By evaluating these factors, you can choose a test framework that best suits your project and development environment.3. Pros and Cons of each with additional frameworksHere’s an expanded overview of popular test frameworks, including their pros and cons, along with additional commonly used test frameworks:1. Jest  Description: Developed by Facebook, Jest is an all-in-one testing framework for JavaScript.  Features:          Built-in test runner and assertion library.      Snapshot testing for React components.      Mocking and spying capabilities.      Parallel test execution.      Zero configuration setup.        Pros:          Comprehensive feature set.      Easy to set up and use, especially for React applications.      Fast execution due to parallel testing.      Rich ecosystem with many plugins.        Cons:          Can be overkill for simple projects.      Larger bundle size due to built-in features.            When to Use:          You need an integrated solution with built-in mocking and snapshot features.      You’re working with React or other JavaScript frameworks.        npm install --save-dev jest      2. Mocha  Description: Mocha is a flexible testing framework for Node.js and browser-based JavaScript.  Features:          Allows custom assertion libraries (e.g., Chai).      Supports asynchronous testing.      Various reporters available.      Extensible with plugins.        Pros:          Highly customizable with different assertion libraries and reporters.      Works well with various plugins.      Suitable for both Node.js and browser testing.        Cons:          Requires additional libraries for assertions and mocking (e.g., Chai, Sinon).      Slightly more configuration needed compared to Jest.            When to Use:          You prefer flexibility and customization.      You want to use different assertion libraries or need specific reporting formats.        npm install --save-dev mocha      3. Jasmine  Description: Jasmine is a behavior-driven development (BDD) framework for JavaScript.  Features:          BDD syntax for writing tests.      Built-in assertion library.      No external dependencies.      Supports asynchronous testing.        Pros:          Simple and clean BDD syntax.      No need for additional libraries.      Good documentation and community support.        Cons:          Limited built-in features compared to Jest.      Less flexibility in choosing assertion libraries.            When to Use:          You prefer BDD-style testing and syntax.      You need a straightforward testing framework without extra dependencies.        npm install --save-dev jasmine      4. Ava  Description: Ava is a minimalistic test runner for Node.js focused on simplicity and performance.  Features:          Minimal configuration and syntax.      Supports parallel test execution.      Built-in assertion library.        Pros:          Fast and efficient due to parallel test execution.      Simple syntax and minimal setup.      Good performance for large test suites.        Cons:          Limited built-in features compared to Jest.      Fewer plugins and integrations available.            When to Use:          You need a lightweight, fast test runner.      You prefer minimal configuration and simplicity.        npm install --save-dev ava      5. Tape  Description: Tape is a minimalistic test framework for Node.js and browser-based JavaScript.  Features:          Simple, straightforward syntax.      Basic testing functionality.      Encourages using external libraries for assertions.        Pros:          Minimalistic and straightforward.      Works well with other libraries for assertions and reporting.      Easy to integrate into various setups.        Cons:          Lacks built-in assertion and reporting features.      Less opinionated, which might require additional setup.            When to Use:          You prefer a minimalistic approach with custom integrations.      You want to use external libraries for assertions and reporting.        npm install --save-dev tape      Additional Test Frameworks      Karma          Description: A test runner for JavaScript that works with various test frameworks (e.g., Jasmine, Mocha).      Features:                  Runs tests in real browsers.          Supports various test frameworks and reporters.                    Pros:                  Browser-based testing.          Highly configurable and integrates with various frameworks.                    Cons:                  Requires setup and configuration.          Can be complex for beginners.                          Cypress          Description: End-to-end testing framework with a focus on frontend applications.      Features:                  Real-time browser preview of tests.          Built-in commands and assertions.          Easy setup and configuration.                    Pros:                  Excellent for end-to-end and integration testing.          Interactive test runner.          Good documentation and support.                    Cons:                  Focused primarily on end-to-end testing.          Can be overkill for simple unit tests.                          Supertest          Description: A high-level abstraction for testing HTTP APIs.      Features:                  Integrates with Mocha or other test frameworks.          Provides a fluent API for making HTTP requests and assertions.                    Pros:                  Simplifies HTTP API testing.          Works well with Mocha for integration tests.                    Cons:                  Limited to HTTP requests and responses.                    By considering the pros, cons, and specific features of each framework, you can choose the one that best fits your project requirements and development preferences."
    },
  
    {
      "title": "Passport Jwt",
      "url": "/documentation/passport-jwt",
      "date": "2024-08-19",
      "content": "Passport-jwt DocumentaionTable of Contents  Overview  Features and Usage          Installation and Import      Configuration                  Basic Code Structure          Parts of Code in detail                          Imports              passport.use(name[optional], strategy)              new Startegy(options, verifyCallback)                                          Full Code Structure (seperated into modules)        Authentication          With session support (w/o callback)      Without session support (w/ callback)        Methods to pass JWT TokenOverview  A middleware for Express.js framework that provides authentication and authorization using JSON Web Tokens (JWT).  A passport strategy to work with JWT  This only handles what we can do with a JWT token created using passport. To create a token checkout PassportFeatures and Usage      Installation and Import - Install: npm install passport-jwt - Import: const { Strategy, ExtractJwt } = require(\"passport-jwt\"); - passport-jwt is a class with 2 properties - Strategy and ExtractJwt - Strategy is a class with 2 parameters passed to its contructor - ExtractJwt is an object with various sub properties        Configuration    - Basic Structure:              ```javascript  const JwtStrategy = require(\"passport-jwt\").Strategy;  const ExtractJwt = require(\"passport-jwt\").ExtractJwt;  const passport = require(\"passport\");  // Options for the strategy  const opts = {    jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), // Extract token from Authorization header    secretOrKey: \"your_jwt_secret_key\", // Secret key for verifying token  };  // JWT Strategy  passport.use(    new JwtStrategy(opts, (jwtPayload, done) =&gt; {      // Find the user based on the jwtPayload.sub (subject)      User.findOne({ id: jwtPayload.sub }, (err, user) =&gt; {        if (err) {          return done(err, false);        }        if (user) {          return done(null, user);        } else {          return done(null, false); // User not found        }      });    })  );  ```- Parts of the configuration:              1. Imports:         - const {Strategy,ExtractJwt} = require(\"passport-jwt\") - const passport = require(\"passport\"); 2. passport.use() method to register strategy (2 ways):    passport.use(Strategy) - Default Strategy         - Registers a strategy directly.         - Will be treated as the default strategy.         - Allows you to refer to the strategy by the name _jwt_ later in the *passport* method `passport.authenticate('jwt')`.                  &lt;details&gt;         &lt;summary&gt;         &lt;code&gt;passport.use(name, Strategy)&lt;/code&gt; - Named Strategy [optional]         &lt;/summary&gt;     - Allows you to refer to the strategy by the name _jwt_ later in the *passport* method `passport.authenticate('name')`.     &lt;/details&gt;  3. Strategy (has 2 parameters):         - Has two parameters: opts and verify            - Parameters:            &lt;details&gt;            &lt;summary&gt;                &lt;code&gt;`opts`&lt;/code&gt; - (object) Options            &lt;/summary&gt;            - This parameter is an object that defines various options for the strategy.            - Example:                ```js                const opts = {                    jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),                    secretOrKey: \"your_jwt_secret_key\",                    issuer: \"your_issuer\", // optional                    algorithms: [\"HS256\"], // optional                    ignoreExpiration: false, // optional, defaults to false                };                ```            - Properties:                1. &lt;details&gt;                        &lt;summary&gt;                        &lt;code&gt;jwtFromRequest&lt;/code&gt; - (function) To specify method of Jwt extraction                        &lt;/summary&gt;                    - Specifies how the JWT will be extracted from the incoming request from client using _ExtractJwt_ class.                    - Example                        ```javascript                        const opts = {                            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken();                        }                        ```                    - All options (Properties of ExtractJwt):                    1. &lt;details&gt;                        &lt;summary&gt;                        &lt;code&gt;ExtractJwt.fromAuthHeaderAsBearerToken()&lt;/code&gt;                        &lt;/summary&gt;                        - **Usage**: Extracts the JWT from the Authorization header, assuming the JWT is prefixed by the word Bearer.                        - **Input parameter**: none                        - **Example**:                        ```js                        jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken();                        ```                        &lt;/details&gt;                    2. &lt;details&gt;                        &lt;summary&gt;                        &lt;code&gt;ExtractJwt.fromHeader(header_name)&lt;/code&gt;                        &lt;/summary&gt;                        - **Usage**: Extracts the JWT from a custom header in the request.                        - **Input parameter**: header_name (string) - The name of the custom header containing the JWT.                        - **Example**:                        ```js                        jwtFromRequest: ExtractJwt.fromHeader('auth_token')                        ```                        &lt;/details&gt;                    3. &lt;details&gt;                        &lt;summary&gt;                        &lt;code&gt;ExtractJwt.fromBodyField(field_name)&lt;/code&gt;                        &lt;/summary&gt;                        - **Usage**:  Extracts the JWT from a specific field in the request body (typically used in form submissions or JSON payloads).                        - **Input parameter**: field_name (string) - The name of the field in the request body that contains the JWT.                        - **Example**:                        ```js                        jwtFromRequest: ExtractJwt.fromBodyField('token')                        ```                        &lt;/details&gt;                    4. &lt;details&gt;                        &lt;summary&gt;                        &lt;code&gt;ExtractJwt.fromUrlQueryParameter(param_name)&lt;/code&gt;                        &lt;/summary&gt;                        - **Usage**:  Extracts the JWT from a URL query parameter.                        - **Input parameter**: param_name (string) - The name of the query parameter in the URL that contains the JWT.                        - **Example**:                        ```js                        jwtFromRequest: ExtractJwt.fromUrlQueryParameter('token')                        ```                        &lt;/details&gt;                    5. &lt;details&gt;                        &lt;summary&gt;                        &lt;code&gt;fromAuthHeaderWithScheme(auth_scheme) &lt;/code&gt;                        &lt;/summary&gt;                        - **Usage**:  Extracts the JWT from Authorization Header with the specified auth_scheme                        - **Input parameter**: (string) Auth scheme like Bearer, Token, etc                        - **Example**:                            ```js                            jwtFromRequest: ExtractJwt.ExtractJwt.fromAuthHeaderWithScheme('Token')                            ```                        &lt;/details&gt;                    6. &lt;details&gt;                        &lt;summary&gt;                        &lt;code&gt;fromExtractors([array of extractor functions]) &lt;/code&gt;                        &lt;/summary&gt;                        - **Usage**:  Lets us define multiple extractors to extract jwt from different sources one after other.                        - **Input parameter**: (array) Array of extractors                        - **Example**:                            ```js                            const extractors = [                                ExtractJwt.fromAuthHeaderAsBearerToken(),         // Try the Bearer token from Authorization header                                ExtractJwt.fromUrlQueryParameter('auth_token')    // Then try the token from the URL query parameter                            ];                            const opts = {                                jwtFromRequest: ExtractJwt.fromExtractors(extractors),                                secretOrKey: 'your_secret_key'                            };                            ```                        &lt;/details&gt;                    7. &lt;details&gt;                        &lt;summary&gt;                        &lt;code&gt;Custom Extractors&lt;/code&gt;                        &lt;/summary&gt;                        - **Usage**:  Lets us define custom extractoinof tokens from anywhere                        - **Example**:                            ```js                            //when extracting from cookies using cookie parser                            var cookieParser = require('cookie-parser')                            const express = require('express');                            const app = express()                            app.use(cookieParser())                            //custom extractor                            var cookieExtractor = function (req) {                            var token = null;                            if (req &amp;&amp; req.cookies) {                                token = req.cookies[\"jwt\"];                            }                            return token;                            };                            const opts = {                                jwtFromRequest: cookieExtractor,                                secretOrKey: 'your_secret_key'                            };                            ```                        &lt;/details&gt;                    &lt;/details&gt;                2. &lt;details&gt;                    &lt;summary&gt;                        &lt;code&gt;secretOrKey&lt;/code&gt; - (string or buffer) Secret key to verify JWT                    &lt;/summary&gt;                    - The key used to verify the JWT signature. This is essential for validating the authenticity of the token.                    - **For symmetric algorithms** (e.g., HS256, HS384, HS512), `secretOrKey` will be a shared secret string or buffer used by both the server that signs the JWT and the server that verifies it.                    - **For asymmetric algorithms** (e.g., RS256, RS384, RS512), `secretOrKey` will be a public key that verifies the JWT, while the corresponding private key is used to sign the JWT.                    - Examples:                        - Symmetric key:                            ```js                            const opts = {                                secretOrKey: 'your_jwt_secret_key' //can be any random word                            };                            ```                        - Asymmetric key:                            ```js                            const opts = {                                secretOrKey: fs.readFileSync('./path/to/public.key', 'utf8')                            };                            ```                        - Note:                            - If using symmetric encryption (e.g., HS256), the same secretOrKey must be used for both signing and verifying the token.                            - If using asymmetric encryption (e.g., RS256), the secretOrKey should be the public key, while the private key is used to sign the token.                            - It is important to securely manage this key, as exposure could compromise the security of your system.                    &lt;/details&gt;                3. &lt;details&gt;                    &lt;summary&gt;                        &lt;code&gt;secretOrKeyProvider&lt;/code&gt; - (function) [optional] Function to get secretOrKey from anywhere                    &lt;/summary&gt;                    - This function dynamically provides the secret or public key for verifying the JWT. It is useful in cases where the key needs to be determined based on the request, such as in multi-tenant applications or when using different keys for different users.                    - Do not use both `secretOrKey` and `secretOrKeyProvider`. Use either of them                    - Parameters:                        - `request`: The original HTTP request object.                        - `rawJwtToken`: The raw JWT token extractedfrom the request.                        - `done`: A function to return the key, with the parameters:                            - `err`                            - `secretOrKey` (string or buffer)                    - Example:                        ```js                            const opts = {                                secretOrKeyProvider: (request, rawJwtToken, done) =&gt; {                                    // Logic to determine the secret or key dynamically                                    const secretOrKey = getSecretForTenant(request); // Example function to get the secret key based on tenant                                    done(null, secretOrKey); // Pass the key to the callback function                                }                            };                        ```                        - Note:                            1. If secretOrKeyProvider is provided, it overrides the static secretOrKey option                            2. Useful in scenarios where the key might change per request or per user, such as:                                - Multi-tenant applications where each tenant has a different key.                                - Using different keys for different users or services.                            3. If the key cannot be determined (e.g., a database lookup fails), call done(err) to signal an error.                            4. When using asymmetric encryption (e.g., RS256), the secretOrKeyProvider would return the public key for verification.                        - Example for multi-tenant application:                            ```js                            const opts = {                                secretOrKeyProvider: (request, rawJwtToken, done) =&gt; {                                    // Get the tenant's key based on some property of the request (e.g., subdomain or user ID)                                    const tenantKey = getTenantKeyFromDb(request.tenantId); // Example function to retrieve tenant's key                                    done(null, tenantKey);                                }                            };                            ```                        - Use Case:                            - Multi-tenant systems where different tenants have different signing keys.                            - Dynamic environments where the key cannot be determined statically and must be retrieved or computed based on the incoming request.                    &lt;/details&gt;                4. &lt;details&gt;                        &lt;summary&gt;                        &lt;code&gt;issuer&lt;/code&gt; - (string or array) [optional]  Verifies the issuer (iss) claim of the token.                        &lt;/summary&gt;                        - Examples:                        ```js                        const opts = {                                    issuer: 'https://accounts.google.com'                                };                        ```                        ```js                        const opts = {                                issuer: [                                    'https://accounts.google.com',                                    'https://your-tenant-name.auth0.com/',                                    'https://dev-123456.okta.com'                                ]                            };                        ```                        - Use Cases:                            - **Single Issuer Application**: If all tokens are issued by your application, you would set the issuer option to your app's identifier.                            - **Third-Party Tokens**: If you're working with tokens issued by third parties (e.g., OAuth providers or external identity systems), you would set issuer to the known trusted issuer.                    &lt;/details&gt;                5. &lt;details&gt;                    &lt;summary&gt;                    &lt;code&gt;algorithms&lt;/code&gt; - (array) [optional] List of allowed algorithms for token verification, e.g., ['HS256', 'RS256'].                    &lt;/summary&gt;                    - **Purpose**: This option helps enforce which algorithms are accepted for signing JWTs, improving security by rejecting tokens signed with algorithms that are not trusted or expected.                    - **Default Behavior**: If the algorithms option is not provided, the strategy will allow any algorithm,                    - Examples:                        ```js                        const opts = {,                            algorithms: ['HS256', 'RS256', 'ES256'] // Accepts JWTs signed with HS256, RS256, or ES256 algorithms                        };                        ```                        ```js                        const opts = {,                            algorithms: ['HS256']                        };                        ```                    &lt;/details&gt;                6. &lt;details&gt;                    &lt;summary&gt;                    &lt;code&gt;audience&lt;/code&gt; - (string or array) [optional] To specify the recipients of Jwt                    &lt;/summary&gt;                    - **Purpose**: To specify the recipients of Jwt. Will be verifiesd against the recipients mentioned in *aud* coming through *jwt_payload*.                    - Examples:                        ```js                        const opts = {,                             \"aud\": \"user-service\",                        };                        ```                        ```js                        const opts = {,                             \"aud\": [\"user-service\", \"billing-service\", \"yoursite.net\"]                        };                        ```                    &lt;/details&gt;                7. &lt;details&gt;                        &lt;summary&gt;                        &lt;code&gt;ignoreExpiration&lt;/code&gt; - (boolean) [optional] Whether to ignore the token's expiration time during verification.                        &lt;/summary&gt;                        - **Purpose**:                            - When you want to accept tokens even if they have expired.                            - Useful in testing environments where you might not want to deal with token expiration.                            - The `exp` claim in a JWT specifies the expiration time of the token. Expiry is not set by passport-jwt.                        - **Default Behavior**: By default, ignoreExpiration is false, meaning that Passport-JWT will check the exp claim to ensure the token is not expired.                        - Examples:                            ```js                            const opts = {                                ignoreExpiration: true // Accepts expired tokens                            };                            ```                            ```js                            const opts = {                                ignoreExpiration: false // Enforces expiration check                            };                            ```                    &lt;/details&gt;                8. &lt;details&gt;                    &lt;summary&gt;                    &lt;code&gt;passReqToCallback&lt;/code&gt; - (boolean) [optional] Whether to pass the request object to the verification callback.                    &lt;/summary&gt;                    - The `passReqToCallback` option specifies whether the request object should be passed to the `verify` callback function in the `JwtStrategy`.                    - Useful if you need access to the `req` object for additional logic inside verify callback.                    - Example:                        ```js                        const opts = {                            passReqToCallback: true // Passes the request object to the verify callback                        };                        ```                        ```js                        passport.use(new JwtStrategy(opts, (req, jwtPayload, done) =&gt; { //now you can add req as parameter                            // Access request object                            console.log(req.headers); // Example of accessing headers                            User.findById(jwtPayload.sub, (err, user) =&gt; {                                if (err) return done(err, false);                                if (user) return done(null, user);                                return done(null, false);                            });                        }));                        ```                    &lt;/details&gt;                9. &lt;details&gt;                    &lt;summary&gt;                    &lt;code&gt;jsonWebTokenOptions &lt;/code&gt; - (object) [optional + deprecated] To pass options to customise token verification                    &lt;/summary&gt;                    - **Purpose**: To pass options directly to the underlying jsonwebtoken.verify() and customise token verification.                    - **Deprecated**: Though deprecated, still allows you to pass audience / issuer / algorithms / ignoreExpiration on the options                    - **Properties**:                        - &lt;details&gt;&lt;summary&gt;&lt;code&gt;algorithms&lt;/code&gt;: (array) Specifies allowed signing algorithms.&lt;/summary&gt;                            - Specifies which algorithms are allowed for verifying the JWT.                            - eg: `algorithms: ['HS256']`                            &lt;/details&gt;                        - &lt;details&gt;&lt;summary&gt;&lt;code&gt;audience&lt;/code&gt;: (string | RegExp | array) Specifies the expected audience of the JWT.&lt;/summary&gt;                            -  Specifies the expected audience of the JWT (who the token is intended for). It can be a string, regex, or array of strings/regexes.                            - eg: `audience: 'your-app-client-id'`                            &lt;/details&gt;                        - &lt;details&gt;&lt;summary&gt;&lt;code&gt;clockTimestamp&lt;/code&gt;: (integer) Sets a fixed time for token validation.&lt;/summary&gt;                            - The time in seconds since the epoch to use as the current time when verifying the JWT.                            ```js                            clockTimestamp: Math.floor(Date.now() / 1000) // current time in seconds                            ```                            &lt;/details&gt;                        - &lt;details&gt;&lt;summary&gt;&lt;code&gt;clockTolerance&lt;/code&gt;: (integer) Helps with clock skew issues.&lt;/summary&gt;                            - Specifies the allowed clock skew (in seconds) when verifying the exp and nbf claims (useful when different servers have slightly unsynchronized clocks).                            - eg: `clockTolerance: 5`                            &lt;/details&gt;                        - &lt;details&gt;&lt;summary&gt;&lt;code&gt;complete&lt;/code&gt;: (boolean) Returns `{ payload, header, signature }` if true.&lt;/summary&gt;                            -  If true, returns an object with the decoded { payload, header, signature } instead of just the payload.                            - eg: `complete: true`                            &lt;/details&gt;                        - &lt;details&gt;&lt;summary&gt;&lt;code&gt;issuer&lt;/code&gt;: (string | array) Specifies the expected issuer of the JWT.&lt;/summary&gt;                            - Specifies the expected issuer of the JWT (the entity that issued the token). Can be a string or an array of strings.                            - eg: `issuer: 'auth.your-app.com'`                            &lt;/details&gt;                        - &lt;details&gt;&lt;summary&gt;&lt;code&gt;ignoreExpiration&lt;/code&gt;: (boolean) Ignores the `exp` claim if true.&lt;/summary&gt;                            -  If true, ignores the exp claim during verification (useful in development, but not recommended in production).                            - eg: `ignoreExpiration: true`                            &lt;/details&gt;                        - &lt;details&gt;&lt;summary&gt;&lt;code&gt;ignoreNotBefore&lt;/code&gt;: (boolean) Ignores the `nbf` claim if true.&lt;/summary&gt;                            - If true, ignores the nbf (Not Before) claim when verifying the token.                            - eg: `ignoreNotBefore: true`                            &lt;/details&gt;                        - &lt;details&gt;&lt;summary&gt;&lt;code&gt;jwtid&lt;/code&gt;: (string) Validates the token ID (jti) claim.&lt;/summary&gt;                             - The jti (JWT ID) claim specifies a unique identifier for the token to prevent replay attacks.                             - eg: `jwtid: 'unique-jwt-id-12345'`                            &lt;/details&gt;                        - &lt;details&gt;&lt;summary&gt;&lt;code&gt;nonce&lt;/code&gt;: (string) Checks the `nonce` claim (used in OpenID Connect).&lt;/summary&gt;                            -  Used to check the nonce claim in OpenID Connect to prevent replay attacks. The nonce is a string used to associate a client session with an ID token.                            - eg: `nonce: 'nonce-value-generated-at-auth-time'`                            &lt;/details&gt;                        - &lt;details&gt;&lt;summary&gt;&lt;code&gt;subject&lt;/code&gt;: (string) Specifies the expected `sub` (Subject) claim.&lt;/summary&gt;                             - Specifies the expected sub (Subject) claim of the JWT, which typically identifies the principal (user) of the token.                             - eg: `subject: 'user-id-12345'`                            &lt;/details&gt;                        - &lt;details&gt;&lt;summary&gt;&lt;code&gt;maxAge&lt;/code&gt;: (string | number) Limits how old a token can be.&lt;/summary&gt;                            -  Specifies the maximum allowable age (in seconds or a time string) for the JWT since its iat (Issued At) claim. Used to reject old tokens.                            - eg: `maxAge: '24h'`                            &lt;/details&gt;                        - &lt;details&gt;&lt;summary&gt;&lt;code&gt;allowInvalidAsymmetricKeyTypes&lt;/code&gt;: (boolean) Allows invalid asymmetric key types if true.&lt;/summary&gt;                            - When set to true, allows invalid asymmetric key types during verification (not recommended unless necessary).                            - eg: `allowInvalidAsymmetricKeyTypes: true`                            &lt;/details&gt;                    - Examples:                        ```js                        const opts = {                            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),                            secretOrKey: 'your_secret_key',                            jsonWebTokenOptions: {                                clockTolerance: 5,  // Allow 5 seconds of clock skew                                maxAge: '1d',       // Only accept tokens no more than 1 day old                                algorithms: ['HS256'],  // Only accept tokens signed with HS256                                ignoreNotBefore: true, // Will ignore token's Not before dates                                ignoreExpiration: false // Will validate the 'expiration' claim                            }                        };                        passport.use(new JwtStrategy(opts, (jwtPayload, done) =&gt; {                            User.findById(jwtPayload.sub, (err, user) =&gt; {                                if (err) return done(err, false);                                if (user) return done(null, user);                                return done(null, false);                            });                        }));                        ```                    &lt;/details&gt;            &lt;/details&gt;            &lt;details&gt;            &lt;summary&gt;                &lt;code&gt;`verify`&lt;/code&gt; - (function) Verify Callback            &lt;/summary&gt;            - **Purpose**: Callback used in the `JwtStrategy` to validate the JWT and determine if it should be accepted.            - **Parameters**:                - &lt;details&gt;                    &lt;summary&gt;                    &lt;code&gt;payload&lt;/code&gt; - (object) Payload for verify callback                    &lt;/summary&gt;                    - **Purpose**: It is the decoded JWT payload, which contains the claims from the token (e.g., user ID, roles).                    - It is an object that contains the claims from the decoded JWT. We can only access these claim values and set it. It is set using *jwt.sign()* using [*jsonwebtoken*](http://jwtdocumentation) module.                    - **Properties**  **(Claims)**:                        1. `sub`: The **subject** of the token, usually the user ID. This is a standard claim and is often used to identify the user.                        2. `exp`: The **expiration** time of the token, specified as a Unix timestamp. This is a standard claim used to determine if the token has expired.                        3. `iat`: The **issued-at** time, specified as a Unix timestamp. This indicates when the token was issued.                        4. `iss`: The **issuer** of the token, which is a standard claim indicating who issued the token.                        5. `aud`: The **audience** for which the token is intended. This is a standard claim indicating the recipient(s) of the token.                        6. `nbf`: **Not Before** - The time before which the token should not be considered valid.                        7. `jti`: **JWT ID** - A unique identifier for the token, which can be used to prevent replay attacks.                        &gt; **Note** : we can also have any custom claims. eg: roles, name.                    - Example:                        ```js                        //setting claims in some other file                        const jwt = require('jsonwebtoken')                        fucntion signIn(req, res){                            const payload = {                                sub: user._id,                                roles: user.roles,                                exp: Math.floor(Date.now() / 1000) + (60 * 60)                                //etc                            }                            const token = jwt.sign(payload, 'your_jwt_secret_key')                            res.send({token})                        }                        //accessing those claims                        passport.use(new JwtStrategy(opts, (jwtPayload, done) =&gt; {                            console.log('User ID:', jwtPayload.sub);                            console.log('Token Expiry Time:', jwtPayload.exp);                            console.log('User Roles:', jwtPayload.roles);                            User.findById(jwtPayload.sub, (err, user) =&gt; {                                if (err) return done(err, false);                                if (user) return done(null, user);                                return done(null, false);                            });                        }));                        ```                    &lt;/details&gt;                - &lt;details&gt;                    &lt;summary&gt;                    &lt;code&gt;done&lt;/code&gt; - (fucntion) To indicate the result of the verification.                    &lt;/summary&gt;                    - **Purpose**: To indicate the result of the verification.                    - **Parameters**:                        - `err`: Error during verification if any                        - `user`: Any sort of data that comes out after the logic inside verify callback                        - `info`: [optional] Any message regarding error or user                    - Example:                        ```js                        //without info                        passport.use(new JwtStrategy(opts, (jwtPayload, done) =&gt; {                            User.findById(jwtPayload.sub, (err, user) =&gt; {                                if (err) return done(err, false);                                if (user) return done(null, user); // Verification successful                                return done(null, false); // No user found, but no error                            });                        }));                        ```                        ```js                        //with info                        passport.use(new JwtStrategy(opts, (jwtPayload, done) =&gt; {                            User.findById(jwtPayload.sub, (err, user) =&gt; {                                if (err) return done(err, false);                                if (!user) return done(null, false, { message: 'User not found' });                            });                        }));                        ```                      &lt;/details&gt;                    - &lt;details&gt;                        &lt;summary&gt;                        &lt;code&gt;req&lt;/code&gt; [conditional]                        &lt;/summary&gt;                        - Only when inside opts, passReqToCallback is true                        ```js                        const opts = {passReqToCallback: true}                        const verify = (req, payload, done)=&gt;{                            // handle payload data                        }                        ```                        &lt;/details&gt;                - Example:                    ```js                    const verify = (jwtPayload, done) =&gt; {                        // jwtPayload contains the decoded JWT payload                        User.findById(jwtPayload.sub, (err, user) =&gt; {                            if (err) return done(err, false); // Error during user lookup                            if (user) return done(null, user); // User found, authentication successful                            return done(null, false); // User not found, authentication failed                        });                    }                    passport.use(new JwtStrategy(opts, verify));                    ```             &lt;/details&gt;        - Example:            ```js            const JwtStrategy = new Startegy(opts, verify)            passport.use(JwtStrategy);            ```        - Strategy is of 2 tyes:            - &lt;details&gt;&lt;summary&gt;With req&lt;/summary&gt;                - paasing opts with true for passReqToCallback enables us to use `req` in verify callbak                ```js                const opts = { passReqToCallback:true }                const verify = (req, payload, done)=&gt;{                }                ```                &lt;/details&gt;            - &lt;details&gt;&lt;summary&gt;Without req&lt;/summary&gt;                ```js                opts = { passReqToCallback:false }                ```                &lt;/details&gt;            Full Structure (for deafult strategy): - Default Strategy:```javascriptconst { Strategy, ExtractJwt } = require(“passport-jwt”);const passport = require(“passport”); //to use for passport.use()            // Options for the strategy        const opts = {            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),            secretOrKey: \"your_jwt_secret_key\",            //etc        };        //verify callback for strategy        const verify = (jwtPayload, done) =&gt; {            User.findOne({ id: jwtPayload.sub }, (err, user) =&gt; {            if (err) {                return done(err, false);            }            if (user) {                return done(null, user);            } else {                return done(null, false); // User not found            }            });        };        //new jwt-Strategy        const JwtStrategy = new Strategy(opts, verify)        //using new jwt-strategy in passport        passport.use(JwtStrategy);        //authenticating default jwt-strategy        passport.authenticate('jwt')    ```- Named Strategy:    ```javascript        const { Strategy, ExtractJwt } = require(\"passport-jwt\");        const passport = require(\"passport\");        const opts = {            jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),            secretOrKey: \"your_jwt_secret_key\",            //etc        };        const verify = (jwtPayload, done) =&gt; {            User.findOne({ id: jwtPayload.sub }, (err, user) =&gt; {            if (err) {                return done(err, false);            }            if (user) {                return done(null, user);            } else {                return done(null, false);            }            });        };        const JwtStrategy = new Strategy(opts, verify)        //using named jwt-strategy in passport        passport.use('my-jwt', JwtStrategy);        //authenticating named jwt-strategy        passport.authenticate('my-jwt')    ```      Authenticating jwt after strategy configuration  Ways:          As of understood till date, passport jwt can be authenticated in 2ways:                  With session support (without callback)          Without session support (with callback)                    With session support (without callback), one would need to many extar methods like passport.serializeUser, session(), etc. We would not have to specifically set req.user to user. Passport would do it internally for us.      Without session support (with callback), we dont need any extra methods. But we would need to set req.user to user explicitly by us.            Without session support (with callback) - in the internal code, if passport.authenticate gets a callback, it doesnt call any other internal function. It just returns that callback with user and err, to handle by ourself.```js// Options for JWT strategy, including extractor function and secret keyconst optsJwt = {jwtFromRequest: cookieExtractor,secretOrKey: constant.secretKey}// Function to verify JWT token and retrieve user informationconst verifyJwt = async function (jwt_payload, done) {if (!jwt_payload.id) return done(null, false);        try {        let user = await User.findOne({ _id: jwt_payload.id });        if (user) return done(null, santizeUser(user));        else return done(null, false);    } catch (error) {        return done(err, false);    }}// Options for Local strategy, specifying the field for usernameconst optsLocal = { usernameField: \"email\" }// Function to verify local credentials and handle authenticationconst verifyLocal = async function (email, password, done) {    try {        const user = await User.findOne({ email: email }).exec();        if (!user) {            return done(null, false, { message: \"No such user email\" });        }        crytpoJwt(user, password, done)    } catch (error) {        return done(error);    }}// Initialize Passport with JWT strategypassport.use(\"jwt\",new JwtStrategy(optsJwt, verifyJwt););// Middleware to authenticate requests using JWT strategyapp.use((req, res, next) =&gt; {    passport.authenticate(\"jwt\", (err, user, info) =&gt; {        if (err || !user)            return next(new ApiError(httpStatus.UNAUTHORIZED, \"Please authenticate\"))        req.user = user;        next()    })(req, res, next)})```            With session support (without callback) - When with callback, internalluy, passport passes many checks and process including - needing a session - needing to use passport.serializeUser atleast once with a callback containing user.id/user - In the latest version, for authenticating using passport-jwt configured strategy, we need to use 2 extra methods from passport package and 1 method from express-session package: -     passport.authenticate() from passport            - `passport.authenticate()` is a passport middleware. It has been [customised internally](https://github.com/mikenicholson/passport-jwt/blob/master/lib/strategy.js#L90) to authenticate jwt via passport-jwt package.        - 3 paramters:            - strategy: (string|array)            - options            - callback [optional]        - &lt;details&gt;            &lt;summary&gt;It is wrapped inside a wrapper as an express middleware to access req, res and next. Without the wrapper it won't pass on to the next function.            &lt;/summary&gt;            ```js            app.use((req, res, next)=&gt;{                passport.authenticate('jwt')(req, res, next)            })            ```            &lt;/details&gt;        - &lt;details&gt;            &lt;summary&gt;            In older versions it would itself be placed as a middleware, but not anymore            &lt;/summary&gt;            ```js            app.use(passport.authenticate('jwt'))            ```            &lt;/details&gt;        - Parameters:            - &lt;details&gt;                &lt;summary&gt;                    &lt;code&gt;strategy&lt;/code&gt;: (string or array)                &lt;/summary&gt;                - **Purpose**: To point to the strategies named during configuration.                - **Example**: jwt, my-jwt, [jwt, my-jwt], etc                &lt;/details&gt;            - &lt;details&gt;                &lt;summary&gt;                    &lt;code&gt;options&lt;/code&gt;: (object) [optional]                &lt;/summary&gt;                - **Purpose**: Options to control the behavior of the authentication middleware.                - It controls the behaviour at individual route/request level in comparison to opts options which controls behaviour at global/strategy level.                - If there are conflicting options between opts and authenticateOptions, then authenticateOptions will override for that particular route.                - **Properties**:                    &lt;details&gt;                    &lt;summary&gt;1. authInfo&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; Whether to include additional authentication information.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; undefined (additional info is not included).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { authInfo: true });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                    &lt;details&gt;                    &lt;summary&gt;2. assignProperty&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; Assigns the object provided by the verify callback to the specified property on the &lt;code&gt;req&lt;/code&gt; object.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; undefined (the object is assigned to &lt;code&gt;req.user&lt;/code&gt;).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { assignProperty: 'userAccount' });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                    &lt;details&gt;                    &lt;summary&gt;3. failureFlash&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; True to flash failure messages or a string to use as a flash message for failures.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; undefined (failure messages are not flashed).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { failureFlash: 'Login failed' });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                    &lt;details&gt;                    &lt;summary&gt;4. failureMessage&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; True to store failure message in &lt;code&gt;req.session.messages&lt;/code&gt;, or a string to use as an override message for failure.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; undefined (failure messages are not stored).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { failureMessage: 'Login unsuccessful' });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                    &lt;details&gt;                    &lt;summary&gt;5. failureRedirect&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; URL to redirect to after a failed login attempt.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; undefined (no redirect occurs).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { failureRedirect: '/login' });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                    &lt;details&gt;                    &lt;summary&gt;6. failWithError&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; Whether to fail with an error.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; undefined (does not fail with error).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { failWithError: true });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                    &lt;details&gt;                    &lt;summary&gt;7. keepSessionInfo&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; Whether to keep session information.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; undefined (session info is not specifically retained).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { keepSessionInfo: true });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                    &lt;details&gt;                    &lt;summary&gt;8. session&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; Save login state in session.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; true (session is used by default).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { session: false });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                    &lt;details&gt;                    &lt;summary&gt;9. scope&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; Scope of access required.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; undefined (no scope is specified).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { scope: ['read', 'write'] });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                    &lt;details&gt;                    &lt;summary&gt;10. successFlash&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; True to flash success messages or a string to use as a flash message for success.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; undefined (success messages are not flashed).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { successFlash: 'Login successful' });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                    &lt;details&gt;                    &lt;summary&gt;11. successMessage&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; True to store success message in &lt;code&gt;req.session.messages&lt;/code&gt;, or a string to use as an override message for success.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; undefined (success messages are not stored).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { successMessage: 'Welcome back!' });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                    &lt;details&gt;                    &lt;summary&gt;12. successRedirect&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; URL to redirect to after a successful login.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; undefined (no redirect occurs).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { successRedirect: '/dashboard' });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                    &lt;details&gt;                    &lt;summary&gt;13. successReturnToOrRedirect&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; URL to redirect to or return to after a successful login.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; undefined (no redirect or return occurs).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { successReturnToOrRedirect: '/profile' });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                    &lt;details&gt;                    &lt;summary&gt;14. state&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; State parameter for the request.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; undefined (no state is set).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { state: 'xyz' });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                    &lt;details&gt;                    &lt;summary&gt;15. pauseStream&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; Pause the request stream before deserializing the user object from the session.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; false (stream is not paused).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { pauseStream: true });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                    &lt;details&gt;                    &lt;summary&gt;16. userProperty&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; Property on &lt;code&gt;req&lt;/code&gt; that will be set to the authenticated user object.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; 'user' (authenticated user is set to &lt;code&gt;req.user&lt;/code&gt;).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { userProperty: 'currentUser' });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                    &lt;details&gt;                    &lt;summary&gt;17. passReqToCallback&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; Whether to pass the request object to the callback.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; undefined (request object is not passed to the callback).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Overrides:&lt;/strong&gt; Overrides passReqToCallback set in opts of strategy configuration&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { passReqToCallback: true });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                    &lt;details&gt;                    &lt;summary&gt;18. prompt&lt;/summary&gt;                    &lt;p&gt;&lt;strong&gt;Description:&lt;/strong&gt; Prompt parameter for the request.&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Default:&lt;/strong&gt; undefined (no prompt is set).&lt;/p&gt;                    &lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;                    &lt;pre&gt;&lt;code&gt;passport.authenticate('strategy', { prompt: 'login' });&lt;/code&gt;&lt;/pre&gt;                    &lt;/details&gt;                &lt;/details&gt;            - &lt;details&gt;                &lt;summary&gt;                    &lt;code&gt;callback&lt;/code&gt;: (function) [optional]                &lt;/summary&gt;                - **Purpose**: Handles the result of the authentication process and provides feedback or further actions based on the outcome.                - **Parameters**:                    1. &lt;details&gt;                        &lt;summary&gt;                            &lt;code&gt;err&lt;/code&gt;: (Error or &lt;code&gt;null&lt;/code&gt;)                        &lt;/summary&gt;                        - **Description**: Contains any error that occurred during the authentication process.                        - **Type**: err | false                        - **Example**: An error object if something went wrong, otherwise `null`.                        &lt;/details&gt;                    2. &lt;details&gt;                        &lt;summary&gt;                            &lt;code&gt;user&lt;/code&gt;: (object | string | Array)                        &lt;/summary&gt;                        - **Description**: The authenticated user object if authentication was successful, or `false` if no user was authenticated.                        - **Type**: User | false | null                        - **Example**: The user data retrieved from the database if authentication is successful.                        &lt;/details&gt;                    3. &lt;details&gt;                        &lt;summary&gt;                            &lt;code&gt;info&lt;/code&gt;: (Object or &lt;code&gt;false&lt;/code&gt;)                        &lt;/summary&gt;                        - **Description**: Contains additional information or error messages about the authentication process. This can include details about why authentication failed.                        - **Type**: object | string | Array                        - **Example**: An object with a `message` property if authentication fails, or `false` if no additional information is available.                        &lt;/details&gt;                    4. &lt;details&gt;                        &lt;summary&gt;                            &lt;code&gt;status&lt;/code&gt;: (number | Array)                        &lt;/summary&gt;                        - **Description**: The HTTP status code representing the result of the authentication attempt.                        - **Type**: number | Array (HTTP status code)                        - **Example**: `401` for unauthorized access, `200` for successful authentication.                        &lt;/details&gt;                &lt;/details&gt;        - Examples:            ```js            //default strategy without optional parameters            app.post(\"/profile\", (req, res, next) =&gt; {                passport.authenticate(\"jwt\")(req, res, next)            });            ```            &lt;details&gt;                &lt;summary&gt;                more examples                &lt;/summary&gt;                ```js                //custom strategy without optional parameters                app.post(\"/profile\", (req, res, next) =&gt; {                    passport.authenticate(\"my-jwt\")(req, res, next)                });                ```                ```js                //default strategy with optional parameters                app.post(\"/profile\", (req, res, next) =&gt; {                    passport.authenticate(\"jwt\", { session: false }, function(err, user, info, status) {                        if (err) {                            return res                                    .status(500)                                    .json({ message: 'An error occurred', error: err });                        }                        if (!user) {                            return res                                    .status(401)                                    .json({ message: 'Unauthorized', info: info });                        }                        //in case of callback we need to set req.user=user                        req.user=user                        res.send(status).json(user.profile);                    })(req, res, next)                });                ```                &lt;/details&gt;        &lt;/details&gt;    - &lt;details&gt;        &lt;summary&gt;        &lt;code&gt;passport.serializeUser()&lt;/code&gt; from passport        &lt;/summary&gt;        - We need passport.serializeUser() during the process of logIn which happens inside passport.authenticate()        - &lt;details&gt;            &lt;summary&gt;Input parameter: &lt;code&gt;callback function&lt;/code&gt;            &lt;/summary&gt;            - &lt;details&gt;&lt;summary&gt;input parameters of cb fn: &lt;code&gt;user&lt;/code&gt;, &lt;code&gt;done&lt;/code&gt;&lt;/summary&gt;                - `user`: The user object returned from the authentication process.                - &lt;details&gt;&lt;summary&gt;&lt;code&gt;done&lt;/code&gt;: A callback function that you call after serializing the user, which takes two parameters: &lt;code&gt;err&lt;/code&gt;, &lt;code&gt;id&lt;/code&gt;&lt;/summary&gt;                    - `err`: Any error that occurred during serialization.                    - `id`: The user ID or any unique identifier that will be stored in the session.                    ```js                    passport.serializeUser((user, done)=&gt;{                        done(err, id)                    });                    ```                    &lt;/details&gt;                ```js                passport.serializeUser((user, done)=&gt;{});                ```                &lt;/details&gt;            ```js            passport.serializeUser(callback);            ```            &lt;/details&gt;        ```js        // structure of serialiseUser        passport.serializeUser((user, done) =&gt; {            done(null, user.id);        });        //err can be null or err        //user can be false, user, user.id, or anything related to user        ```        &lt;/details&gt;    - &lt;details&gt;        &lt;summary&gt;        &lt;code&gt;session()&lt;/code&gt; from express-session        &lt;/summary&gt;        - session() is also necssary to logIn using passport.authenticate()        - Parameter: `sessionOptions` (object)        - So structure is `session(sessionOptions)        - ```js            //structure of session            const express = require(\"express\");            const session = require(\"express-session\");            const app = express()            app.use(session({                    secret: process.env.SESSION_SECRET,                resave: false,                    saveUninitialized: false,            }))            ```        - Session option keys:            &lt;details&gt;            &lt;summary&gt;&lt;strong&gt;1. secret&lt;/strong&gt;&lt;/summary&gt;            &lt;ul&gt;                &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; string | array&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; N/A&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; String(s) used to sign the session ID cookie.&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;secret: 'mySecret'&lt;/code&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;/details&gt;            &lt;details&gt;            &lt;summary&gt;&lt;strong&gt;2. genid(req)&lt;/strong&gt;&lt;/summary&gt;            &lt;ul&gt;                &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; function [(req: express.Request) =&gt; string]&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; Uses uid-safe library to generate a unique session ID.&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Function to generate session IDs.&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;genid: () =&gt; 'customID'&lt;/code&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;/details&gt;            &lt;details&gt;            &lt;summary&gt;&lt;strong&gt;3. name&lt;/strong&gt;&lt;/summary&gt;            &lt;ul&gt;                &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; string &lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; 'connect.sid'&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Name of the session ID cookie.&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;name: 'session_id'&lt;/code&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;/details&gt;            &lt;details&gt;            &lt;summary&gt;&lt;strong&gt;4. store&lt;/strong&gt;&lt;/summary&gt;            &lt;ul&gt;                &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; Store &lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; MemoryStore (in-memory session store)&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Specifies session store instance.&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;store: new RedisStore()&lt;/code&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;/details&gt;            &lt;details&gt;            &lt;summary&gt;&lt;strong&gt;5. cookie&lt;/strong&gt;&lt;/summary&gt;            &lt;ul&gt;                &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; object &lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; N/A&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Options for the session cookie (e.g., maxAge, secure).&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;CookieOptions:&lt;/strong&gt;                &lt;details&gt;                    &lt;summary&gt;&lt;strong&gt;1. maxAge&lt;/strong&gt;&lt;/summary&gt;                    &lt;ul&gt;                        &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; number &lt;/li&gt;                        &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; N/A&lt;/li&gt;                        &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Specifies the maximum age of the cookie in milliseconds.&lt;/li&gt;                        &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;maxAge: 3600000&lt;/code&gt; (1 hour)&lt;/li&gt;                    &lt;/ul&gt;                    &lt;/details&gt;            &lt;details&gt;                &lt;summary&gt;&lt;strong&gt;2. partitioned&lt;/strong&gt;&lt;/summary&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; boolean &lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; false&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Specifies the `Partitioned` attribute for the cookie. Not fully standardized yet.&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;partitioned: true&lt;/code&gt;&lt;/li&gt;                &lt;/ul&gt;                &lt;/details&gt;            &lt;details&gt;                &lt;summary&gt;&lt;strong&gt;3. priority&lt;/strong&gt;&lt;/summary&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; \"low\" | \"medium\" | \"high\" &lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; \"medium\"&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Specifies the `Priority` attribute of the cookie (low, medium, or high).&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;priority: 'high'&lt;/code&gt;&lt;/li&gt;                &lt;/ul&gt;                &lt;/details&gt;            &lt;details&gt;                &lt;summary&gt;&lt;strong&gt;4. signed&lt;/strong&gt;&lt;/summary&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; boolean &lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; false&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Specifies whether the cookie is signed with the secret.&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;signed: true&lt;/code&gt;&lt;/li&gt;                &lt;/ul&gt;                &lt;/details&gt;            &lt;details&gt;                &lt;summary&gt;&lt;strong&gt;5. expires&lt;/strong&gt;&lt;/summary&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; Date | null &lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; No expiration set (non-persistent cookie).&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Specifies the expiration date for the cookie.&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;expires: new Date(Date.now() + 3600000)&lt;/code&gt;&lt;/li&gt;                &lt;/ul&gt;                &lt;/details&gt;            &lt;details&gt;                &lt;summary&gt;&lt;strong&gt;6. httpOnly&lt;/strong&gt;&lt;/summary&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; boolean &lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; true&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Specifies whether the cookie is HTTP-only, preventing access from client-side JavaScript.&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;httpOnly: false&lt;/code&gt;&lt;/li&gt;                &lt;/ul&gt;                &lt;/details&gt;            &lt;details&gt;                &lt;summary&gt;&lt;strong&gt;7. path&lt;/strong&gt;&lt;/summary&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; string &lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; '/'&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Specifies the path for which the cookie is valid.&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;path: '/admin'&lt;/code&gt;&lt;/li&gt;                &lt;/ul&gt;                &lt;/details&gt;            &lt;details&gt;                &lt;summary&gt;&lt;strong&gt;8. domain&lt;/strong&gt;&lt;/summary&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; string &lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; No domain set.&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Specifies the domain for which the cookie is valid.&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;domain: 'example.com'&lt;/code&gt;&lt;/li&gt;                &lt;/ul&gt;                &lt;/details&gt;            &lt;details&gt;                &lt;summary&gt;&lt;strong&gt;9. secure&lt;/strong&gt;&lt;/summary&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; boolean | \"auto\" &lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; false&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Specifies whether the cookie is only sent over HTTPS.&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;secure: true&lt;/code&gt;&lt;/li&gt;                &lt;/ul&gt;                &lt;/details&gt;            &lt;details&gt;                &lt;summary&gt;&lt;strong&gt;10. encode&lt;/strong&gt;&lt;/summary&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; (val: string) =&gt; string &lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; Default encoder for cookie values.&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Specifies a custom encoding function for the cookie value.&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;encode: encodeURIComponent&lt;/code&gt;&lt;/li&gt;                &lt;/ul&gt;                &lt;/details&gt;            &lt;details&gt;                &lt;summary&gt;&lt;strong&gt;11. sameSite&lt;/strong&gt;&lt;/summary&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; boolean | \"lax\" | \"strict\" | \"none\" &lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; false&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Specifies the `SameSite` attribute for cross-site cookie control (strict, lax, or none).&lt;/li&gt;                    &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;sameSite: 'strict'&lt;/code&gt;&lt;/li&gt;                &lt;/ul&gt;                &lt;/details&gt;            &lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;cookie: { maxAge: 60000 }&lt;/code&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;/details&gt;            &lt;details&gt;            &lt;summary&gt;&lt;strong&gt;6. rolling&lt;/strong&gt;&lt;/summary&gt;            &lt;ul&gt;                &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; boolean &lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; false&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Resets session expiration on every response.&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;rolling: true&lt;/code&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;/details&gt;            &lt;details&gt;            &lt;summary&gt;&lt;strong&gt;7. resave&lt;/strong&gt;&lt;/summary&gt;            &lt;ul&gt;                &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; boolean &lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; true (deprecated)&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Forces session to be saved on every request, even if unmodified.&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;resave: false&lt;/code&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;/details&gt;            &lt;details&gt;            &lt;summary&gt;&lt;strong&gt;8. proxy&lt;/strong&gt;&lt;/summary&gt;            &lt;ul&gt;                &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; boolean &lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; undefined&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Trust reverse proxy when setting secure cookies.&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;proxy: true&lt;/code&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;/details&gt;            &lt;details&gt;            &lt;summary&gt;&lt;strong&gt;9. saveUninitialized&lt;/strong&gt;&lt;/summary&gt;            &lt;ul&gt;                &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; boolean &lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; true (deprecated)&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Saves uninitialized sessions. Useful for login sessions.&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;saveUninitialized: false&lt;/code&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;/details&gt;            &lt;details&gt;            &lt;summary&gt;&lt;strong&gt;10. unset&lt;/strong&gt;&lt;/summary&gt;            &lt;ul&gt;                &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; \"destroy\" | \"keep\" &lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Default:&lt;/strong&gt; 'keep'&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Description:&lt;/strong&gt; Controls behavior when session is deleted.&lt;/li&gt;                &lt;li&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;unset: 'destroy'&lt;/code&gt;&lt;/li&gt;            &lt;/ul&gt;            &lt;/details&gt;            &lt;/details&gt;- Complete structure for authentication:    ```js    const express = require('express');    const session = require(\"express-session\");    const passport = require(\"passport\");    const app = express()    app.use(session({ //to be called on top        secret: process.env.SESSION_SECRET,    }))    app.use((req, res, next)=&gt;{ //can be called anywhere        passport.authenticate('jwt')(req, res, next)    })    passport.serializeUser(()=&gt;{    })    ```      Sending jwt from client to server      Using Authorisation header (most common)-         Bearer Token: The most common and standard method for JWTs.      ```js  // Client-side (e.g., using Axios in JavaScript)  axios.get(\"/protected-resource\", {    headers: {      Authorization: `Bearer ${token}`,    },  });  // Server-side (Express with Passport)  const opts = {    jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), // Extract JWT from Bearer Token    secretOrKey: SECRET_KEY,  };  ```    -         Custom Scheme: Allows custom authentication schemes as needed.      ```js  // Client-side (e.g., using Axios in JavaScript)  axios.get(\"/protected-resource\", {    headers: {      Authorization: `Bearer ${token}`,    },  });  // Server-side (Express)  const customSchemeExtractor = (req) =&gt; {    const authHeader = req.headers[\"authorization\"];    if (authHeader &amp;&amp; authHeader.startsWith(\"customScheme \")) {      return authHeader.split(\" \")[1];    }    return null;  };  const opts = {    jwtFromRequest: customSchemeExtractor, // Use custom extractor    secretOrKey: SECRET_KEY,  };  ```    -         Digest Authentication: Less common for JWTs, used in specific scenarios.      ```js  // Client-side (e.g., using Axios in JavaScript)  axios.get(\"/protected-resource\", {    headers: {      Authorization: `Digest ${token}`,    },  });  // Server-side (Express)  const digestExtractor = (req) =&gt; {    const authHeader = req.headers[\"authorization\"];    if (authHeader &amp;&amp; authHeader.startsWith(\"Digest \")) {      return authHeader.split(\" \")[1];    }    return null;  };  const opts = {    jwtFromRequest: digestExtractor, // Use custom extractor    secretOrKey: SECRET_KEY,  };  ```    -             Basic Authentication: Typically used for credentials, not recommended for JWTs.            ```js      // (Not Recommended for JWTs)      // Client-side (e.g., using Axios in JavaScript)      axios.get('/protected-resource', {           headers: {              'Authorization': `Basic ${token}`          }      });      // Server-side (Express)      const basicExtractor = (req) =&gt; {          const authHeader = req.headers['authorization'];          if (authHeader &amp;&amp; authHeader.startsWith('Basic ')) {              return authHeader.split(' ')[1];          }          return null;      };  const opts = {  jwtFromRequest: basicExtractor, // Use custom extractor  secretOrKey: SECRET_KEY,  }  ```            Using cookies- For client side: - We dont have to do anything. just run both server an dclient on same url (eg: http://localhost:3000), client using build file and server direclty running using node index. - when both run on same server: - cookies sent to client from sever will be stored as Set-Cookies in header and - server itself will read it back when any req is sent from client to server  ```js  //client side  axios.get('/protected-resource')      // server side      const cookieParser = require('cookie-parser')      const express = require('express');      const app = express()      app.use(cookieParser())      //custom extractor      var cookieExtractor = function (req) {      var token = null;      if (req &amp;&amp; req.cookies) {          token = req.cookies[\"jwt\"];      }      return token;      };      const opts = {          jwtFromRequest: cookieExtractor,          secretOrKey: 'your_secret_key'      };      ```          Using URL Query Parameters```js// Client-side (e.g., using Axios)axios.get(\"/protected-resource?token=\" + token);// Custom extractor function for query parametersconst queryParamExtractor = (req) =&gt; {  return req.query.token; // Extract JWT from query parameter 'token'};const opts = {  jwtFromRequest: queryParamExtractor, // Use custom extractor  secretOrKey: SECRET_KEY,};```        Using Custom Headers```js// Client-side (e.g., using Axios)axios.get(\"/protected-resource\", {  headers: {    \"X-Custom-Header\": token, // Replace 'X-Custom-Header' with your custom header name  },});// Custom extractor function for custom headersconst customHeaderExtractor = (req) =&gt; {  return req.headers[\"x-custom-header\"]; // Replace 'x-custom-header' with your custom header name};const opts = {  jwtFromRequest: customHeaderExtractor, // Use custom extractor  secretOrKey: SECRET_KEY,};```  "
    }
  
]
 