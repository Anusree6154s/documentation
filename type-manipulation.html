<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>More about Type Manipulation | Bits &amp; Bytes</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="More about Type Manipulation" />
<meta name="author" content="Anusree Anilkumar" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Type Manipulation in TypeScript Type manipulation in TypeScript refers to the ability to transform or infer types based on certain conditions, allowing you to create more flexible and reusable code. TypeScript provides powerful tools for manipulating types, such as infer, conditional types, and utility types, among others. Here’s an overview of these key concepts: 1. Conditional Types Conditional types allow you to select one type over another based on a condition. This is similar to a ternary operator (condition ? true : false) but for types. Basic Syntax: type ConditionalType&lt;T&gt; = T extends SomeCondition ? TrueType : FalseType; In this example, T is checked against SomeCondition. If it matches, the result is TrueType; otherwise, it will be FalseType. 2. infer Keyword for Type Inference The infer keyword allows you to extract a type from a more complex type within conditional types. It’s especially useful for situations where you want to infer the type of a function’s return value, arguments, or other components without having to explicitly define it. Example of infer with ReturnType: type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never; Here, ReturnType&lt;T&gt; is a conditional type that: Checks if T is a function (denoted by (...args: any[]) =&gt;). If T is a function, it infers the return type of that function and assigns it to R. If T is not a function, it returns never (meaning an invalid type). Usage Example: type MyFunction = (x: number, y: number) =&gt; string; type Result = ReturnType&lt;MyFunction&gt;; // Result will be `string` Here, the type Result will be string because the function MyFunction returns a string. The ReturnType utility extracts that return type. 3. Common Use Cases for Type Manipulation Extracting Function Arguments You can use the infer keyword to extract the types of function parameters as well. type ParameterType&lt;T&gt; = T extends (arg: infer U) =&gt; any ? U : never; type MyFunction = (x: number) =&gt; string; type Param = ParameterType&lt;MyFunction&gt;; // Param will be `number` In this example, ParameterType extracts the type of the parameter passed to the function. If MyFunction takes a number, then Param will be number. Discriminated Unions with infer You can use infer to narrow types in conditional types when dealing with discriminated unions. type Shape = | { kind: &#39;circle&#39;, radius: number } | { kind: &#39;square&#39;, sideLength: number }; type GetShapeType&lt;T&gt; = T extends { kind: &#39;circle&#39; } ? &#39;Circle&#39; : T extends { kind: &#39;square&#39; } ? &#39;Square&#39; : never; type CircleType = GetShapeType&lt;{ kind: &#39;circle&#39;, radius: 10 }&gt;; // &#39;Circle&#39; type SquareType = GetShapeType&lt;{ kind: &#39;square&#39;, sideLength: 20 }&gt;; // &#39;Square&#39; Here, we use a conditional type to map over a discriminated union to extract the types based on the kind property. 4. Using Utility Types for Type Transformation TypeScript also offers a range of utility types that make it easier to manipulate types in common scenarios. These types include Partial, Required, Readonly, Record, etc. Example: Pick, Omit, and Exclude interface Person { name: string; age: number; address: string; } // Pick specific keys from the interface type NameAndAge = Pick&lt;Person, &#39;name&#39; | &#39;age&#39;&gt;; // { name: string; age: number } // Omit specific keys from the interface type WithoutAddress = Omit&lt;Person, &#39;address&#39;&gt;; // { name: string; age: number } // Exclude specific types from a union type WithoutString = Exclude&lt;string | number | boolean, string&gt;; // number | boolean Pick&lt;T, K&gt;: Picks a subset of properties from a type T. Omit&lt;T, K&gt;: Omit specific properties from a type T. Exclude&lt;T, U&gt;: Excludes types from a union type. These utility types are often used for type manipulation, allowing you to create new types based on existing ones. 5. Key Takeaways of Type Manipulation Concept Explanation Example Conditional Types Types that select one type over another based on a condition. type IsString&lt;T&gt; = T extends string ? true : false; infer Keyword Extracts a type within a conditional type, useful for inferring function return types or extracting types from more complex types. type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never; Function Arguments Extracts the types of function arguments. type Param&lt;T&gt; = T extends (arg: infer U) =&gt; any ? U : never; Discriminated Unions Conditional types combined with discriminated unions to narrow down types. type ShapeType&lt;T&gt; = T extends { kind: &#39;circle&#39; } ? &#39;Circle&#39; : T extends { kind: &#39;square&#39; } ? &#39;Square&#39; : never; Utility Types Built-in utility types like Pick, Omit, Partial, Required, and Exclude allow transformation of types in useful ways. type NameAndAge = Pick&lt;Person, &#39;name&#39; | &#39;age&#39;&gt;; 6. Conclusion Type manipulation in TypeScript allows you to create flexible, reusable, and strongly typed code by leveraging the power of conditional types, infer, and utility types. These tools enable complex type transformations that are both expressive and maintainable, making TypeScript a robust language for building large and scalable applications." />
<meta property="og:description" content="Type Manipulation in TypeScript Type manipulation in TypeScript refers to the ability to transform or infer types based on certain conditions, allowing you to create more flexible and reusable code. TypeScript provides powerful tools for manipulating types, such as infer, conditional types, and utility types, among others. Here’s an overview of these key concepts: 1. Conditional Types Conditional types allow you to select one type over another based on a condition. This is similar to a ternary operator (condition ? true : false) but for types. Basic Syntax: type ConditionalType&lt;T&gt; = T extends SomeCondition ? TrueType : FalseType; In this example, T is checked against SomeCondition. If it matches, the result is TrueType; otherwise, it will be FalseType. 2. infer Keyword for Type Inference The infer keyword allows you to extract a type from a more complex type within conditional types. It’s especially useful for situations where you want to infer the type of a function’s return value, arguments, or other components without having to explicitly define it. Example of infer with ReturnType: type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never; Here, ReturnType&lt;T&gt; is a conditional type that: Checks if T is a function (denoted by (...args: any[]) =&gt;). If T is a function, it infers the return type of that function and assigns it to R. If T is not a function, it returns never (meaning an invalid type). Usage Example: type MyFunction = (x: number, y: number) =&gt; string; type Result = ReturnType&lt;MyFunction&gt;; // Result will be `string` Here, the type Result will be string because the function MyFunction returns a string. The ReturnType utility extracts that return type. 3. Common Use Cases for Type Manipulation Extracting Function Arguments You can use the infer keyword to extract the types of function parameters as well. type ParameterType&lt;T&gt; = T extends (arg: infer U) =&gt; any ? U : never; type MyFunction = (x: number) =&gt; string; type Param = ParameterType&lt;MyFunction&gt;; // Param will be `number` In this example, ParameterType extracts the type of the parameter passed to the function. If MyFunction takes a number, then Param will be number. Discriminated Unions with infer You can use infer to narrow types in conditional types when dealing with discriminated unions. type Shape = | { kind: &#39;circle&#39;, radius: number } | { kind: &#39;square&#39;, sideLength: number }; type GetShapeType&lt;T&gt; = T extends { kind: &#39;circle&#39; } ? &#39;Circle&#39; : T extends { kind: &#39;square&#39; } ? &#39;Square&#39; : never; type CircleType = GetShapeType&lt;{ kind: &#39;circle&#39;, radius: 10 }&gt;; // &#39;Circle&#39; type SquareType = GetShapeType&lt;{ kind: &#39;square&#39;, sideLength: 20 }&gt;; // &#39;Square&#39; Here, we use a conditional type to map over a discriminated union to extract the types based on the kind property. 4. Using Utility Types for Type Transformation TypeScript also offers a range of utility types that make it easier to manipulate types in common scenarios. These types include Partial, Required, Readonly, Record, etc. Example: Pick, Omit, and Exclude interface Person { name: string; age: number; address: string; } // Pick specific keys from the interface type NameAndAge = Pick&lt;Person, &#39;name&#39; | &#39;age&#39;&gt;; // { name: string; age: number } // Omit specific keys from the interface type WithoutAddress = Omit&lt;Person, &#39;address&#39;&gt;; // { name: string; age: number } // Exclude specific types from a union type WithoutString = Exclude&lt;string | number | boolean, string&gt;; // number | boolean Pick&lt;T, K&gt;: Picks a subset of properties from a type T. Omit&lt;T, K&gt;: Omit specific properties from a type T. Exclude&lt;T, U&gt;: Excludes types from a union type. These utility types are often used for type manipulation, allowing you to create new types based on existing ones. 5. Key Takeaways of Type Manipulation Concept Explanation Example Conditional Types Types that select one type over another based on a condition. type IsString&lt;T&gt; = T extends string ? true : false; infer Keyword Extracts a type within a conditional type, useful for inferring function return types or extracting types from more complex types. type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never; Function Arguments Extracts the types of function arguments. type Param&lt;T&gt; = T extends (arg: infer U) =&gt; any ? U : never; Discriminated Unions Conditional types combined with discriminated unions to narrow down types. type ShapeType&lt;T&gt; = T extends { kind: &#39;circle&#39; } ? &#39;Circle&#39; : T extends { kind: &#39;square&#39; } ? &#39;Square&#39; : never; Utility Types Built-in utility types like Pick, Omit, Partial, Required, and Exclude allow transformation of types in useful ways. type NameAndAge = Pick&lt;Person, &#39;name&#39; | &#39;age&#39;&gt;; 6. Conclusion Type manipulation in TypeScript allows you to create flexible, reusable, and strongly typed code by leveraging the power of conditional types, infer, and utility types. These tools enable complex type transformations that are both expressive and maintainable, making TypeScript a robust language for building large and scalable applications." />
<link rel="canonical" href="https://anusree6154s.github.io/documentation/type-manipulation" />
<meta property="og:url" content="https://anusree6154s.github.io/documentation/type-manipulation" />
<meta property="og:site_name" content="Bits &amp; Bytes" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-01-19T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="More about Type Manipulation" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Anusree Anilkumar"},"dateModified":"2025-01-19T00:00:00+00:00","datePublished":"2025-01-19T00:00:00+00:00","description":"Type Manipulation in TypeScript Type manipulation in TypeScript refers to the ability to transform or infer types based on certain conditions, allowing you to create more flexible and reusable code. TypeScript provides powerful tools for manipulating types, such as infer, conditional types, and utility types, among others. Here’s an overview of these key concepts: 1. Conditional Types Conditional types allow you to select one type over another based on a condition. This is similar to a ternary operator (condition ? true : false) but for types. Basic Syntax: type ConditionalType&lt;T&gt; = T extends SomeCondition ? TrueType : FalseType; In this example, T is checked against SomeCondition. If it matches, the result is TrueType; otherwise, it will be FalseType. 2. infer Keyword for Type Inference The infer keyword allows you to extract a type from a more complex type within conditional types. It’s especially useful for situations where you want to infer the type of a function’s return value, arguments, or other components without having to explicitly define it. Example of infer with ReturnType: type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never; Here, ReturnType&lt;T&gt; is a conditional type that: Checks if T is a function (denoted by (...args: any[]) =&gt;). If T is a function, it infers the return type of that function and assigns it to R. If T is not a function, it returns never (meaning an invalid type). Usage Example: type MyFunction = (x: number, y: number) =&gt; string; type Result = ReturnType&lt;MyFunction&gt;; // Result will be `string` Here, the type Result will be string because the function MyFunction returns a string. The ReturnType utility extracts that return type. 3. Common Use Cases for Type Manipulation Extracting Function Arguments You can use the infer keyword to extract the types of function parameters as well. type ParameterType&lt;T&gt; = T extends (arg: infer U) =&gt; any ? U : never; type MyFunction = (x: number) =&gt; string; type Param = ParameterType&lt;MyFunction&gt;; // Param will be `number` In this example, ParameterType extracts the type of the parameter passed to the function. If MyFunction takes a number, then Param will be number. Discriminated Unions with infer You can use infer to narrow types in conditional types when dealing with discriminated unions. type Shape = | { kind: &#39;circle&#39;, radius: number } | { kind: &#39;square&#39;, sideLength: number }; type GetShapeType&lt;T&gt; = T extends { kind: &#39;circle&#39; } ? &#39;Circle&#39; : T extends { kind: &#39;square&#39; } ? &#39;Square&#39; : never; type CircleType = GetShapeType&lt;{ kind: &#39;circle&#39;, radius: 10 }&gt;; // &#39;Circle&#39; type SquareType = GetShapeType&lt;{ kind: &#39;square&#39;, sideLength: 20 }&gt;; // &#39;Square&#39; Here, we use a conditional type to map over a discriminated union to extract the types based on the kind property. 4. Using Utility Types for Type Transformation TypeScript also offers a range of utility types that make it easier to manipulate types in common scenarios. These types include Partial, Required, Readonly, Record, etc. Example: Pick, Omit, and Exclude interface Person { name: string; age: number; address: string; } // Pick specific keys from the interface type NameAndAge = Pick&lt;Person, &#39;name&#39; | &#39;age&#39;&gt;; // { name: string; age: number } // Omit specific keys from the interface type WithoutAddress = Omit&lt;Person, &#39;address&#39;&gt;; // { name: string; age: number } // Exclude specific types from a union type WithoutString = Exclude&lt;string | number | boolean, string&gt;; // number | boolean Pick&lt;T, K&gt;: Picks a subset of properties from a type T. Omit&lt;T, K&gt;: Omit specific properties from a type T. Exclude&lt;T, U&gt;: Excludes types from a union type. These utility types are often used for type manipulation, allowing you to create new types based on existing ones. 5. Key Takeaways of Type Manipulation Concept Explanation Example Conditional Types Types that select one type over another based on a condition. type IsString&lt;T&gt; = T extends string ? true : false; infer Keyword Extracts a type within a conditional type, useful for inferring function return types or extracting types from more complex types. type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never; Function Arguments Extracts the types of function arguments. type Param&lt;T&gt; = T extends (arg: infer U) =&gt; any ? U : never; Discriminated Unions Conditional types combined with discriminated unions to narrow down types. type ShapeType&lt;T&gt; = T extends { kind: &#39;circle&#39; } ? &#39;Circle&#39; : T extends { kind: &#39;square&#39; } ? &#39;Square&#39; : never; Utility Types Built-in utility types like Pick, Omit, Partial, Required, and Exclude allow transformation of types in useful ways. type NameAndAge = Pick&lt;Person, &#39;name&#39; | &#39;age&#39;&gt;; 6. Conclusion Type manipulation in TypeScript allows you to create flexible, reusable, and strongly typed code by leveraging the power of conditional types, infer, and utility types. These tools enable complex type transformations that are both expressive and maintainable, making TypeScript a robust language for building large and scalable applications.","headline":"More about Type Manipulation","mainEntityOfPage":{"@type":"WebPage","@id":"https://anusree6154s.github.io/documentation/type-manipulation"},"url":"https://anusree6154s.github.io/documentation/type-manipulation"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/documentation/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://anusree6154s.github.io/documentation/feed.xml" title="Bits &amp; Bytes" /></head>
<body><header class="site-header">
  <div class="loader"></div>

    <div class="wrapper"><!-- <a class="site-title" rel="author" href="/documentation/">Bits &amp; Bytes</a> -->
          <a class="site-title"  rel="author" href="/documentation/"><span>BITS</span><span> & </span><span>BYTES</span></a><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewBox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
              </svg>
            </span>
          </label>
  
          <div class="trigger">
            <!--<a class="page-link" href="/documentation/about">About Me</a>-->

            <a class="page-link" href="/documentation/#latest-posts">LATEST POSTS</a>
            <a class="page-link" href="/documentation/all-posts">ALL POSTS</a>
            <a class="page-link" href="/documentation/#projects">PROJECTS</a>
            <a class="page-link" href="/documentation/#profile">PROFILE</a>
            <a class="page-link" href="/documentation/#contact">CONTACT</a>
          </div>
        </nav></div>
    
  </header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  


  <header class="post-header">
    
      
        <div class="parent-link">
          This post is part of <a href="/documentation/typescript-learners-guide">Typescript learners guide</a>.
        </div>
    
    <h1 class="post-title p-name" itemprop="name headline">More about Type Manipulation</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-01-19T00:00:00+00:00" itemprop="datePublished">19 Jan 2025
      </time></p>
      <p class="tag-container"><span  class="tag-badge">
            typescript
        </span><span  class="tag-badge">
            type manipulation
        </span></span>
</p>
  </header> 

  

  <div class="post-content e-content" itemprop="articleBody">
    <h3 id="type-manipulation-in-typescript"><strong>Type Manipulation in TypeScript</strong></h3>

<p><strong>Type manipulation</strong> in TypeScript refers to the ability to <strong>transform</strong> or <strong>infer</strong> types based on certain conditions, allowing you to create more flexible and reusable code. TypeScript provides powerful tools for manipulating types, such as <code class="language-plaintext highlighter-rouge">infer</code>, <strong>conditional types</strong>, and utility types, among others. Here’s an overview of these key concepts:</p>

<p><br /></p>

<h3 id="1-conditional-types"><strong>1. Conditional Types</strong></h3>

<p>Conditional types allow you to select one type over another based on a condition. This is similar to a ternary operator (<code class="language-plaintext highlighter-rouge">condition ? true : false</code>) but for types.</p>

<p><strong>Basic Syntax:</strong></p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ConditionalType</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="nx">SomeCondition</span> <span class="p">?</span> <span class="nx">TrueType</span> <span class="p">:</span> <span class="nx">FalseType</span><span class="p">;</span>
</code></pre></div></div>

<p>In this example, <code class="language-plaintext highlighter-rouge">T</code> is checked against <code class="language-plaintext highlighter-rouge">SomeCondition</code>. If it matches, the result is <code class="language-plaintext highlighter-rouge">TrueType</code>; otherwise, it will be <code class="language-plaintext highlighter-rouge">FalseType</code>.</p>

<p><br /></p>

<h3 id="2-infer-keyword-for-type-inference"><strong>2. <code class="language-plaintext highlighter-rouge">infer</code> Keyword for Type Inference</strong></h3>

<p>The <code class="language-plaintext highlighter-rouge">infer</code> keyword allows you to <strong>extract</strong> a type from a more complex type within conditional types. It’s especially useful for situations where you want to <strong>infer</strong> the type of a function’s return value, arguments, or other components without having to explicitly define it.</p>

<p><strong>Example of <code class="language-plaintext highlighter-rouge">infer</code> with <code class="language-plaintext highlighter-rouge">ReturnType</code>:</strong></p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ReturnType</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="p">(...</span><span class="nx">args</span><span class="p">:</span> <span class="kr">any</span><span class="p">[])</span> <span class="o">=&gt;</span> <span class="nx">infer</span> <span class="nx">R</span> <span class="p">?</span> <span class="nx">R</span> <span class="p">:</span> <span class="nx">never</span><span class="p">;</span>
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">ReturnType&lt;T&gt;</code> is a conditional type that:</p>

<ul>
  <li>Checks if <code class="language-plaintext highlighter-rouge">T</code> is a function (denoted by <code class="language-plaintext highlighter-rouge">(...args: any[]) =&gt;</code>).</li>
  <li>If <code class="language-plaintext highlighter-rouge">T</code> is a function, it <strong>infers</strong> the return type of that function and assigns it to <code class="language-plaintext highlighter-rouge">R</code>.</li>
  <li>If <code class="language-plaintext highlighter-rouge">T</code> is not a function, it returns <code class="language-plaintext highlighter-rouge">never</code> (meaning an invalid type).</li>
</ul>

<p><strong>Usage Example:</strong></p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">MyFunction</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">y</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">string</span><span class="p">;</span>

<span class="kd">type</span> <span class="nx">Result</span> <span class="o">=</span> <span class="nx">ReturnType</span><span class="o">&lt;</span><span class="nx">MyFunction</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// Result will be `string`</span>
</code></pre></div></div>

<p>Here, the type <code class="language-plaintext highlighter-rouge">Result</code> will be <code class="language-plaintext highlighter-rouge">string</code> because the function <code class="language-plaintext highlighter-rouge">MyFunction</code> returns a <code class="language-plaintext highlighter-rouge">string</code>. The <code class="language-plaintext highlighter-rouge">ReturnType</code> utility extracts that return type.</p>

<p><br /></p>

<h3 id="3-common-use-cases-for-type-manipulation"><strong>3. Common Use Cases for Type Manipulation</strong></h3>

<h4 id="extracting-function-arguments"><strong>Extracting Function Arguments</strong></h4>
<p>You can use the <code class="language-plaintext highlighter-rouge">infer</code> keyword to extract the types of function parameters as well.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">ParameterType</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="p">(</span><span class="nx">arg</span><span class="p">:</span> <span class="nx">infer</span> <span class="nx">U</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">any</span> <span class="p">?</span> <span class="nx">U</span> <span class="p">:</span> <span class="nx">never</span><span class="p">;</span>

<span class="kd">type</span> <span class="nx">MyFunction</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">string</span><span class="p">;</span>

<span class="kd">type</span> <span class="nx">Param</span> <span class="o">=</span> <span class="nx">ParameterType</span><span class="o">&lt;</span><span class="nx">MyFunction</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// Param will be `number`</span>
</code></pre></div></div>

<p>In this example, <code class="language-plaintext highlighter-rouge">ParameterType</code> extracts the type of the parameter passed to the function. If <code class="language-plaintext highlighter-rouge">MyFunction</code> takes a <code class="language-plaintext highlighter-rouge">number</code>, then <code class="language-plaintext highlighter-rouge">Param</code> will be <code class="language-plaintext highlighter-rouge">number</code>.</p>

<h4 id="discriminated-unions-with-infer"><strong>Discriminated Unions with <code class="language-plaintext highlighter-rouge">infer</code></strong></h4>
<p>You can use <code class="language-plaintext highlighter-rouge">infer</code> to narrow types in conditional types when dealing with <strong>discriminated unions</strong>.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Shape</span> <span class="o">=</span> 
  <span class="o">|</span> <span class="p">{</span> <span class="na">kind</span><span class="p">:</span> <span class="dl">'</span><span class="s1">circle</span><span class="dl">'</span><span class="p">,</span> <span class="na">radius</span><span class="p">:</span> <span class="kr">number</span> <span class="p">}</span>
  <span class="o">|</span> <span class="p">{</span> <span class="na">kind</span><span class="p">:</span> <span class="dl">'</span><span class="s1">square</span><span class="dl">'</span><span class="p">,</span> <span class="na">sideLength</span><span class="p">:</span> <span class="kr">number</span> <span class="p">};</span>

<span class="kd">type</span> <span class="nx">GetShapeType</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="p">{</span> <span class="na">kind</span><span class="p">:</span> <span class="dl">'</span><span class="s1">circle</span><span class="dl">'</span> <span class="p">}</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">Circle</span><span class="dl">'</span> <span class="p">:</span>
                      <span class="nx">T</span> <span class="kd">extends</span> <span class="p">{</span> <span class="na">kind</span><span class="p">:</span> <span class="dl">'</span><span class="s1">square</span><span class="dl">'</span> <span class="p">}</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">Square</span><span class="dl">'</span> <span class="p">:</span>
                      <span class="nx">never</span><span class="p">;</span>

<span class="kd">type</span> <span class="nx">CircleType</span> <span class="o">=</span> <span class="nx">GetShapeType</span><span class="o">&lt;</span><span class="p">{</span> <span class="na">kind</span><span class="p">:</span> <span class="dl">'</span><span class="s1">circle</span><span class="dl">'</span><span class="p">,</span> <span class="na">radius</span><span class="p">:</span> <span class="mi">10</span> <span class="p">}</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// 'Circle'</span>
<span class="kd">type</span> <span class="nx">SquareType</span> <span class="o">=</span> <span class="nx">GetShapeType</span><span class="o">&lt;</span><span class="p">{</span> <span class="na">kind</span><span class="p">:</span> <span class="dl">'</span><span class="s1">square</span><span class="dl">'</span><span class="p">,</span> <span class="na">sideLength</span><span class="p">:</span> <span class="mi">20</span> <span class="p">}</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// 'Square'</span>
</code></pre></div></div>

<p>Here, we use a conditional type to map over a <strong>discriminated union</strong> to extract the types based on the <code class="language-plaintext highlighter-rouge">kind</code> property.</p>

<p><br /></p>

<h3 id="4-using-utility-types-for-type-transformation"><strong>4. Using Utility Types for Type Transformation</strong></h3>

<p>TypeScript also offers a range of <strong>utility types</strong> that make it easier to manipulate types in common scenarios. These types include <code class="language-plaintext highlighter-rouge">Partial</code>, <code class="language-plaintext highlighter-rouge">Required</code>, <code class="language-plaintext highlighter-rouge">Readonly</code>, <code class="language-plaintext highlighter-rouge">Record</code>, etc.</p>

<h4 id="example-pick-omit-and-exclude"><strong>Example: <code class="language-plaintext highlighter-rouge">Pick</code>, <code class="language-plaintext highlighter-rouge">Omit</code>, and <code class="language-plaintext highlighter-rouge">Exclude</code></strong></h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nl">address</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Pick specific keys from the interface</span>
<span class="kd">type</span> <span class="nx">NameAndAge</span> <span class="o">=</span> <span class="nb">Pick</span><span class="o">&lt;</span><span class="nx">Person</span><span class="p">,</span> <span class="dl">'</span><span class="s1">name</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">age</span><span class="dl">'</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// { name: string; age: number }</span>

<span class="c1">// Omit specific keys from the interface</span>
<span class="kd">type</span> <span class="nx">WithoutAddress</span> <span class="o">=</span> <span class="nx">Omit</span><span class="o">&lt;</span><span class="nx">Person</span><span class="p">,</span> <span class="dl">'</span><span class="s1">address</span><span class="dl">'</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// { name: string; age: number }</span>

<span class="c1">// Exclude specific types from a union</span>
<span class="kd">type</span> <span class="nx">WithoutString</span> <span class="o">=</span> <span class="nx">Exclude</span><span class="o">&lt;</span><span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span> <span class="o">|</span> <span class="nx">boolean</span><span class="p">,</span> <span class="kr">string</span><span class="o">&gt;</span><span class="p">;</span>  <span class="c1">// number | boolean</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">Pick&lt;T, K&gt;</code></strong>: Picks a subset of properties from a type <code class="language-plaintext highlighter-rouge">T</code>.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Omit&lt;T, K&gt;</code></strong>: Omit specific properties from a type <code class="language-plaintext highlighter-rouge">T</code>.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Exclude&lt;T, U&gt;</code></strong>: Excludes types from a union type.</li>
</ul>

<p>These utility types are often used for type manipulation, allowing you to create new types based on existing ones.</p>

<p><br /></p>

<h3 id="5-key-takeaways-of-type-manipulation"><strong>5. Key Takeaways of Type Manipulation</strong></h3>

<table>
  <thead>
    <tr>
      <th><strong>Concept</strong></th>
      <th><strong>Explanation</strong></th>
      <th><strong>Example</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Conditional Types</strong></td>
      <td>Types that select one type over another based on a condition.</td>
      <td><code class="language-plaintext highlighter-rouge">type IsString&lt;T&gt; = T extends string ? true : false;</code></td>
    </tr>
    <tr>
      <td><strong><code class="language-plaintext highlighter-rouge">infer</code> Keyword</strong></td>
      <td>Extracts a type within a conditional type, useful for inferring function return types or extracting types from more complex types.</td>
      <td><code class="language-plaintext highlighter-rouge">type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never;</code></td>
    </tr>
    <tr>
      <td><strong>Function Arguments</strong></td>
      <td>Extracts the types of function arguments.</td>
      <td><code class="language-plaintext highlighter-rouge">type Param&lt;T&gt; = T extends (arg: infer U) =&gt; any ? U : never;</code></td>
    </tr>
    <tr>
      <td><strong>Discriminated Unions</strong></td>
      <td>Conditional types combined with discriminated unions to narrow down types.</td>
      <td><code class="language-plaintext highlighter-rouge">type ShapeType&lt;T&gt; = T extends { kind: 'circle' } ? 'Circle' : T extends { kind: 'square' } ? 'Square' : never;</code></td>
    </tr>
    <tr>
      <td><strong>Utility Types</strong></td>
      <td>Built-in utility types like <code class="language-plaintext highlighter-rouge">Pick</code>, <code class="language-plaintext highlighter-rouge">Omit</code>, <code class="language-plaintext highlighter-rouge">Partial</code>, <code class="language-plaintext highlighter-rouge">Required</code>, and <code class="language-plaintext highlighter-rouge">Exclude</code> allow transformation of types in useful ways.</td>
      <td><code class="language-plaintext highlighter-rouge">type NameAndAge = Pick&lt;Person, 'name' | 'age'&gt;;</code></td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h3 id="6-conclusion"><strong>6. Conclusion</strong></h3>

<p>Type manipulation in TypeScript allows you to create flexible, reusable, and strongly typed code by leveraging the power of conditional types, <code class="language-plaintext highlighter-rouge">infer</code>, and utility types. These tools enable complex type transformations that are both expressive and maintainable, making TypeScript a robust language for building large and scalable applications.</p>


  </div>

  
  <div style="margin-top: 20px;" class="related-posts">
  

  <div class="disqus-comments"><div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'https://anusree6154s.github.io/documentation/type-manipulation';
      this.page.identifier = 'https://anusree6154s.github.io/documentation/type-manipulation';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://anusree-anilkumar-blog.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></div>

  <a class="u-url" href="/documentation/type-manipulation" hidden></a>
</article>
      </div>
    </main><!-- <footer class="site-footer h-card">
    <data class="u-url" href="/documentation/"></data>
  
    <div class="wrapper">
  
      <div class="footer-col-wrapper">
        <div class="footer-col">
          <p class="feed-subscribe">
            <a href="https://anusree6154s.github.io/documentation/feed.xml">
              <svg class="svg-icon orange">
                <path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194
                  11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017 0
                  13.806c0-1.21.983-2.195 2.194-2.195zM10.606
                  16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"
                />
              </svg><span>Subscribe</span>
            </a>
          </p>
          <ul class="contact-list">
            
          </ul>
        </div>
        <div class="footer-col">
          <p>Tech Blog</p>
        </div>
      </div>
  
      <div class="social-links"><ul class="social-media-list"><li><a href="https://github.com/Anusree6154s"><svg class="svg-icon"><use xlink:href="/documentation/assets/minima-social-icons.svg#github"></use></svg> <span class="username">Anusree6154s</span></a></li><li><a href="https://www.linkedin.com/in/anusreeanilkumar1"><svg class="svg-icon"><use xlink:href="/documentation/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">anusreeanilkumar1</span></a></li><li><a href="https://www.twitter.com/anu6154s"><svg class="svg-icon"><use xlink:href="/documentation/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">anu6154s</span></a></li><li><a href="/documentation/feed.xml"><svg class="svg-icon"><use xlink:href="/documentation/assets/minima-social-icons.svg#rss"></use></svg> <span>rss</span></a></li></ul>
</div>
  
    </div>
  
  </footer> -->

<footer id="contact">
  <section class="footer-inner">
    <div class="contact">
      <div class="contact-inner">
        <p>CONTACT</p>
        <p>
          <span class="logo"></span><span>anilkumaranusree113@gmail.com</span>
        </p>
        <p><span class="logo"></span><span>+91-9699973230</span></p>
        <p><span class="logo"></span><span>Surat, Gujarat, India</span></p>
      </div>

      <div class="socials">
        <a href="https://www.linkedin.com/in/anusreeanilkumar1/"
          ><span></span
        ></a>
        <a href="https://github.com/Anusree6154s"><span></span></a>
        <a href="https://x.com/anu6154s"><span></span></a>
      </div>
    </div>
    <div class="list">
      <div class="sections">
        <p>SECTIONS</p>
        <a href="/documentation/#latest-posts">Latest Posts</a>
        <a href="/documentation/all-posts">All Posts</a>
        <a href="/documentation/#projects">Projects</a>
        <a href="/documentation/#profile">Profile</a>
      </div>
      <div class="links">
        <p>LINKS</p>
        <a href="https://anusreeanilkumar.vercel.app/">Personal Portfolio</a>
        <a href="https://www.crio.do/learn/portfolio/anilkumaranusree113/"
          >Crio.Do Portfolio</a
        >
        <a href="https://anusreeanilkumar.vercel.app/projects">All Projects</a>
        <a
          href="https://drive.google.com/file/d/1Y8_r1SKBmwClHUr-pszQpEmI3XLBEbTO/view?usp=sharing"
          >Resume</a
        >
      </div>
    </div>
  </section>

  <section class="sub-footer">@ 2025 Anusree Anilkumar</section>
</footer>
</body>

</html>
